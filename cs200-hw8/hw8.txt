Directory structure:
└── cs200-hw8/
    ├── README.md
    ├── CMakeLists.txt
    ├── CMakePresets.json
    ├── .clang-format
    ├── app_resources/
    │   └── web/
    │       └── index_shell.html
    ├── Assets/
    │   └── shaders/
    │       ├── basic_vtx_clr_attribute.frag
    │       ├── pass_thru_pos2d_clr.vert
    │       ├── BatchRenderer2D/
    │       │   ├── quad.frag
    │       │   ├── quad.vert
    │       │   ├── sdf.frag
    │       │   └── sdf.vert
    │       ├── DemoBufferTypes/
    │       │   ├── background.frag
    │       │   ├── background.vert
    │       │   ├── villager.frag
    │       │   └── villager.vert
    │       ├── DemoTexturing/
    │       │   ├── combine.frag
    │       │   └── combine.vert
    │       ├── ImmediateRenderer2D/
    │       │   ├── quad.frag
    │       │   ├── quad.vert
    │       │   ├── sdf.frag
    │       │   └── sdf.vert
    │       ├── InstancedRenderer2D/
    │       │   ├── quad.frag
    │       │   ├── quad.vert
    │       │   ├── sdf.frag
    │       │   └── sdf.vert
    │       ├── PostProcess/
    │       │   ├── box-blur.frag
    │       │   ├── chromatic-aberration.frag
    │       │   ├── gamma-correct.frag
    │       │   ├── pixelize.frag
    │       │   ├── simple-texture.frag
    │       │   └── simple.vert
    │       └── shape/
    │           ├── shape.frag
    │           └── shape.vert
    ├── cmake/
    │   ├── CompilerWarnings.cmake
    │   ├── Dependencies.cmake
    │   ├── StandardProjectSettings.cmake
    │   └── dependencies/
    │       ├── DearImGUI.cmake
    │       ├── GLEW.cmake
    │       ├── GSL.cmake
    │       ├── OpenGL.cmake
    │       ├── SDL2.cmake
    │       └── STB.cmake
    ├── docs/
    │   ├── DebuggingWeb.md
    │   └── DevEnvironment.md
    ├── scripts/
    │   └── scan_build_project.py
    └── source/
        ├── CMakeLists.txt
        ├── main.cpp
        ├── CS200/
        │   ├── BatchRenderer2D.cpp
        │   ├── BatchRenderer2D.h
        │   ├── Image.cpp
        │   ├── Image.h
        │   ├── ImGuiHelper.cpp
        │   ├── ImGuiHelper.h
        │   ├── ImmediateRenderer2D.cpp
        │   ├── ImmediateRenderer2D.h
        │   ├── InstancedRenderer2D.cpp
        │   ├── InstancedRenderer2D.h
        │   ├── IRenderer2D.h
        │   ├── NDC.h
        │   ├── OffscreenFramebuffer.cpp
        │   ├── OffscreenFramebuffer.h
        │   ├── PostProcessingPipeline.cpp
        │   ├── PostProcessingPipeline.h
        │   ├── Renderer2DUtils.cpp
        │   ├── Renderer2DUtils.h
        │   ├── RenderingAPI.cpp
        │   ├── RenderingAPI.h
        │   ├── RGBA.h
        │   ├── Shape.cpp
        │   └── Shape.h
        ├── Demo/
        │   ├── DemoDepthPost.cpp
        │   └── DemoDepthPost.h
        ├── Engine/
        │   ├── Animation.cpp
        │   ├── Animation.h
        │   ├── Camera.cpp
        │   ├── Camera.h
        │   ├── Collision.cpp
        │   ├── Collision.h
        │   ├── Component.h
        │   ├── ComponentManager.h
        │   ├── Engine.cpp
        │   ├── Engine.h
        │   ├── Error.h
        │   ├── Font.cpp
        │   ├── Font.h
        │   ├── Fonts.h
        │   ├── FPS.h
        │   ├── GameObject.cpp
        │   ├── GameObject.h
        │   ├── GameObjectManager.cpp
        │   ├── GameObjectManager.h
        │   ├── GameState.h
        │   ├── GameStateManager.cpp
        │   ├── GameStateManager.h
        │   ├── Input.cpp
        │   ├── Input.h
        │   ├── Logger.cpp
        │   ├── Logger.h
        │   ├── Matrix.cpp
        │   ├── Matrix.h
        │   ├── Particle.cpp
        │   ├── Particle.h
        │   ├── Path.cpp
        │   ├── Path.h
        │   ├── Random.cpp
        │   ├── Random.h
        │   ├── Rect.h
        │   ├── ShowCollision.cpp
        │   ├── ShowCollision.h
        │   ├── Sprite.cpp
        │   ├── Sprite.h
        │   ├── TextManager.cpp
        │   ├── TextManager.h
        │   ├── Texture.cpp
        │   ├── Texture.h
        │   ├── TextureManager.cpp
        │   ├── TextureManager.h
        │   ├── Timer.h
        │   ├── Vec2.cpp
        │   ├── Vec2.h
        │   ├── Window.cpp
        │   └── Window.h
        ├── Game/
        │   ├── Background.cpp
        │   ├── Background.h
        │   ├── GameObjectTypes.h
        │   ├── MainMenu.cpp
        │   ├── MainMenu.h
        │   ├── Particles.h
        │   ├── Score.cpp
        │   ├── Score.h
        │   ├── Splash.cpp
        │   ├── Splash.h
        │   └── States.h
        └── OpenGL/
            ├── Buffer.cpp
            ├── Buffer.h
            ├── Environment.h
            ├── Framebuffer.cpp
            ├── Framebuffer.h
            ├── GL.cpp
            ├── GL.h
            ├── GLConstants.h
            ├── GLTypes.h
            ├── Handle.h
            ├── Shader.cpp
            ├── Shader.h
            ├── Texture.cpp
            ├── Texture.h
            ├── VertexArray.cpp
            └── VertexArray.h

================================================
FILE: README.md
================================================
# CS200 Computer Graphics I

## How to Build and Run

First Setup your [Development Environment](docs/DevEnvironment.md)

### Command Line Build

**Windows**

```sh
# configure / generate build files
cmake --preset windows-debug
cmake --preset windows-developer-release
cmake --preset windows-release
cmake --preset web-debug-on-windows

# Build exe
cmake --build --preset windows-debug
cmake --build --preset windows-developer-release
cmake --build --preset windows-release
cmake --build --preset web-debug-on-windows
```

**Linux**

```sh
# configure / generate build files
cmake --preset linux-debug
cmake --preset linux-developer-release
cmake --preset linux-release
cmake --preset web-debug
cmake --preset web-developer-release
cmake --preset web-release

# Build exe
cmake --build --preset linux-debug
cmake --build --preset linux-developer-release
cmake --build --preset linux-release
cmake --build --preset web-debug
cmake --build --preset web-developer-release
cmake --build --preset web-release
```

### Automated Build Script

For convenience, use the automated build script that handles all configurations:

```sh
python3 scripts/scan_build_project.py
```

See the script help for filtering options:

```sh
python3 scripts/scan_build_project.py --help
```

## Build Configurations

This project supports three distinct build configurations, each designed for different stages of development and deployment:

### **Debug Configuration**

- **Purpose**: Active development and debugging
- **Features**: 
  - Allows setting breakpoints to step through code line-by-line
  - No compiler optimizations (preserves variable values for debugging)
  - Console window for viewing debug output
  - All developer helper features enabled
- **Performance**: Slower execution, larger executable size
- **When to use**: When you need to debug issues or understand code flow

### **Developer-Release Configuration**

- **Purpose**: Testing with optimized performance while keeping developer tools
- **Features**:
  - Compiler optimizations enabled (faster execution)
  - Cannot set breakpoints (optimizations interfere with debugging)
  - Console window for viewing output
  - Verbose logging and error checking enabled
  - Developer assertions active
- **Performance**: Fast execution, optimized code
- **When to use**: Performance testing while retaining diagnostic capabilities

### **Release Configuration**

- **Purpose**: Final builds for end users
- **Features**:
  - Full compiler optimizations
  - No console window (clean user experience)
  - Minimal logging (only critical errors)
  - No developer features or extra error checking
  - Smallest executable size
- **Performance**: Maximum speed, production-ready
- **When to use**: Final builds for distribution to users

## CMake Presets

CMake presets simplify the build process by pre-configuring complex settings. Instead of manually specifying:

- Compiler flags and optimization levels
- Output directories and build paths  
- Platform-specific configurations
- Dependency locations
- Debug/release-specific settings

The presets handle all of this automatically. For example, `cmake --preset linux-debug` is equivalent to running:

```sh
cmake -S . -B build/linux-debug \
  -DCMAKE_BUILD_TYPE=Debug \
  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
  -DDEVELOPER_VERSION=ON \
  [... many more flags ...]
```

This saves time and reduces configuration errors, especially when working across different platforms and build types.



================================================
FILE: CMakeLists.txt
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology
cmake_minimum_required(VERSION 3.21)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_EXTENSIONS OFF)

# #  Helper to print out all environment variables
# get_cmake_property(_variableNames VARIABLES)
# list (SORT _variableNames)
# foreach (_variableName ${_variableNames})
#     message(STATUS "${_variableName}=${${_variableName}}")
# endforeach()

project(engine_porting)

include(cmake/StandardProjectSettings.cmake)

include(cmake/CompilerWarnings.cmake)
add_library(project_options INTERFACE)
target_compile_features(project_options INTERFACE cxx_std_20)
set_project_warnings(project_options)

include(cmake/Dependencies.cmake)

add_subdirectory(source)




================================================
FILE: CMakePresets.json
================================================
{
    "version": 3,
    "cmakeMinimumRequired": {
        "major": 3,
        "minor": 21,
        "patch": 0
    },
    "configurePresets": [
        {
            "name": "conf-common",
            "description": "General settings that apply to all configurations",
            "hidden": true,
            "binaryDir": "${sourceDir}/build/${presetName}",
            "installDir": "${sourceDir}/build/install/${presetName}"
        },
        {
            "name": "conf-windows-common",
            "description": "Windows settings for MSBuild toolchain that apply to msvc and clang",
            "hidden": true,
            "inherits": "conf-common",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "toolset": {
                "value": "host=x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_C_COMPILER": "cl",
                "CMAKE_CXX_COMPILER": "cl"
            }
        },
        {
            "name": "conf-unixlike-common",
            "description": "Unix-like OS settings for gcc and clang toolchains",
            "hidden": true,
            "inherits": "conf-common",
            "generator": "Ninja",
            "condition": {
                "type": "inList",
                "string": "${hostSystemName}",
                "list": [
                    "Linux",
                    "Darwin"
                ]
            },
            "cacheVariables": {
                "CMAKE_C_COMPILER": "gcc",
                "CMAKE_CXX_COMPILER": "g++"
            }
        },
        {
            "name": "conf-web-common",
            "description": "Common Web/Emscripten configuration",
            "hidden": true,
            "inherits": "conf-unixlike-common",
            "generator": "Ninja",
            "toolchainFile": "~/emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake",
            "cacheVariables": {
                "CMAKE_C_COMPILER": "~/emsdk/upstream/emscripten/emcc",
                "CMAKE_CXX_COMPILER": "~/emsdk/upstream/emscripten/em++"
            }
        },
        {
            "name": "windows-debug",
            "displayName": "Windows Debug",
            "description": "Debug Build on Windows",
            "inherits": "conf-windows-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "windows-developer-release",
            "displayName": "Windows Developer Release",
            "description": "Optimized Developer Build on Windows",
            "inherits": "conf-windows-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "windows-release",
            "displayName": "Windows Release",
            "description": "Optimized User Facing Build on Windows",
            "inherits": "conf-windows-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "FALSE"
            }
        },
        {
            "name": "web-debug-on-windows",
            "displayName": "Web Debug on Windows",
            "description": "Debug Build on Web for Windows",
            "inherits": "conf-common",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "generator": "Ninja",
            "toolchainFile": "$env{USERPROFILE}/emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake",
            "cacheVariables": {
                "CMAKE_C_COMPILER": "$env{USERPROFILE}/emsdk/upstream/emscripten/emcc",
                "CMAKE_CXX_COMPILER": "$env{USERPROFILE}/emsdk/upstream/emscripten/em++",
                "CMAKE_BUILD_TYPE": "Debug",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "linux-debug",
            "displayName": "Linux Debug",
            "description": "Debug Build on Linux",
            "inherits": "conf-unixlike-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "linux-developer-release",
            "displayName": "Linux Developer Release",
            "description": "Optimized Developer Build on Linux",
            "inherits": "conf-unixlike-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "linux-release",
            "displayName": "Linux Release",
            "description": "Optimized User Facing Build on Linux",
            "inherits": "conf-unixlike-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "FALSE"
            }
        },
        {
            "name": "web-debug",
            "displayName": "Web Debug",
            "description": "Debug Build on Web",
            "inherits": "conf-web-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "web-developer-release",
            "displayName": "Web Developer Release",
            "description": "Optimized Developer Build on Web",
            "inherits": "conf-web-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "TRUE"
            }
        },
        {
            "name": "web-release",
            "displayName": "Web Release",
            "description": "Optimized User Facing Build on Web",
            "inherits": "conf-web-common",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "IS_DEVELOPER_VERSION": "FALSE"
            }
        }
    ],
    "buildPresets": [
        {
            "name": "build-windows-common",
            "description": "Windows build settings",
            "hidden": true,
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            }
        },
        {
            "name": "build-unixlike-common",
            "description": "Unix-like build settings",
            "hidden": true,
            "condition": {
                "type": "inList",
                "string": "${hostSystemName}",
                "list": [
                    "Linux",
                    "Darwin"
                ]
            }
        },
        {
            "name": "windows-debug",
            "configurePreset": "windows-debug",
            "inherits": "build-windows-common",
            "configuration": "Debug"
        },
        {
            "name": "windows-developer-release",
            "configurePreset": "windows-developer-release",
            "inherits": "build-windows-common",
            "configuration": "RelWithDebInfo"
        },
        {
            "name": "windows-release",
            "configurePreset": "windows-release",
            "inherits": "build-windows-common",
            "configuration": "Release"
        },
        {
            "name": "web-debug-on-windows",
            "configurePreset": "web-debug-on-windows",
            "inherits": "build-windows-common",
            "configuration": "Debug"
        },
        {
            "name": "linux-debug",
            "configurePreset": "linux-debug",
            "inherits": "build-unixlike-common",
            "configuration": "Debug"
        },
        {
            "name": "linux-developer-release",
            "configurePreset": "linux-developer-release",
            "inherits": "build-unixlike-common",
            "configuration": "RelWithDebInfo"
        },
        {
            "name": "linux-release",
            "configurePreset": "linux-release",
            "inherits": "build-unixlike-common",
            "configuration": "Release"
        },
        {
            "name": "web-debug",
            "configurePreset": "web-debug",
            "inherits": "build-unixlike-common",
            "configuration": "Debug"
        },
        {
            "name": "web-developer-release",
            "configurePreset": "web-developer-release",
            "inherits": "build-unixlike-common",
            "configuration": "RelWithDebInfo"
        },
        {
            "name": "web-release",
            "configurePreset": "web-release",
            "inherits": "build-unixlike-common",
            "configuration": "Release"
        }
    ]
}



================================================
FILE: .clang-format
================================================
# clang-format version 14
Language : Cpp
Standard : Latest

AccessModifierOffset: -4
AlignAfterOpenBracket: AlwaysBreak
AlignArrayOfStructures: Right
AlignConsecutiveAssignments: AcrossComments
AlignConsecutiveBitFields: AcrossEmptyLinesAndComments
AlignConsecutiveDeclarations: AcrossComments
AlignConsecutiveMacros: AcrossComments
AlignEscapedNewlines: Right
AlignOperands: Align
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: true
AllowAllParametersOfDeclarationOnNextLine: true
AllowShortBlocksOnASingleLine: Never
AllowShortCaseLabelsOnASingleLine: true
AllowShortEnumsOnASingleLine: true
AllowShortFunctionsOnASingleLine: None
AllowShortIfStatementsOnASingleLine: Never
AllowShortLambdasOnASingleLine: Inline
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: Yes
BinPackArguments: true
BinPackParameters: true
BitFieldColonSpacing: Both
BreakAfterJavaFieldAnnotations: true
BreakBeforeBinaryOperators: None
BreakBeforeBraces: Allman
BreakBeforeConceptDeclarations: true
BreakBeforeTernaryOperators: true
BreakConstructorInitializers: BeforeColon
BreakInheritanceList: BeforeColon
BreakStringLiterals: false
ColumnLimit: 200
CompactNamespaces: true
ContinuationIndentWidth: 4
Cpp11BracedListStyle: false
DeriveLineEnding: true
DerivePointerAlignment: false
EmptyLineAfterAccessModifier: Leave
EmptyLineBeforeAccessModifier: LogicalBlock
FixNamespaceComments: false
IncludeBlocks: Preserve
IndentAccessModifiers: false
IndentCaseBlocks: true
IndentCaseLabels: true
IndentExternBlock: NoIndent
IndentGotoLabels: false
IndentPPDirectives: AfterHash
IndentRequires: false
IndentWidth: 4
IndentWrappedFunctionNames: true
KeepEmptyLinesAtTheStartOfBlocks: false
LambdaBodyIndentation: Signature
MaxEmptyLinesToKeep: 2
NamespaceIndentation: All
PPIndentWidth: -1
PackConstructorInitializers: BinPack
PointerAlignment: Left
# QualifierOrder: ['static', 'constexpr', 'inline', 'const', 'type' ]
ReferenceAlignment: Left
ReflowComments: true
SeparateDefinitionBlocks: Always
SortIncludes: CaseSensitive
SortUsingDeclarations: true
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCaseColon: false
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeRangeBasedForLoopColon: true
SpaceBeforeSquareBrackets: false
SpaceInEmptyBlock: true
SpaceInEmptyParentheses: false
SpacesInAngles: Never
SpacesInCStyleCastParentheses: false
SpacesInConditionalStatement: false
SpacesInContainerLiterals: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
TabWidth: 4
UseCRLF: false
UseTab: true



================================================
FILE: app_resources/web/index_shell.html
================================================
<!doctype html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="icon" href="https://www.digipen.edu/themes/custom/digipen_future/favicon.ico"
        type="image/vnd.microsoft.icon" />
    <title>DigiPen Programming Fun</title>
    <meta name="description" content="Computer Programming Fun for DigiPen classes">

    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
    <meta name="mobile-web-app-capable" content="yes" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <style>
        body {
            overflow-y: hidden;
            overflow-x: hidden;
            margin: 0;
            background-color: #FFFFFF;
            -webkit-font-smoothing: subpixel-antialiased;
            font-smoothing: subpixel-antialiased;
        }

        #main-container {
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }

        .emscripten {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: 100%;
            background: transparent;
            background-color: #00000000;
        }

        canvas.emscripten {
            border: 0px none;
            background: transparent;
            background-color: #00000000;
        }

        #description {
            margin: 10px;
            padding: 10px;
            color: #000000;
        }
    </style>
</head>

<body>
    <div id="main-container">
        <div id="description" align="center">
            <h2>DigiPen Korea Graphics I</h2>

            <div id="container_status" align="center">
                Loading - please wait ..
            </div>
        </div>
        <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div>

    <script type='text/javascript'>
        // Set background image via JavaScript
        function setBackgroundImage() {
            document.body.style.backgroundImage = "url('data:image/svg+xml;base64,\
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbDpzcGFjZT0icHJlc2VydmUiIGFyaWEtbGFiZWxsZWRieT0ibG9nb190aXRsZSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pbllNaW4gbWVldCIgdmlld0JveD0iMCAyOTAuNSA2MTMuNSAyMTEiPgogIDx0aXRsZT5EaWdpUGVuIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5PC90aXRsZT4KICA8cGF0aCBkPSJNMTEzLjMgMzk2LjZhMzcgMzcgMCAwIDAgMzcuNC0zNi43YzAtMjAtMTcuMS0zNi43LTM4LjEtMzYuN0g4NS4zdjczLjFoMjcuOHYuM2guMnptLTc0IDczLjZhMzcgMzcgMCAwIDEtMzcuNC0zNi42QTM3LjYgMzcuNiAwIDAgMSAzOS44IDM5N2gyNy4zdjczLjFIMzkuM3YuMXptMzIuMi0xNDcuMWg5Ljd2MTQ3LjFoLTkuN3ptMzE3LjEgMTguOGMwIDIuNi0yLjYgNC42LTUuNiA0LjZoLTE1Yy0zLjEgMC01LjYtMi4xLTUuNi00LjZ2LTcuN2MwLTIuNiAyLjYtNC42IDUuNi00LjZoMTVjMy4xIDAgNS42IDIuMSA1LjYgNC42djcuN3ptLTI2LjUgOC45aDI2LjV2NjMuNmgtMjYuNXptLTgwLjItOC45YzAgMi42LTIuNiA0LjYtNS42IDQuNmgtMTVjLTMuMSAwLTUuOC0yLjEtNS44LTQuNnYtNy43YzAtMi42IDIuNi00LjYgNS44LTQuNmgxNWMzLjEgMCA1LjYgMi4xIDUuNiA0LjZ2Ny43em0tMjYuNiA4LjloMjYuNXY2My42aC0yNi41ek00NzEuOCAzMzljLTMuMS01LTcuNS04LjktMTIuOC0xMS42YTQxLjQgNDEuNCAwIDAgMC0xOC42LTQuMUgzOTh2OTEuMmgyNi4zVjM4N2gxOC4zYzQuOCAwIDkuMS0uOSAxMy4yLTIuNiAzLjktMS43IDcuNy0zLjkgMTAuOS02LjggMy4xLTIuOSA1LjYtNi4yIDcuMi0xMC40IDEuNy0zLjkgMi42LTcgMi42LTExLjRhMzYuNyAzNi43IDAgMCAwLTQuNy0xNi44bS0zNS40IDI3LjJoLTEydi0yMS40aDExLjhjNiAwIDEwLjkgNC44IDEwLjkgMTAuNi40IDYtNC42IDEwLjgtMTAuNyAxMC44bTE3Mi45LTguNmEyMS4xIDIxLjEgMCAwIDAtOS42LTcuOSAzOC4xIDM4LjEgMCAwIDAtMTQuNC0yLjdoLTM5LjV2NjcuNWgyNi41di0zNy42YzAtNC44IDIuMS02LjggNi43LTYuOCA0LjggMCA2LjcgMi4xIDYuNyA2Ljh2MzcuOWgyNi41di00NC45Yy41LTQuNy0uNS05LTIuOS0xMi4zbS02OSAyOS40Yy4zLTIuMS43LTQuMy43LTYuNWEzMy41IDMzLjUgMCAwIDAtMzMuMS0zMy43Yy0xOC41IDAtMzMuMSAxNS0zMy4xIDMzLjcgMCAxOC42IDE0LjkgMzQgMzMuMSAzNCAxMi41IDAgMjMuNC03IDI4LjktMTcuNGgtMjIuOWMtNS44IDAtMTAuNi0xLjQtMTAuNi03LjVWMzg3aDM3em0tMzcuMS0xMy44di0xLjdjMC00LjggMy44LTguNyA4LjItOC43IDQuOCAwIDguMiAzLjkgOC4yIDguNXYxLjdsLTE2LjQuMnptLTIwNSA2OS4yaDIzLjdjNy4yIDAgMTMuOC0yLjYgMTkuMy02LjcgNy4yLTUuOCAxMi0xNC45IDEyLTI0Ljl2LTYxLjNoLTMwLjhhNDMgNDMgMCAwIDAtMTMuMiAyLjIgMzYgMzYgMCAwIDAtMTAuNiA2LjcgMzEuOCAzMS44IDAgMCAwIDMuOCA0OC41YzEgLjcgMS45IDEuMiAyLjcgMS45IDQuMSAyLjYgOC45IDMuOSAxMy43IDQuMWg3djEuNWMwIDEuNy0uMyAyLjYtMSAzLjItMS43IDIuNi01IDMuMi05LjEgMy4yaC0xOC4xYy42LjYuNiAyMS42LjYgMjEuNnptMjUuMS03Mi41aDcuNXYyMGgtNy43Yy01LjYgMC0xMC4xLTQuNi0xMC4xLTkuOSAwLTUuNiA0LjUtMTAuMSAxMC4zLTEwLjFtLTgxLjUtMjMuNGMtNC4xLTctOS43LTEyLjYtMTcuMS0xNi43LTctNC4xLTE0LjktNi4yLTIyLjktNi4yaC0zNi4xdjkwLjdoMzcuNGM1LjMgMCAxMC45LTEuMiAxNi43LTMuOGE1NCA1NCAwIDAgMCAxNC45LTkuNyA0MSA0MSAwIDAgMCA5LjktMTQuNyA0NS41IDQ1LjUgMCAwIDAgMy4yLTE3LjFjLjUtNy44LTEuNi0xNS4zLTYtMjIuNW0tMjEuOSAyOC45Yy0xIDIuMS0yLjIgMy45LTMuOSA1LjZhMTcuMiAxNy4yIDAgMCAxLTUuOCAzLjhjLTIuMiAxLTQuMyAxLjQtNi41IDEuNGgtMTIuOHYtMzQuN0gyMDNjMy4xIDAgNi4yLjkgOC45IDIuNiAyLjcgMS43IDUgMy44IDYuNyA2LjVzMi42IDUuNiAyLjYgOC43Yy4zIDEuOC0uNCA0LjEtMS4zIDYuMW0tNTMuNSA3NC4zaDIuOVY0NzBoLTIuOXptMjguMiAwaC0yLjR2MTUuOGwtMTMuNi0xNS44aC0yLjR2MjAuMmgyLjV2LTE1LjRsMTMuNyAxNS40aDIuMnptMTcgMS4yYTcuNiA3LjYgMCAwIDAtNC42LTEuNGMtMy44IDAtNi4yIDIuMS02LjIgNS4zIDAgNS4zIDguNyA2IDguNyAxMC4xIDAgMS0xIDIuNi0zLjIgMi42LTEuOSAwLTMuOS0xLTUuMy0yLjl2My44YTkuNyA5LjcgMCAwIDAgNS42IDEuOWMzLjIgMCA1LjYtMi4yIDUuNi01LjMgMC02LjUtOC43LTYuNS04LjctMTAuNCAwLTEuNCAxLjItMi42IDMuMi0yLjYgMS4yIDAgMy4xLjMgNC44IDIuMWwuMS0zLjJ6bTIxLjMtMS4yaC0xNi43djIuNmg2Ljh2MTcuNmgyLjl2LTE3LjZoN3ptNS41IDBoMi45VjQ3MGgtMi45em0yNC45IDBoLTE2Ljl2Mi42aDd2MTcuNmgyLjl2LTE3LjZoN3ptMjIuMiAwaC0yLjl2MTEuOGMwIDEuOS0uMiAzLjItMS4yIDQuMy0xIDEtMi42IDEuNy00LjggMS43LTEuOSAwLTMuMi0uMy00LjMtMS45LTEtMS0xLjItMS45LTEuMi00LjF2LTEyaC0yLjl2MTIuNmMwIDUuMyA0LjEgNy45IDguMiA3LjkgNiAwIDkuMS0zLjIgOS4xLTguMnYtMTIuMXptMjEuNyAwaC0xNi45djIuNmg3djE3LjZoMi45di0xNy42aDd6bTE2LjYgMGgtMTEuNHYyMC4yaDExLjd2LTIuNmgtOC44VjQ2MWg4LjN2LTIuNmgtOC4zdi02LjFoOC41em0xOC42IDEwLjFjMC00LjYgMy4yLTcuNyA3LjktNy43IDQuNiAwIDcuOSAzLjIgNy45IDcuNyAwIDQuMy0zLjIgNy43LTcuOSA3LjdhNy42IDcuNiAwIDAgMS03LjktNy43bS0yLjkgMGMwIDUuMyA0LjEgMTAuNCAxMC44IDEwLjQgNi44IDAgMTAuOS01IDEwLjktMTAuNCAwLTUuNi00LjEtMTAuNC0xMC45LTEwLjQtNi41LjItMTAuOCA0LjgtMTAuOCAxMC40bTM4LjUtMTAuMWgtMTAuOHYyMC4yaDIuOXYtOS4yaDcuOXYtMi44aC03Ljl2LTUuNmg3Ljl6bTI3LjggMGgtMTYuOXYyLjZoN3YxNy42aDIuOXYtMTcuNmg3em0xNi42IDBoLTExLjN2MjAuMmgxMS44di0yLjZINDE0VjQ2MWg4LjR2LTIuNkg0MTR2LTYuMWg4LjR6bTIzLjQgMS40Yy0yLjctMS00LjgtMS43LTYuOC0xLjctNi41IDAtMTEuMSA0LjYtMTEuMSAxMC42IDAgNC4xIDMuMiAxMC4xIDEwLjkgMTAuMSAzLjIgMCA1LjMtLjkgNy41LTEuOVY0NjVhMTMuNyAxMy43IDAgMCAxLTcgMi4yYy00LjggMC04LjItMy4xLTguMi03LjdzMy4yLTcuNyA4LTcuN2MyLjYgMCA0LjYuNyA2LjggMi4xdi0yLjdoLS4xem0yMy4xLTEuNGgtMi44djguOWgtMTEuNHYtOC45aC0yLjl2MjAuMmgyLjl2LTguNmgxMS40djguNmgyLjh6bTI1LjggMGgtMi44djE1LjhsLTEzLjYtMTUuOEg0NzZ2MjAuMmgyLjZ2LTE1LjRsMTMuNyAxNS40aDIuNHptOSAxMC4xYzAtNC42IDMuMi03LjcgNy45LTcuN3M3LjkgMy4yIDcuOSA3LjdjMCA0LjMtMy4yIDcuNy03LjkgNy43YTcuNSA3LjUgMCAwIDEtNy45LTcuN20tMi45IDBjMCA1LjMgNC4xIDEwLjQgMTAuOCAxMC40IDYuOCAwIDEwLjktNSAxMC45LTEwLjQgMC01LjYtNC4xLTEwLjQtMTAuOC0xMC40LTYuOC4yLTEwLjkgNC44LTEwLjkgMTAuNG0zMC42LTEwLjFoLTIuOXYyMC4yaDExLjl2LTIuNmgtOXptMTYuMSAxMC4xYzAtNC42IDMuMi03LjcgNy45LTcuN3M3LjkgMy4yIDcuOSA3LjdjMCA0LjMtMy4yIDcuNy03LjkgNy43YTcuNiA3LjYgMCAwIDEtNy45LTcuN20tMyAwYzAgNS4zIDQuMSAxMC40IDEwLjggMTAuNCA2LjggMCAxMC45LTUgMTAuOS0xMC40IDAtNS42LTQuMS0xMC40LTEwLjgtMTAuNC02LjYgMC0xMC45IDQuOC0xMC45IDEwLjRtNDUuNy4yaC02Ljh2Mi42aDMuOXY0LjFjLTEuNC4zLTIuNy45LTQuMy45LTQuOCAwLTguMi0zLjItOC4yLTcuNyAwLTQuMyAzLjItNy43IDcuOS03LjcgMi42IDAgNC44LjcgNy4yIDEuOXYtMi45Yy0zLjItMS4yLTQuOC0xLjktNy4yLTEuOS02LjIgMC0xMC44IDQuNi0xMC44IDEwLjZzNC42IDEwLjQgMTAuOCAxMC40YzIuNyAwIDUtLjMgNy43LTEuN1Y0NjBoLS4yem0xMy4zLTMuMy01LjUtN2gtMy42bDcuNyA5LjR2MTAuOGgyLjl2LTEwLjRsNy40LTkuOEg2MDl6Ii8+Cjwvc3ZnPgo=')";
            document.body.style.backgroundRepeat = "no-repeat";
            document.body.style.backgroundPosition = "center center";
            document.body.style.backgroundAttachment = "fixed";
            document.body.style.backgroundSize = "contain";
        }

        // Remove background image when Emscripten is loaded
        function removeBackgroundImage() {
            document.body.style.backgroundImage = "none";
        }

        // Set background image on page load
        setBackgroundImage();

        var isInitialized = false;
        var failedToInitialize = false;

        function updateWindowSize() {
            var w = window,
                d = document,
                e = d.documentElement,
                g = d.getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight || e.clientHeight || g.clientHeight;
            Module.setWindowSize(x, y);
        }

        window.setInterval(function () {
            if (isInitialized == false) return;

            updateWindowSize();

        }, 500);

        function onkeydown(event) {
            if (event.ctrlKey ||
                (event.keyCode >= 112 && event.keyCode <= 123)) {
                event.stopImmediatePropagation();
                return;
            }

            if (event.keyCode == 8 || // Backspace
                event.keyCode == 9 || // Tab
                event.keyCode == 46 || // Delete
                (event.keyCode >= 37 && event.keyCode <= 40)) { // Arrow keys
                event.preventDefault();
            }
        }

        function init() {
            document.getElementById('container_status').innerHTML = "WebAssembly module initialized successfully!"
            document.getElementById('container_status').style.color = "#00ff00";

            window.addEventListener('keydown', onkeydown, true);
            // This enables our app to get keyboard focus when displayed through an iframe
            // https://supernapie.com/blog/keyboard-focus-in-an-iframe/
            window.addEventListener('load', function () {
                window.focus();
                document.body.addEventListener('click', function (e) {
                    window.focus();
                }, false);
            });

            if (isInitialized == false) {
                updateWindowSize();
                isInitialized = true;
            }
            {
                var status = document.getElementById("description");
                status.hidden = true;
            }
            
            // Remove background image once Emscripten is fully loaded and displaying
            removeBackgroundImage();
        }

        function getQueryParam(parameterName) {
            const queryParams = new URLSearchParams(window.location.search);
            return queryParams.get(parameterName);
        }

        function buildCommandLineArguments() {
            var param = getQueryParam('start')
            if (param)
                return ['--start', param]
            return []
        }

        var Module = {
            arguments: buildCommandLineArguments(),
            preRun: [(function () { })],
            postRun: [(function () {
                if (failedToInitialize) return;
                init();
            })],
            canvas: (function () {
                var canvas = document.getElementById('canvas');
                canvas.addEventListener("webglcontextlost", function (e) {
                    alert('WebGL context lost. You will need to reload the page.'); e.preventDefault();
                }, false);
                return canvas;
            })(),
            print: function (text) {
                text = Array.prototype.slice.call(arguments).join(' ');
                console.log(text);
            },
            printErr: function (text) {
                text = Array.prototype.slice.call(arguments).join(' ');
                console.error(text);
            },
            setStatus: function (text) {
                if (text) {
                    console.log("html module status: " + text);
                }
            }
        };

        window.onerror = function (event) {
            failedToInitialize = true;
            let reason = JSON.stringify(event);
            console.log("onerror: " + reason);
            document.getElementById('container_status').innerHTML = reason;
            document.getElementById('container_status').innerHTML += '<br>This browser is not supported. Please try a different browser';
            document.getElementById('container_status').style.color = "#ff0000";
        };
    </script>

    {{{ SCRIPT }}}
</body>

</html>



================================================
FILE: Assets/shaders/basic_vtx_clr_attribute.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

in vec3 vColor;

layout(location = 0) out vec4 FragColor;

void main()
{
    FragColor = vec4(vColor, 1.0);
}



================================================
FILE: Assets/shaders/pass_thru_pos2d_clr.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec3 aVertexColor;

out vec3 vColor;

void main()
{
    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    vColor      = aVertexColor;
}



================================================
FILE: Assets/shaders/BatchRenderer2D/quad.frag
================================================
#version 300 es
/*****/
precision mediump float;

/**
* \file
* \author Rudy Castan
* \date 2025 Fall
* \par CS200 Computer Graphics I
* \copyright DigiPen Institute of Technology
*/

//every GPU have different amount limit of texture
//have to ask to OpenGL, in fragment shader, programically
#ifndef MAX_TEXTURE_SLOTS
#define MAX_TEXTURE_SLOTS 8// we will ask opengl programically
#endif

uniform sampler2D uTextures[MAX_TEXTURE_SLOTS];//'' : array size must be a constant integer expression

in vec2 vTexCoord;
flat in vec4 vTint;
flat in int vTextureIndex;
layout(location=0)out vec4 FragColor;

void main()
{
    // FragColor = texture(uTextures[vTextureIndex], vTexCoord) * vTint;
    //300es version need to use constexpr index so..
    vec4 tex_color;
    
    switch(vTextureIndex){
        case 0:tex_color=texture(uTextures[0],vTexCoord);break;
        
        case 1:tex_color=texture(uTextures[1],vTexCoord);break;
        
        #if MAX_TEXTURE_SLOTS>2
        case 2:tex_color=texture(uTextures[2],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>3
        case 3:tex_color=texture(uTextures[3],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>4
        case 4:tex_color=texture(uTextures[4],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>5
        case 5:tex_color=texture(uTextures[5],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>6
        case 6:tex_color=texture(uTextures[6],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>7
        case 7:tex_color=texture(uTextures[7],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>8
        case 8:tex_color=texture(uTextures[8],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>9
        case 9:tex_color=texture(uTextures[9],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>10
        case 10:tex_color=texture(uTextures[10],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>11
        case 11:tex_color=texture(uTextures[11],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>12
        case 12:tex_color=texture(uTextures[12],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>13
        case 13:tex_color=texture(uTextures[13],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>14
        case 14:tex_color=texture(uTextures[14],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>15
        case 15:tex_color=texture(uTextures[15],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>16
        case 16:tex_color=texture(uTextures[16],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>17
        case 17:tex_color=texture(uTextures[17],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>18
        case 18:tex_color=texture(uTextures[18],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>19
        case 19:tex_color=texture(uTextures[19],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>20
        case 20:tex_color=texture(uTextures[20],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>21
        case 21:tex_color=texture(uTextures[21],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>22
        case 22:tex_color=texture(uTextures[22],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>23
        case 23:tex_color=texture(uTextures[23],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>24
        case 24:tex_color=texture(uTextures[24],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>25
        case 25:tex_color=texture(uTextures[25],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>26
        case 26:tex_color=texture(uTextures[26],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>27
        case 27:tex_color=texture(uTextures[27],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>28
        case 28:tex_color=texture(uTextures[28],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>29
        case 29:tex_color=texture(uTextures[29],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>30
        case 30:tex_color=texture(uTextures[30],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>31
        case 31:tex_color=texture(uTextures[31],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>32
        case 32:tex_color=texture(uTextures[32],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>33
        case 33:tex_color=texture(uTextures[33],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>34
        case 34:tex_color=texture(uTextures[34],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>35
        case 35:tex_color=texture(uTextures[35],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>36
        case 36:tex_color=texture(uTextures[36],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>37
        case 37:tex_color=texture(uTextures[37],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>38
        case 38:tex_color=texture(uTextures[38],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>39
        case 39:tex_color=texture(uTextures[39],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>40
        case 40:tex_color=texture(uTextures[40],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>41
        case 41:tex_color=texture(uTextures[41],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>42
        case 42:tex_color=texture(uTextures[42],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>43
        case 43:tex_color=texture(uTextures[43],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>44
        case 44:tex_color=texture(uTextures[44],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>45
        case 45:tex_color=texture(uTextures[45],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>46
        case 46:tex_color=texture(uTextures[46],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>47
        case 47:tex_color=texture(uTextures[47],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>48
        case 48:tex_color=texture(uTextures[48],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>49
        case 49:tex_color=texture(uTextures[49],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>50
        case 50:tex_color=texture(uTextures[50],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>51
        case 51:tex_color=texture(uTextures[51],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>52
        case 52:tex_color=texture(uTextures[52],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>53
        case 53:tex_color=texture(uTextures[53],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>54
        case 54:tex_color=texture(uTextures[54],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>55
        case 55:tex_color=texture(uTextures[55],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>56
        case 56:tex_color=texture(uTextures[56],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>57
        case 57:tex_color=texture(uTextures[57],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>58
        case 58:tex_color=texture(uTextures[58],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>59
        case 59:tex_color=texture(uTextures[59],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>60
        case 60:tex_color=texture(uTextures[60],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>61
        case 61:tex_color=texture(uTextures[61],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>62
        case 62:tex_color=texture(uTextures[62],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>63
        case 63:tex_color=texture(uTextures[63],vTexCoord);break;
        #endif
    }
    tex_color*=vTint;
    
    FragColor=tex_color;
    
    if(FragColor.a==0.)
    discard;
}



================================================
FILE: Assets/shaders/BatchRenderer2D/quad.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aWorldPosition;
layout(location = 1) in vec2 aTexCoord;
layout(location = 2) in vec4 aTint;
layout(location = 3) in int aTextureIndex;
layout(location = 4) in float aDepth;

out vec2 vTexCoord;
//by default, any output variable interpolated
//but vTint has to be same across the triangle(for each pixels)
//so put flat
flat out vec4 vTint;
flat out int vTextureIndex;

// uniform mat3 uModel; //get rid of it so that cpu do this 
// uniform mat3 uToNDC; //instead using uniformblock
layout(std140) uniform NDC
{
    mat3 uToNDC;
};

// uniform mat3 uTexCoordTransform; //get rid of it so that cpu do this 

/**
why give model xform task to CPU?
we have lots of vertex(duplicated)
it is more 
*/

void main()
{
    vec3 ndc_point = uToNDC * /* uModel * */ vec3(aWorldPosition, 1.0); //we assume that vertex position is already in world space(we dont need model xformation)
    gl_Position = vec4(ndc_point.xy, aDepth, 1.0);
    vTexCoord = aTexCoord.st;//don't need texcoord xform anymore, just copy
    vTint = aTint;
    vTextureIndex = aTextureIndex;
}



================================================
FILE: Assets/shaders/BatchRenderer2D/sdf.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 * (Batch Renderer Version)
 */

// 1. Receive all uniforms as 'in' variables
in vec2 vTestPoint;
flat in vec4 vFillColor;
flat in vec4 vLineColor;
flat in vec2 vWorldSize;
flat in float vLineWidth;
flat in int vShape;

layout(location = 0) out vec4 FragColor;

// --- sdCircle, sdRectangle functions are identical to the original ---
float sdCircle( vec2 p, float r )
{
    return length(p) - r;
}

float sdRectangle( vec2 point, vec2 half_dim )
{
    vec2 d = abs(point)-half_dim;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// 2. Modify evalute_color function to use 'v' (in) variables instead of uniforms
vec4 evalute_color(float sdf)
{
    float fill_alpha = (sdf < 0.0) ? 1.0 : 0.0;
    // 'uLineWidth' -> 'vLineWidth'
    float outline_alpha = (abs(sdf) < vLineWidth * 0.5) ? 1.0 : 0.0; 

    // 'uFillColor' -> 'vFillColor'
    vec4 fill_color = vec4(vFillColor.rgb, fill_alpha * vFillColor.a);
    // 'uLineColor' -> 'vLineColor'
    vec4 line_color = vec4(vLineColor.rgb, outline_alpha * vLineColor.a);

    return mix(fill_color,line_color,line_color.a);
}

void main()
{
    float sdf = 0.0;
    
    // 3. Check 'vShape' (from vertex) instead of 'uShape' (uniform)
    if(vShape == 0){ // This pixel belongs to a Circle
        // 'uWorldSize' -> 'vWorldSize'
        float radius = min(vWorldSize.x ,vWorldSize.y) * 0.5; 
        sdf = sdCircle(vTestPoint, radius);
    }
    else if(vShape == 1){ // This pixel belongs to a Rectangle
        // 'uWorldSize' -> 'vWorldSize'
        sdf = sdRectangle(vTestPoint, 0.5 * vWorldSize); 
    }
    
    vec4 color = evalute_color(sdf);
    if(color.a <= 0.0 )
        discard;
    FragColor = color;
}


================================================
FILE: Assets/shaders/BatchRenderer2D/sdf.vert
================================================
#version 300 es

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 * (Batch Renderer Version)
 */

// 1. Receive all per-object data as attributes
layout(location = 0) in vec2 aWorldPosition;  // World coordinates calculated on the CPU
layout(location = 1) in vec2 aTestPoint;      // vTestPoint calculated on the CPU
layout(location = 2) in vec4 aFillColor;
layout(location = 3) in vec4 aLineColor;
layout(location = 4) in vec2 aWorldSize;
layout(location = 5) in float aLineWidth;
layout(location = 6) in int aShape;
layout(location = 7) in float aDepth;

// 2. Common UBO (Camera)
layout(std140) uniform NDC
{
    mat3 uToNDC;
};

// 3. Variables to pass to the Fragment Shader
out vec2 vTestPoint;
flat out vec4 vFillColor;
flat out vec4 vLineColor;
flat out vec2 vWorldSize;
flat out float vLineWidth;
flat out int vShape;

void main()
{
    // 4. Use the pre-calculated aWorldPosition, same as the Batch Texture Shader
    vec3 ndc_point = uToNDC * vec3(aWorldPosition, 1.0); 
    gl_Position = vec4(ndc_point.xy, aDepth, 1.0);

    // 5. Pass all attributes directly to the Fragment Shader
    vTestPoint = aTestPoint;
    vFillColor = aFillColor;
    vLineColor = aLineColor;
    vWorldSize = aWorldSize;
    vLineWidth = aLineWidth;
    vShape = aShape;
}


================================================
FILE: Assets/shaders/DemoBufferTypes/background.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

in vec3 vColor;

layout(location = 0) out vec4 FragColor;

void main()
{
    FragColor = vec4(vColor, 1.0);
}



================================================
FILE: Assets/shaders/DemoBufferTypes/background.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec3 aVertexColor;

out vec3 vColor;

layout(std140) uniform NDC
{
    mat3 uToNDC;
};

void main()
{
    gl_Position = vec4((uToNDC * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vColor      = aVertexColor;
}



================================================
FILE: Assets/shaders/DemoBufferTypes/villager.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

in vec3 vColor;

layout(location = 0) out vec4 FragColor;

void main()
{
    FragColor = vec4(vColor, 1.0);
}



================================================
FILE: Assets/shaders/DemoBufferTypes/villager.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec3 aVertexColor;

layout(std140) uniform NDC
{
    mat3 uToNDC;
};

uniform mat3 uModel;

out vec3 vColor;

void main()
{
    vec3 ndc_point = uToNDC * uModel * vec3(aVertexPosition, 1.0);
    gl_Position    = vec4(ndc_point.xy, 0.0, 1.0);
    vColor         = aVertexColor;
}



================================================
FILE: Assets/shaders/DemoTexturing/combine.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

in vec3 vColor;
in vec2 vTextureCoordinates;

layout(location = 0) out vec4 fFragClr;

uniform sampler2D uTex2d;
uniform float     uModulateColor;
uniform float     uProcTex;
uniform float     uTileSize;
uniform float     uUseImage;
uniform bool      uUseTextureAlpha;

const vec4 cyan = vec4(1.0, 0.0, 1.0, 1.0);
const vec4 teal = vec4(0.0, 0.68, 0.94, 1.0);

void main()
{
    vec4 interpolated_color = mix(vec4(1.0), vec4(vColor, 1.0), uModulateColor);
    vec4 procedural_color   = mix(vec4(1.0), (0.0 == mod(floor(gl_FragCoord.x / uTileSize) + floor(gl_FragCoord.y / uTileSize), 2.0)) ? cyan : teal, uProcTex);
    vec4 texture_color      = mix(vec4(1.0), texture(uTex2d, vTextureCoordinates), uUseImage);
    if (!uUseTextureAlpha)
    {
        texture_color.a = 1.0;
    }

    fFragClr = interpolated_color * procedural_color * texture_color;
}



================================================
FILE: Assets/shaders/DemoTexturing/combine.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec3 aVertexColor;
layout(location = 2) in vec2 aVertexTextureCoordinates;

out vec3 vColor;
out vec2 vTextureCoordinates;

uniform float uTexCoordScale;

uniform mat3 uToNDC;
uniform mat3 uModel;

void main()
{
    vec3 ndc_position   = uToNDC * uModel * vec3(aVertexPosition, 1.0);
    gl_Position         = vec4(ndc_position.xy, 0.0, 1.0);
    vColor              = aVertexColor;
    vTextureCoordinates = aVertexTextureCoordinates * uTexCoordScale;
}



================================================
FILE: Assets/shaders/ImmediateRenderer2D/quad.frag
================================================
#version 300 es
precision         mediump float;

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

uniform sampler2D uTex2d;

in vec2 vTexCoord;

layout(location = 0) out vec4 fFragClr;

uniform vec4 uTint; //  cover with new color

//use all variable!!!!!!!!!!!!!!
void main()
{
    fFragClr = texture(uTex2d, vTexCoord) * uTint;

    if(fFragClr.a == 0.0)
    discard;
}




================================================
FILE: Assets/shaders/ImmediateRenderer2D/quad.vert
================================================
#version 300 es

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec2 aTexCoord;


out vec2 vTexCoord;

layout(std140) uniform NDC
{
    mat3 uToNDC;
};

uniform mat3 uModel;
uniform mat3 uTexCoordTransform; //for drawing just part of image
uniform float uDepth;

void main()
{
    vec3 ndc_position   = uToNDC * uModel * vec3(aVertexPosition, 1.0);
    gl_Position         = vec4(ndc_position.xy, uDepth, 1.0);
    vec3 tex_coords = uTexCoordTransform * vec3(aTexCoord,1.0);
    vTexCoord = tex_coords.st ;
}



================================================
FILE: Assets/shaders/ImmediateRenderer2D/sdf.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

in vec2 vTestPoint;

layout(location = 0) out vec4 FragColor;

uniform vec4 uFillColor;
uniform vec4 uLineColor;
uniform vec2 uWorldSize;
uniform float uLineWidth;
uniform int uShape;

float sdCircle( vec2 p, float r )
{
    return length(p) - r;
}

float sdRectangle( vec2 point, vec2 half_dim )
{
    vec2 d = abs(point)-half_dim;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

//evalute the color based off sdf
vec4 evalute_color(float sdf)
{
    float fill_alpha = (sdf < 0.0) ? 1.0 : 0.0;
    float outline_alpha = (abs(sdf) < uLineWidth * 0.5) ? 1.0 : 0.0;

    vec4 fill_color = vec4(uFillColor.rgb, fill_alpha * uFillColor.a);//modulate,mix
    vec4 line_color = vec4(uLineColor.rgb, outline_alpha * uLineColor.a);//modulate,mix

    return mix(fill_color,line_color,line_color.a);
}

void main()
{
    //based off shape evaluate the sdf
    float sdf = 0.0;
    if(uShape == 0){
        float radius = min(uWorldSize.x ,uWorldSize.y) * 0.5;
        sdf = sdCircle(vTestPoint, radius);
    }
    else if(uShape == 1){
        sdf = sdRectangle(vTestPoint, 0.5 * uWorldSize);
    }
    
    //get the color
    vec4 color = evalute_color(sdf);
    if(color.a <= 0.0 )
        discard;
    //set color, discard empty space
    FragColor = color;
}



================================================
FILE: Assets/shaders/ImmediateRenderer2D/sdf.vert
================================================
#version 300 es
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;

uniform mat3 uModel;
layout(std140) uniform NDC
{
    mat3 uToNDC;
};
uniform vec2 uSDFScale;

out vec2 vTestPoint;

uniform float uDepth;
void main()
{
    vec3 ndc_point = uToNDC * uModel * vec3(aVertexPosition,1.0);
    gl_Position = vec4(ndc_point.xy, uDepth, 1.0);
    vTestPoint = aVertexPosition * uSDFScale; //scale
}



================================================
FILE: Assets/shaders/InstancedRenderer2D/quad.frag
================================================
#version 300 es
/*****/
precision mediump float;

/**
* \file
* \author Rudy Castan
* \date 2025 Fall
* \par CS200 Computer Graphics I
* \copyright DigiPen Institute of Technology
*/

//every GPU have different amount limit of texture
//have to ask to OpenGL, in fragment shader, programically
#ifndef MAX_TEXTURE_SLOTS
#define MAX_TEXTURE_SLOTS 8// we will ask opengl programically
#endif

uniform sampler2D uTextures[MAX_TEXTURE_SLOTS];//'' : array size must be a constant integer expression
// we have to treat this uTextures as MAX_TEXTURE_SLOTS uniform variables
//have to set their binding index

in vec2 vTexCoord;
flat in vec4 vTint;
flat in int vTextureIndex;
layout(location=0)out vec4 FragColor;

void main()
{
    // FragColor = texture(uTextures[vTextureIndex], vTexCoord) * vTint;
    //300es version need to use constexpr index so..
    vec4 tex_color;
    
    switch(vTextureIndex){
        case 0:tex_color=texture(uTextures[0],vTexCoord);break;
        
        case 1:tex_color=texture(uTextures[1],vTexCoord);break;
        
        #if MAX_TEXTURE_SLOTS>2
        case 2:tex_color=texture(uTextures[2],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>3
        case 3:tex_color=texture(uTextures[3],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>4
        case 4:tex_color=texture(uTextures[4],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>5
        case 5:tex_color=texture(uTextures[5],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>6
        case 6:tex_color=texture(uTextures[6],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>7
        case 7:tex_color=texture(uTextures[7],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>8
        case 8:tex_color=texture(uTextures[8],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>9
        case 9:tex_color=texture(uTextures[9],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>10
        case 10:tex_color=texture(uTextures[10],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>11
        case 11:tex_color=texture(uTextures[11],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>12
        case 12:tex_color=texture(uTextures[12],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>13
        case 13:tex_color=texture(uTextures[13],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>14
        case 14:tex_color=texture(uTextures[14],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>15
        case 15:tex_color=texture(uTextures[15],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>16
        case 16:tex_color=texture(uTextures[16],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>17
        case 17:tex_color=texture(uTextures[17],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>18
        case 18:tex_color=texture(uTextures[18],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>19
        case 19:tex_color=texture(uTextures[19],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>20
        case 20:tex_color=texture(uTextures[20],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>21
        case 21:tex_color=texture(uTextures[21],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>22
        case 22:tex_color=texture(uTextures[22],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>23
        case 23:tex_color=texture(uTextures[23],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>24
        case 24:tex_color=texture(uTextures[24],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>25
        case 25:tex_color=texture(uTextures[25],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>26
        case 26:tex_color=texture(uTextures[26],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>27
        case 27:tex_color=texture(uTextures[27],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>28
        case 28:tex_color=texture(uTextures[28],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>29
        case 29:tex_color=texture(uTextures[29],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>30
        case 30:tex_color=texture(uTextures[30],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>31
        case 31:tex_color=texture(uTextures[31],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>32
        case 32:tex_color=texture(uTextures[32],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>33
        case 33:tex_color=texture(uTextures[33],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>34
        case 34:tex_color=texture(uTextures[34],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>35
        case 35:tex_color=texture(uTextures[35],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>36
        case 36:tex_color=texture(uTextures[36],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>37
        case 37:tex_color=texture(uTextures[37],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>38
        case 38:tex_color=texture(uTextures[38],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>39
        case 39:tex_color=texture(uTextures[39],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>40
        case 40:tex_color=texture(uTextures[40],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>41
        case 41:tex_color=texture(uTextures[41],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>42
        case 42:tex_color=texture(uTextures[42],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>43
        case 43:tex_color=texture(uTextures[43],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>44
        case 44:tex_color=texture(uTextures[44],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>45
        case 45:tex_color=texture(uTextures[45],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>46
        case 46:tex_color=texture(uTextures[46],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>47
        case 47:tex_color=texture(uTextures[47],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>48
        case 48:tex_color=texture(uTextures[48],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>49
        case 49:tex_color=texture(uTextures[49],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>50
        case 50:tex_color=texture(uTextures[50],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>51
        case 51:tex_color=texture(uTextures[51],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>52
        case 52:tex_color=texture(uTextures[52],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>53
        case 53:tex_color=texture(uTextures[53],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>54
        case 54:tex_color=texture(uTextures[54],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>55
        case 55:tex_color=texture(uTextures[55],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>56
        case 56:tex_color=texture(uTextures[56],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>57
        case 57:tex_color=texture(uTextures[57],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>58
        case 58:tex_color=texture(uTextures[58],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>59
        case 59:tex_color=texture(uTextures[59],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>60
        case 60:tex_color=texture(uTextures[60],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>61
        case 61:tex_color=texture(uTextures[61],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>62
        case 62:tex_color=texture(uTextures[62],vTexCoord);break;
        #endif
        #if MAX_TEXTURE_SLOTS>63
        case 63:tex_color=texture(uTextures[63],vTexCoord);break;
        #endif
    }
    tex_color*=vTint;
    
    FragColor=tex_color;
    
    if(FragColor.a==0.)
    discard;
}



================================================
FILE: Assets/shaders/InstancedRenderer2D/quad.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

//per vertex
layout(location = 0) in vec2 aModelPosition;
layout(location = 1) in vec2 aTexCoord;

//per instance
layout(location = 2) in vec3 aModelRow0;
layout(location = 3) in vec3 aModelRow1;
layout(location = 4) in vec4 aTint;
layout(location = 5) in vec2 aTexCoordScale;
layout(location = 6) in vec2 aTexCoordOffset;
layout(location = 7) in int  aTextureIndex;
layout(location = 8) in float aDepth;

out vec2 vTexCoord;
//by default, any output variable interpolated
//but vTint has to be same across the triangle(for each pixels)
//so put flat
flat out vec4 vTint;
flat out int vTextureIndex;

// uniform mat3 uModel; //get rid of it so that cpu do this 
layout(std140) uniform NDC
{
    mat3 uToNDC;
};
// uniform mat3 uTexCoordTransform; //get rid of it so that cpu do this 

/**
why give model xform task to CPU?
we have lots of vertex(duplicated)
it is more 
*/

void main()
{
    vec2 world_position;
    world_position.x = aModelPosition.x * aModelRow0[0] + aModelPosition.y * aModelRow0[1] + aModelRow0[2];
    world_position.y = aModelPosition.x * aModelRow1[0] + aModelPosition.y * aModelRow1[1] + aModelRow1[2];
    vec3 ndc_point = uToNDC * /* uModel * */ vec3(world_position, 1.0); //we assume that vertex position is already in world space(we dont need model xformation)
    gl_Position = vec4(ndc_point.xy, aDepth, 1.0);
    vTexCoord = aTexCoord * aTexCoordScale + aTexCoordOffset; //get atlas of texture if need
    vTint = aTint;
    vTextureIndex = aTextureIndex;
}



================================================
FILE: Assets/shaders/InstancedRenderer2D/sdf.frag
================================================
#version 300 es
precision mediump float;

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 * (Batch Renderer Version)
 */

// 1. Receive all uniforms as 'in' variables
in vec2 vTestPoint;
flat in vec4 vFillColor;
flat in vec4 vLineColor;
flat in vec2 vWorldSize;
flat in float vLineWidth;
flat in int vShape;

layout(location = 0) out vec4 FragColor;

// --- sdCircle, sdRectangle functions are identical to the original ---
float sdCircle( vec2 p, float r )
{
    return length(p) - r;
}

float sdRectangle( vec2 point, vec2 half_dim )
{
    vec2 d = abs(point)-half_dim;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// 2. Modify evalute_color function to use 'v' (in) variables instead of uniforms
vec4 evalute_color(float sdf)
{
    float fill_alpha = (sdf < 0.0) ? 1.0 : 0.0;
    // 'uLineWidth' -> 'vLineWidth'
    float outline_alpha = (abs(sdf) < vLineWidth * 0.5) ? 1.0 : 0.0; 

    // 'uFillColor' -> 'vFillColor'
    vec4 fill_color = vec4(vFillColor.rgb, fill_alpha * vFillColor.a);
    // 'uLineColor' -> 'vLineColor'
    vec4 line_color = vec4(vLineColor.rgb, outline_alpha * vLineColor.a);

    return mix(fill_color,line_color,line_color.a);
}

void main()
{
    float sdf = 0.0;
    
    // 3. Check 'vShape' (from vertex) instead of 'uShape' (uniform)
    if(vShape == 0){ // This pixel belongs to a Circle
        // 'uWorldSize' -> 'vWorldSize'
        float radius = min(vWorldSize.x ,vWorldSize.y) * 0.5; 
        sdf = sdCircle(vTestPoint, radius);
    }
    else if(vShape == 1){ // This pixel belongs to a Rectangle
        // 'uWorldSize' -> 'vWorldSize'
        sdf = sdRectangle(vTestPoint, 0.5 * vWorldSize); 
    }
    
    vec4 color = evalute_color(sdf);
    if(color.a <= 0.0 )
        discard;
    FragColor = color;
}


================================================
FILE: Assets/shaders/InstancedRenderer2D/sdf.vert
================================================
#version 300 es

/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 * (Batch Renderer Version)
 */


layout(location = 0) in vec2 aModelPosition;

layout(location = 1) in vec3 aModelRow0;
layout(location = 2) in vec3 aModelRow1;
// layout(location = 3) in vec2 aTestPoint;      // vTestPoint doesn't calculated in CPU anymore, but instead in here!!
layout(location = 3) in vec4 aFillColor;
layout(location = 4) in vec4 aLineColor;
layout(location = 5) in vec2 aWorldSize;
layout(location = 6) in float aLineWidth;
layout(location = 7) in int aShape;
layout(location = 8) in float aDepth;


layout(std140) uniform NDC
{
    mat3 uToNDC;
};


out vec2 vTestPoint;
flat out vec4 vFillColor;
flat out vec4 vLineColor;
flat out vec2 vWorldSize;
flat out float vLineWidth;
flat out int vShape;

void main()
{
    vec2 world_position;
    world_position.x = aModelPosition.x * aModelRow0[0] + aModelPosition.y * aModelRow0[1] + aModelRow0[2];
    world_position.y = aModelPosition.x * aModelRow1[0] + aModelPosition.y * aModelRow1[1] + aModelRow1[2];
    vec3 ndc_point = uToNDC * vec3(world_position, 1.0); 
    gl_Position = vec4(ndc_point.xy, aDepth, 1.0); // Use 1 depth for SDF


    // vTestPoint = aTestPoint;
    // vTestPoint = aModelPosition * aWorldSize;
    vec2 quadSize = aWorldSize + vec2(aLineWidth);
    vTestPoint = aModelPosition * quadSize;
    vFillColor = aFillColor;
    vLineColor = aLineColor;
    vWorldSize = aWorldSize;
    vLineWidth = aLineWidth;
    vShape = aShape;
}


================================================
FILE: Assets/shaders/PostProcess/box-blur.frag
================================================
#version 300 es
precision mediump float;
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
uniform sampler2D uColorTexture;
in vec2 vTexCoord;
layout(location = 0) out vec4 FragColor;

uniform int uBlurSize;
uniform float uSeparation;

void main()
{
    FragColor = texture(uColorTexture, vTexCoord);
    if(uBlurSize <= 0){
        return;
    }
    vec2 tex_size = vec2(textureSize(uColorTexture, 0));
    FragColor = vec4(vec3(0.0), FragColor.a);
    // -size to +size, (2*size+1) * (2*size+1)
    for(int i = -uBlurSize; i <= uBlurSize; ++i)
    {
        for(int j = -uBlurSize; j < uBlurSize; ++j)
        {
            vec2 offset = vec2(i,j) * uSeparation / tex_size;
            FragColor.rgb += texture(uColorTexture, vTexCoord+offset).rgb;
        }
    }
    float count = (2.0*float(uBlurSize)+1.0);
    count *= count;
    FragColor.rgb /= count;
}


================================================
FILE: Assets/shaders/PostProcess/chromatic-aberration.frag
================================================
#version 300 es
precision mediump float;
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
uniform sampler2D uColorTexture;
in vec2 vTexCoord;
layout(location = 0) out vec4 FragColor;

uniform vec2 uMouseFocusPoint; // measure in texture coords 0-1

void main()
{
    float red_offset = 0.009;
    float green_offset = 0.006;
    float blue_offset = -0.006;
    vec2 direction = vTexCoord - uMouseFocusPoint;
    FragColor.r = texture(uColorTexture, vTexCoord + (direction*vec2(red_offset))).r;
    FragColor.g = texture(uColorTexture, vTexCoord + (direction*vec2(green_offset))).g;
    FragColor.b = texture(uColorTexture, vTexCoord + (direction*vec2(blue_offset))).b;
    FragColor.a = texture(uColorTexture, vTexCoord).a;

}


================================================
FILE: Assets/shaders/PostProcess/gamma-correct.frag
================================================
#version 300 es
precision mediump float;
/**
 * \file
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
uniform sampler2D uColorTexture;
in vec2 vTexCoord;
layout(location = 0) out vec4 FragColor;

uniform float uGamma;

void main()
{
    FragColor = texture(uColorTexture, vTexCoord);
    FragColor.rgb = pow(FragColor.rgb, vec3(uGamma));
}



================================================
FILE: Assets/shaders/PostProcess/pixelize.frag
================================================
#version 300 es
precision mediump float;
/**
 * \file
 * \author Taekyung HoeWhore
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
uniform sampler2D uColorTexture;
in vec2 vTexCoord;
layout(location = 0) out vec4 FragColor;

uniform int pixelSize;

void main() {
    FragColor = texture(uColorTexture, vTexCoord);

  // Must be odd.
  if(pixelSize % 2 == 0 || pixelSize <= 1) 
    return;

  vec2 tex_size = vec2(textureSize(uColorTexture, 0));
  vec2 texCoord = gl_FragCoord.xy / tex_size;


  float x = float(int(gl_FragCoord.x) % pixelSize);
  float y = float(int(gl_FragCoord.y) % pixelSize);

        x = floor(float(pixelSize) / 2.0) - x;
        y = floor(float(pixelSize) / 2.0) - y;

        x = gl_FragCoord.x + x;
        y = gl_FragCoord.y + y;

  vec2 uv = vec2(x, y) / tex_size;

  FragColor = texture(uColorTexture, uv);
}


================================================
FILE: Assets/shaders/PostProcess/simple-texture.frag
================================================
#version 300 es

precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

uniform sampler2D uColorTexture;

in vec2 vTexCoord;

layout(location = 0) out vec4 FragColor;

void main()
{
    FragColor = texture(uColorTexture, vTexCoord);
}



================================================
FILE: Assets/shaders/PostProcess/simple.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aVertexPosition;
layout(location = 1) in vec2 aTexCoord;

out vec2 vTexCoord;

void main()
{
    // Vertices are already in NDC space, just pass through
    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    vTexCoord   = aTexCoord;
}



================================================
FILE: Assets/shaders/shape/shape.frag
================================================
#version 300 es

precision mediump float;

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

uniform sampler2D uTexture;
uniform vec4 uTint;

in vec2 vTexCoord;


layout(location = 0) out vec4 FragColor;

void main()
{
    vec4 tex_color = texture(uTexture, vTexCoord);
    FragColor = tex_color * uTint;
}



================================================
FILE: Assets/shaders/shape/shape.vert
================================================
#version 300 es

/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

layout(location = 0) in vec2 aPosition;
layout(location = 1) in vec2 aTexCoord;
// layout(location = 2) in vec4 aTint;

out vec2 vTexCoord;
// out vec4 vTint;

layout(std140) uniform NDC
{
    mat3 uToNDC;
};
uniform mat3 uTransform;
uniform float uDepth;

void main()
{
    // Apply transform matrix to position
    vec3 transformed_pos = uTransform * vec3(aPosition, 1.0);
    
    // Apply NDC matrix
    vec3 ndc_point = uToNDC * transformed_pos;
    
    gl_Position = vec4(ndc_point.xy, uDepth, 1.0);
    vTexCoord = aTexCoord;
    // vTint = aTint;
}



================================================
FILE: cmake/CompilerWarnings.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

# from here:
#
# https://github.com/lefticus/cppbestpractices/blob/master/02-Use_the_Tools_Available.md

function(set_project_warnings project_name)
  option(WARNINGS_AS_ERRORS "Treat compiler warnings as errors" TRUE)

  set(MSVC_WARNINGS
      /W4 # Baseline reasonable warnings
      /w14242 # 'identifier': conversion from 'type1' to 'type1', possible loss
              # of data
      /w14254 # 'operator': conversion from 'type1:field_bits' to
              # 'type2:field_bits', possible loss of data
      /w14263 # 'function': member function does not override any base class
              # virtual member function
      /w14265 # 'classname': class has virtual functions, but destructor is not
              # virtual instances of this class may not be destructed correctly
      /w14287 # 'operator': unsigned/negative constant mismatch
      /we4289 # nonstandard extension used: 'variable': loop control variable
              # declared in the for-loop is used outside the for-loop scope
      /w14296 # 'operator': expression is always 'boolean_value'
      /w14311 # 'variable': pointer truncation from 'type1' to 'type2'
      /w14545 # expression before comma evaluates to a function which is missing
              # an argument list
      /w14546 # function call before comma missing argument list
      /w14547 # 'operator': operator before comma has no effect; expected
              # operator with side-effect
      /w14549 # 'operator': operator before comma has no effect; did you intend
              # 'operator'?
      /w14555 # expression has no effect; expected expression with side- effect
      /w14619 # pragma warning: there is no warning number 'number'
      /w14640 # Enable warning on thread un-safe static member initialization
      /w14826 # Conversion from 'type1' to 'type_2' is sign-extended. This may
              # cause unexpected runtime behavior.
      /w14905 # wide string literal cast to 'LPSTR'
      /w14906 # string literal cast to 'LPWSTR'
      /w14928 # illegal copy-initialization; more than one user-defined
              # conversion has been implicitly applied
      /permissive- # standards conformance mode for MSVC compiler.
      /wd4201 # warning C4201 : nonstandard extension used : nameless struct / union
  )

  set(CLANG_WARNINGS
      -Wall
      -Wextra # reasonable and standard
      -Wshadow # warn the user if a variable declaration shadows one from a
               # parent context
      $<$<COMPILE_LANGUAGE:CXX>:-Wnon-virtual-dtor> # warn the user if a class with virtual functions has a
                         # non-virtual destructor. This helps catch hard to
                         # track down memory errors
      $<$<COMPILE_LANGUAGE:CXX>:-Wold-style-cast> # warn for c-style casts
      -Wcast-align # warn for potential performance problem casts
      -Wunused # warn on anything being unused
      $<$<COMPILE_LANGUAGE:CXX>:-Woverloaded-virtual> # warn if you overload (not override) a virtual
                           # function
      -Wpedantic # warn if non-standard C++ is used
      -Wconversion # warn on type conversions that may lose data
      -Wsign-conversion # warn on sign conversions
      -Wnull-dereference # warn if a null dereference is detected
      -Wdouble-promotion # warn if float is implicit promoted to double
      -Wformat=2 # warn on security issues around functions that format output
                 # (ie printf)
    #   -Wno-gnu-anonymous-struct # allow anonymous-struct
    #   -Wno-nested-anon-types
  )

  if (WARNINGS_AS_ERRORS)
    set(CLANG_WARNINGS ${CLANG_WARNINGS} -Werror)
    set(MSVC_WARNINGS ${MSVC_WARNINGS} /WX)
  endif()

  set(GCC_WARNINGS
      ${CLANG_WARNINGS}
      -Wmisleading-indentation # warn if indentation implies blocks where blocks
                               # do not exist
      -Wduplicated-cond # warn if if / else chain has duplicated conditions
      -Wduplicated-branches # warn if if / else branches have duplicated code
      -Wlogical-op # warn about logical operations being used where bitwise were
                   # probably wanted
      $<$<COMPILE_LANGUAGE:CXX>:-Wuseless-cast> # warn if you perform a cast to the same type
  )

  if(MSVC)
    set(PROJECT_WARNINGS ${MSVC_WARNINGS})
  elseif(CMAKE_CXX_COMPILER_ID MATCHES ".*Clang")
    set(PROJECT_WARNINGS ${CLANG_WARNINGS})
  elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(PROJECT_WARNINGS ${GCC_WARNINGS})
  else()
    message(AUTHOR_WARNING "No compiler warnings set for '${CMAKE_CXX_COMPILER_ID}' compiler.")
  endif()

  target_compile_options(${project_name} INTERFACE ${PROJECT_WARNINGS})

endfunction()



================================================
FILE: cmake/Dependencies.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

include(FetchContent)

include(cmake/dependencies/OpenGL.cmake)    #defines target the_opengl
include(cmake/dependencies/GLEW.cmake)      # defines target the_glew
include(cmake/dependencies/SDL2.cmake)      # defines target the_sdl2
include(cmake/dependencies/DearImGUI.cmake) # defines target the_imgui   ;  note DearImGUI.cmake depends on SDL2.cmake
include(cmake/dependencies/GSL.cmake)       # defines target the_gsl
include(cmake/dependencies/STB.cmake)       # defines target the_stb

add_library(dependencies INTERFACE)

target_link_libraries(dependencies INTERFACE 
    the_opengl
    the_glew
    the_sdl2
    the_imgui
    the_gsl
    the_stb
)



================================================
FILE: cmake/StandardProjectSettings.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

include(FetchContent)
set(FETCHCONTENT_QUIET TRUE)
set(CMAKE_VERBOSE_MAKEFILE OFF)

# https://cmake.org/cmake/help/latest/policy/CMP0135.html
if(POLICY CMP0135)
  cmake_policy(SET CMP0135 NEW)
endif()

# Set a default build type if none was specified
if(NOT CMAKE_BUILD_TYPE)
  message(STATUS "Setting build type to 'Release' as none was specified.")
  set(CMAKE_BUILD_TYPE
      Release
      CACHE STRING "Choose the type of build." FORCE)
  
endif()

if(NOT CMAKE_CONFIGURATION_TYPES)
# Set the possible values of build type for cmake-gui, ccmake
  set_property(
    CACHE CMAKE_BUILD_TYPE
    PROPERTY STRINGS
             "Debug"
             "Release"
             "MinSizeRel"
             "RelWithDebInfo")
endif()

# Generate compile_commands.json to make it easier to work with clang based tools
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Put exe targets into the root of the build folder
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
foreach(config ${CMAKE_CONFIGURATION_TYPES})
    string(TOUPPER ${config} config_upper)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${config_upper} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
endforeach()



================================================
FILE: cmake/dependencies/DearImGUI.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

# Depends on SDL2 and OpenGL

FetchContent_Declare(
    dearimgui
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    GIT_TAG a28cb615ff2c2ed8901397b00762d557cae24760 # latest from docking branch as of 8/22/2025
)
FetchContent_MakeAvailable(dearimgui)

add_library(the_imgui STATIC
    ${dearimgui_SOURCE_DIR}/imgui.cpp ${dearimgui_SOURCE_DIR}/imgui.h
    ${dearimgui_SOURCE_DIR}/imconfig.h ${dearimgui_SOURCE_DIR}/imgui_internal.h
    ${dearimgui_SOURCE_DIR}/imgui_draw.cpp
    ${dearimgui_SOURCE_DIR}/imgui_tables.cpp
    ${dearimgui_SOURCE_DIR}/imgui_widgets.cpp
    ${dearimgui_SOURCE_DIR}/backends/imgui_impl_opengl3.cpp ${dearimgui_SOURCE_DIR}/backends/imgui_impl_opengl3.h
    ${dearimgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp
    ${dearimgui_SOURCE_DIR}/backends/imgui_impl_sdl2.h
)

target_include_directories(the_imgui SYSTEM PUBLIC ${dearimgui_SOURCE_DIR} ${dearimgui_SOURCE_DIR}/backends)
target_link_libraries(the_imgui PRIVATE the_sdl2)



================================================
FILE: cmake/dependencies/GLEW.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

# We will use GLEW for OpenGL bindings
# Linux platforms have a very easy way to install these depenencies and expose them to compilers so,
#   we will use the builtin find_package
# Emscripten has their own port of GLEW builtin. We don't even need to specify any flags.
#   Windows does not have a simple way to get it, so we download official windows binaries and link against those


add_library(the_glew INTERFACE)

if(NOT WIN32 AND NOT EMSCRIPTEN)
    # on    Mac : brew install glew
    # on Ubuntu : apt install libglew-dev
    set(GLEW_STATIC_LIBS TRUE)
    find_package(GLEW REQUIRED)
    target_link_libraries(the_glew INTERFACE ${GLEW_STATIC_LIBRARIES} $<$<PLATFORM_ID:Linux>:GL>)
    target_include_directories(the_glew SYSTEM INTERFACE ${GLEW_INCLUDE_DIRS})
elseif(WIN32)
    # download binaries for GLEW for windows x64
    FetchContent_Declare(
        glew
        DOWNLOAD_EXTRACT_TIMESTAMP TRUE
        URL "https://github.com/nigels-com/glew/releases/download/glew-2.2.0/glew-2.2.0-win32.zip"
    )
    FetchContent_MakeAvailable(glew)

    target_link_directories(the_glew INTERFACE ${glew_SOURCE_DIR}/lib/Release/x64)
    target_link_libraries(the_glew INTERFACE glew32s) # note that is the name of the glew32s.lib file we need to link in
    target_include_directories(the_glew SYSTEM INTERFACE ${glew_SOURCE_DIR}/include)
    target_compile_definitions(the_glew INTERFACE GLEW_STATIC)
endif()



================================================
FILE: cmake/dependencies/GSL.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

FetchContent_Declare(
    gsl
    DOWNLOAD_EXTRACT_TIMESTAMP TRUE
    URL https://github.com/microsoft/GSL/archive/refs/tags/v4.2.0.tar.gz
    URL_HASH MD5=5f3d2f7ef9c6351503c0c8f1f9390144
)
FetchContent_MakeAvailable(gsl)

add_library(the_gsl INTERFACE)
target_include_directories(the_gsl SYSTEM INTERFACE ${gsl_SOURCE_DIR}/include)



================================================
FILE: cmake/dependencies/OpenGL.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

# most platforms should have OpenGL already available
# debian linux : libgl1-mesa-dev (not that installing GLEW installs this as a dependency)
find_package(OpenGL REQUIRED)

add_library(the_opengl INTERFACE)
target_link_libraries(the_opengl INTERFACE ${OPENGL_LIBRARIES})

if(EMSCRIPTEN)
    # We want WebGL 2
    # WebGL 2 is almost the same as OpenGL ES 3 which is almost the same as OpenGL 3.3
    # MIN_WEBGL_VERSION=2           - Specifies the lowest WebGL version to target. Pass MIN_WEBGL_VERSION=2 to drop support for WebGL 1.0
    # MAX_WEBGL_VERSION=2           - Specifies the highest WebGL version to target. Pass -sMAX_WEBGL_VERSION=2 to enable targeting WebGL 2.
    # https://emscripten.org/docs/porting/multimedia_and_graphics/OpenGL-support.html
    
    target_link_options(the_opengl INTERFACE -sMIN_WEBGL_VERSION=2 -sMAX_WEBGL_VERSION=2)
    target_compile_definitions(the_opengl INTERFACE IS_WEBGL2)

endif()




================================================
FILE: cmake/dependencies/SDL2.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

# We will be using SDL2 for windowing & gl context creation
# Linux platforms have a very easy way to install these depenencies and expose them to compilers so,
#   we will use the builtin find_package
# Emscripten has their own port of SDL2 builtin. We can just #include, define --use-port=sdl2, and start using it.
#   Windows does not have a simple way to get it, so we download official windows binaries and link against those

add_library(the_sdl2 INTERFACE)

if(WIN32)
    # download binaries for SDL2 for windows x64
    FetchContent_Declare(
        sdl2
        DOWNLOAD_EXTRACT_TIMESTAMP TRUE
        URL https://github.com/libsdl-org/SDL/releases/download/release-2.32.8/SDL2-devel-2.32.8-VC.zip
        URL_HASH MD5=13172db35a91f3baac59e47187a2ebbb
    )
    FetchContent_MakeAvailable(sdl2)

    target_include_directories(the_sdl2 SYSTEM INTERFACE ${sdl2_SOURCE_DIR}/include)

    target_link_directories(the_sdl2 INTERFACE ${sdl2_SOURCE_DIR}/lib/x64)
    target_link_libraries(the_sdl2 INTERFACE SDL2)
    target_compile_definitions(the_sdl2 INTERFACE SDL_MAIN_HANDLED)

    # Define a custom target to copy SDL2.dll to the build directory
    set(TEMP_EXE_FOLDER $<IF:$<BOOL:${CMAKE_RUNTIME_OUTPUT_DIRECTORY}>,${CMAKE_RUNTIME_OUTPUT_DIRECTORY},${CMAKE_BINARY_DIR}>)
    add_custom_target(copy_sdl2_dll
    COMMAND ${CMAKE_COMMAND} -E copy
            ${sdl2_SOURCE_DIR}/lib/x64/SDL2.dll
            ${TEMP_EXE_FOLDER}/SDL2.dll
            DEPENDS ${sdl2_SOURCE_DIR}/lib/x64/SDL2.dll
            COMMENT "Copying SDL2.dll to executable directory"
    )
    add_dependencies(the_sdl2 copy_sdl2_dll)
else()
    if(EMSCRIPTEN)
        # --use-port=sdl2                     - we want version 2 rather than SDL1
        # https://emscripten.org/docs/tools_reference/settings_reference.html?highlight=use_sdl#use-sdl
        target_compile_options(the_sdl2 INTERFACE --use-port=sdl2)
        target_link_options(the_sdl2 INTERFACE --use-port=sdl2)
    else()
        # on    Mac : brew install sdl2
        # on Ubuntu : apt install libsdl2-dev
        find_package(SDL2 REQUIRED)
        target_include_directories(the_sdl2 SYSTEM INTERFACE ${SDL2_INCLUDE_DIRS})
        target_link_libraries(the_sdl2 INTERFACE ${SDL2_LIBRARIES})
    endif()
endif()



================================================
FILE: cmake/dependencies/STB.cmake
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

FetchContent_Declare(
    stb_github
    GIT_REPOSITORY https://github.com/nothings/stb.git
    # latest of master branch as of 8/22/2025
    GIT_TAG f58f558c120e9b32c217290b80bad1a0729fbb2c
)

FetchContent_MakeAvailable(stb_github)

if(NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/stb_implementation.cpp)
    set(STB_IMPLEMENTATION_CODE "// This file is auto-generated from cmake/depenendencies/STB.cmake
    #define STB_IMAGE_IMPLEMENTATION
    #include \"stb_image.h\"
    #define STB_PERLIN_IMPLEMENTATION
    #include \"stb_perlin.h\"
    //#include \"stb_vorbis.c\"
    ")

    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/stb_implementation.cpp ${STB_IMPLEMENTATION_CODE})
    set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/stb_implementation.cpp PROPERTIES GENERATED TRUE)
endif()

add_library(the_stb STATIC ${CMAKE_CURRENT_BINARY_DIR}/stb_implementation.cpp)
target_include_directories(the_stb SYSTEM PUBLIC ${stb_github_SOURCE_DIR})




================================================
FILE: docs/DebuggingWeb.md
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xe2 in position 1735: illegal multibyte sequence


================================================
FILE: docs/DevEnvironment.md
================================================
# Environment Setup

## Windows OS Setup

Install the following tools:

1. [**Visual Studio**](https://visualstudio.microsoft.com/downloads/)
   - Select C++-related packages during installation.
2. [**CMake**](https://cmake.org/download/)
   - Ensure it is available on the command line (`PATH`) if prompted.
3. [**Git SCM**](https://git-scm.com/downloads)
   - Ensure it is available on the command line (`PATH`) if prompted.
4. [**Ninja Build**](https://github.com/ninja-build/ninja/releases)
   - Manually add it to the command line (`PATH`).

## Web / Emscripten Setup

### Important Notice

**Do not use the Windows version of Emscripten for production.** Due to line-ending differences, generated output files may not work properly when uploaded to a web server. Instead, use Emscripten on a Linux-based OS such as macOS or Ubuntu (_[WSL](https://learn.microsoft.com/en-us/windows/wsl/install) works too_).

### Installation Steps

1. Review [Emscripten Platform-Specific Notes](https://emscripten.org/docs/getting_started/downloads.html#platform-notes-installation-instructions-sdk) for any prerequisites, such as Python 3.
2. Open a terminal and run:

```sh
   # Clone the emsdk repository
   git clone https://github.com/emscripten-core/emsdk.git

   # Navigate to the directory
   cd emsdk

   # Fetch the latest version of the SDK (if needed)
   git pull

   # Install the SDK tools
   ./emsdk install 4.0.13

   # Activate this version for the current user
   ./emsdk activate 4.0.13

   # Set environment variables for the current terminal session
   source ./emsdk_env.sh
```

### Emscripten Setup on Windows

If your main development platform is Windows, you should use [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) for creating `Release` builds.

However, for debugging with breakpoints, `WSL` may not work reliably. In this case, install the Windows version of Emscripten in your **User** directory (e.g., `C:/Users/<your-username>`). Follow these steps:

```sh
# Navigate to your User directory
cd %USERPROFILE%

# Clone the emsdk repository
git clone https://github.com/emscripten-core/emsdk.git

# Navigate to the directory
cd emsdk

# Install the SDK tools
emsdk install 4.0.13

# Activate this version
emsdk activate 4.0.13
```

For more details on debugging, see [Web Debugging](DebuggingWeb.md).

## Ubuntu / Debian OS Setup

### Install Required Tools

You need **GNU development tools** such as `make`, `git`, and other dependencies:

```sh
sudo apt install build-essential git cmake ninja-build libsdl2-dev libglew-dev libopenal-dev
```

## macOS Setup

### Install Xcode

Xcode is the integrated development environment (IDE) for macOS and includes necessary C++ tools.

1. Open the **App Store** and search for "Xcode" to install it.
2. Launch Xcode after installation to complete the setup.
3. Open **Terminal** (Applications > Utilities or use Spotlight Search).
4. Run the following command to install Command Line Tools:

   ```sh
   xcode-select --install
   ```
5. Follow the on-screen instructions.

### Install Development Tools & Libraries

1. **Install Homebrew** (if not already installed):
   - Visit [Homebrew's website](https://brew.sh) and follow the installation instructions.

2. **Install CMake, SDL2, and GLEW using Homebrew**:
   ```sh
   brew install cmake ninja sdl2 glew openal-soft
   ```

This will install the required development tools and dependencies automatically.



================================================
FILE: scripts/scan_build_project.py
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xe2 in position 1469: illegal multibyte sequence


================================================
FILE: source/CMakeLists.txt
================================================
# author Rudy Castan
# date 2025 Fall
# CS200 Computer Graphics I
# copyright DigiPen Institute of Technology

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

set(SOURCE_CODE
    Engine/Engine.h Engine/Engine.cpp
    Engine/Error.h
    Engine/Font.h Engine/Font.cpp
    Engine/Fonts.h
    Engine/FPS.h
    Engine/GameState.h
    Engine/GameStateManager.h Engine/GameStateManager.cpp
    Engine/Input.h Engine/Input.cpp
    Engine/Logger.h Engine/Logger.cpp
    Engine/Matrix.h Engine/Matrix.cpp
    Engine/Path.h Engine/Path.cpp
    Engine/Random.h Engine/Random.cpp
    Engine/Rect.h
    Engine/Texture.h Engine/Texture.cpp
    Engine/TextureManager.h Engine/TextureManager.cpp
    Engine/TextManager.h Engine/TextManager.cpp
    Engine/Timer.h
    Engine/Vec2.h Engine/Vec2.cpp
    Engine/Window.h Engine/Window.cpp
    Engine/Animation.cpp Engine/Animation.h
    Engine/Camera.cpp Engine/Camera.h
    Engine/Collision.cpp Engine/Collision.h
    Engine/Component.h
    Engine/ComponentManager.h
    Engine/GameObject.cpp Engine/GameObject.h
    Engine/GameObjectManager.cpp Engine/GameObjectManager.h
    Engine/Particle.cpp Engine/Particle.h
    Engine/ShowCollision.cpp Engine/ShowCollision.h
    Engine/Sprite.cpp Engine/Sprite.h

    OpenGL/Buffer.h OpenGL/Buffer.cpp
    OpenGL/Environment.h
    OpenGL/Framebuffer.h OpenGL/Framebuffer.cpp
    OpenGL/GL.cpp OpenGL/GL.h
    OpenGL/GLConstants.h
    OpenGL/GLTypes.h
    OpenGL/Handle.h
    OpenGL/Shader.cpp OpenGL/Shader.h
    OpenGL/Texture.h OpenGL/Texture.cpp
    OpenGL/VertexArray.cpp OpenGL/VertexArray.h

    CS200/Image.h CS200/Image.cpp
    CS200/ImGuiHelper.h CS200/ImGuiHelper.cpp
    CS200/ImmediateRenderer2D.h CS200/ImmediateRenderer2D.cpp
    CS200/BatchRenderer2D.h CS200/BatchRenderer2D.cpp
    CS200/InstancedRenderer2D.h CS200/InstancedRenderer2D.cpp
    CS200/IRenderer2D.h
    CS200/NDC.h
    CS200/Renderer2DUtils.h CS200/Renderer2DUtils.cpp
    CS200/RenderingAPI.h CS200/RenderingAPI.cpp
    CS200/RGBA.h
    CS200/Shape.h CS200/Shape.cpp
    CS200/PostProcessingPipeline.h CS200/PostProcessingPipeline.cpp
    CS200/OffscreenFramebuffer.h CS200/OffscreenFramebuffer.cpp

    Demo/DemoDepthPost.h Demo/DemoDepthPost.cpp

    Game/Background.h Game/Background.cpp
    Game/GameObjectTypes.h
    Game/MainMenu.h Game/MainMenu.cpp
    Game/Particles.h
    Game/Score.h Game/Score.cpp
    Game/Splash.h Game/Splash.cpp
    Game/States.h

    main.cpp
)

add_executable(engine_porting ${SOURCE_CODE})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${SOURCE_CODE})

target_link_libraries(engine_porting PRIVATE project_options dependencies)
target_include_directories(engine_porting PRIVATE .)

# Check the IS_DEVELOPER_VERSION cache variable
# This is set by the cmake configure preset
if (IS_DEVELOPER_VERSION)
    target_compile_definitions(engine_porting PRIVATE DEVELOPER_VERSION)
endif()

if(EMSCRIPTEN)

    # https://emscripten.org/docs/tools_reference/settings_reference.html
    # ASSERTIONS=1                  - we want asserts to work
    # WASM=1                        - we want web assembly generated rather than just javascript
    # DISABLE_EXCEPTION_CATCHING=0  - we are using exceptions so let's not disable them
    # ALLOW_MEMORY_GROWTH=1         - we don't know exactly how much heap space we'll need so allow it to grow
    # EXIT_RUNTIME=1                - have exiting actually stop the program
    # SINGLE_FILE=1                 - generate everything into one html file
    # --embed-file                  - https://emscripten.org/docs/tools_reference/emcc.html#emcc-embed-file
    # --use-preload-cache           - help with faster reloads : https://emscripten.org/docs/compiling/Deploying-Pages.html#providing-a-quick-second-time-load
    # -lembind                      - to call c++ from javascript https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html
    # --shell-file                  - to customize the webpage https://emscripten.org/docs/compiling/Deploying-Pages.html#build-files-and-custom-shell
    target_link_options(engine_porting PRIVATE 
    -sASSERTIONS=$<$<BOOL:${IS_DEVELOPER_VERSION}>:1>$<$<NOT:$<BOOL:${IS_DEVELOPER_VERSION}>>:0>
    -sWASM=1 
    -sDISABLE_EXCEPTION_CATCHING=0 
    -sALLOW_MEMORY_GROWTH=1 
    -sEXIT_RUNTIME=1 
    -sSINGLE_FILE=1 
    --embed-file ${CMAKE_SOURCE_DIR}/Assets@/Assets
    --use-preload-cache
    -lembind
    --shell-file ${CMAKE_SOURCE_DIR}/app_resources/web/index_shell.html
    )

    set_target_properties(engine_porting PROPERTIES SUFFIX ".html")
elseif(WIN32)

    target_link_options(engine_porting PRIVATE 
        $<IF:$<BOOL:${IS_DEVELOPER_VERSION}>,/SUBSYSTEM:CONSOLE,/SUBSYSTEM:WINDOWS>
        /ENTRY:mainCRTStartup)

    set(ICON_RC ${CMAKE_CURRENT_BINARY_DIR}/app.rc)
    if(NOT EXISTS ${ICON_RC})
        set(ICON_FILE ${CMAKE_SOURCE_DIR}/app_resources/windows/icon.ico)
        file(WRITE ${ICON_RC} "IDR_MAINFRAME ICON \"${ICON_FILE}\"\nIDI_ICON1 ICON DISCARDABLE \"${ICON_FILE}\"")
    endif()

    target_sources(engine_porting PRIVATE ${ICON_RC})

endif()



================================================
FILE: source/main.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2024 Fall
 * \copyright DigiPen Institute of Technology
 */

#include "Engine/Engine.h"
#include "Engine/GameStateManager.h"
#include "Engine/Window.h"
#include "Game/Splash.h"

namespace
{
    [[maybe_unused]] int  gWindowWidth  = 400;
    [[maybe_unused]] int  gWindowHeight = 400;
    [[maybe_unused]] bool gNeedResize   = false;
}


#if defined(__EMSCRIPTEN__)
#    include <emscripten.h>
#    include <emscripten/bind.h>
#    include <emscripten/em_asm.h>

void main_loop()
{
    Engine& engine = Engine::Instance();
    if (gNeedResize)
    {
        Engine::GetWindow().ForceResize(gWindowWidth, gWindowHeight);
        gNeedResize = false;
    }

    engine.Update();

    if (engine.HasGameEnded())
    {
        emscripten_cancel_main_loop();
        engine.Stop();
    }
}

EMSCRIPTEN_BINDINGS(main_window)
{
    emscripten::function(
        "setWindowSize", emscripten::optional_override(
                             [](int sizeX, int sizeY)
                             {
                                 sizeX                  = (sizeX < 400) ? 400 : sizeX; // Minimum size enforcement
                                 sizeY                  = (sizeY < 400) ? 400 : sizeY; // Minimum size enforcement  
                                 const auto window_size = Engine::GetWindow().GetSize();
                                 if (sizeX != window_size.x || sizeY != window_size.y)
                                 {
                                     gNeedResize   = true;
                                     gWindowWidth  = sizeX;
                                     gWindowHeight = sizeY;
                                 }
                             }));
}
#endif

int main([[maybe_unused]] int argc, [[maybe_unused]] char* argv[])
{
    Engine& engine = Engine::Instance();
    engine.Start("Taekyung Ho CS200 HW8");
    engine.GetGameStateManager().PushState<Splash>();

#if !defined(__EMSCRIPTEN__)
    while (engine.HasGameEnded() == false)
    {
        engine.Update();
    }
    engine.Stop();
#else
    // https://emscripten.org/docs/api_reference/emscripten.h.html#c.emscripten_set_main_loop
    constexpr bool simulate_infinite_loop  = true;
    constexpr int  match_browser_framerate = -1;
    emscripten_set_main_loop(main_loop, match_browser_framerate, simulate_infinite_loop);
#endif
    return 0;
}



================================================
FILE: source/CS200/BatchRenderer2D.cpp
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "BatchRenderer2D.h"

#include "Engine/Path.h"
#include "OpenGL/Buffer.h"
#include "OpenGL/GL.h"
#include "OpenGL/VertexArray.h"
#include "Renderer2DUtils.h"
#include <fstream>
#include <numeric>
#include <sstream>

namespace CS200
{
	BatchRenderer2D::BatchRenderer2D(unsigned max_quads)
	{
		maxVertices = max_quads * 4; // each quad have 4 vertices
		maxIndices	= max_quads * 6;
		vertexData.resize(maxVertices);
		sdfVertexData.resize(maxVertices);

		// wait until other stuffs are ready.. ->Init
	}

	BatchRenderer2D::BatchRenderer2D(BatchRenderer2D&& other) noexcept
		: vertexData(std::move(other.vertexData)),
          vertexBufferHandle(other.vertexBufferHandle),
          texturingCombineShader(std::move(other.texturingCombineShader)),
          modelHandle(other.modelHandle),
          sdfVertexData(std::move(other.sdfVertexData)),
          sdfVertexBufferHandle(other.sdfVertexBufferHandle),
          sdfShader(std::move(other.sdfShader)),
          sdfModelHandle(other.sdfModelHandle),
          sdfVertexDataEnd(other.sdfVertexDataEnd),
          sdfIndexCount(other.sdfIndexCount),
          indexBufferHandle(other.indexBufferHandle),
          camera_uniform_buffer(other.camera_uniform_buffer),
          camera_array(other.camera_array),
          currentCameraMatrix(other.currentCameraMatrix),
          maxVertices(other.maxVertices),
          maxIndices(other.maxIndices),
          vertexDataEnd(other.vertexDataEnd),
          indexCount(other.indexCount),
          textureSlots(std::move(other.textureSlots)),
          activeTextureSize(other.activeTextureSize),
          draw_call(other.draw_call), 
		  texture_call(other.texture_call)
	{
		other.vertexBufferHandle	 = 0;
		other.modelHandle			 = 0;
		other.sdfVertexBufferHandle	 = 0;
		other.sdfModelHandle		 = 0;
		other.indexBufferHandle		 = 0;
		other.camera_uniform_buffer	 = 0;
		other.texturingCombineShader = {};
		other.sdfShader				 = {};
		other.vertexDataEnd			 = nullptr;
		other.indexCount			 = 0;
		other.sdfVertexDataEnd		 = nullptr;
		other.sdfIndexCount			 = 0;
		other.activeTextureSize		 = 0;
		other.draw_call				 = 0;
		other.texture_call			 = 0;
	}

	BatchRenderer2D& BatchRenderer2D::operator=(BatchRenderer2D&& other) noexcept
	{
		std::swap(vertexData, other.vertexData);
		std::swap(vertexBufferHandle, other.vertexBufferHandle);
		std::swap(indexBufferHandle, other.indexBufferHandle);
		std::swap(modelHandle, other.modelHandle);
		std::swap(texturingCombineShader, other.texturingCombineShader);
		std::swap(currentCameraMatrix, other.currentCameraMatrix);

		std::swap(sdfVertexData, other.sdfVertexData);
		std::swap(sdfVertexBufferHandle, other.sdfVertexBufferHandle);
		std::swap(sdfShader, other.sdfShader);
		std::swap(sdfModelHandle, other.sdfModelHandle);
		std::swap(sdfVertexDataEnd, other.sdfVertexDataEnd);
		std::swap(sdfIndexCount, other.sdfIndexCount);

		std::swap(camera_uniform_buffer, other.camera_uniform_buffer);
		std::swap(camera_array, other.camera_array);
		std::swap(draw_call, other.draw_call);
		std::swap(texture_call, other.texture_call);

		std::swap(maxVertices, other.maxVertices);
		std::swap(maxIndices, other.maxIndices);
		std::swap(vertexDataEnd, other.vertexDataEnd);
		std::swap(indexCount, other.indexCount);
		std::swap(textureSlots, other.textureSlots);
		std::swap(activeTextureSize, other.activeTextureSize);
		return *this;
	}

	BatchRenderer2D::~BatchRenderer2D()
	{
		Shutdown();
	}

	void BatchRenderer2D::Init()
	{
		// get how many texture opengl can draw
		GLint max_tex_units = 0;
		GL::GetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &max_tex_units); // check with docs.gl to get minimum(16) and maximum
		textureSlots.resize(static_cast<size_t>(std::min(max_tex_units, 64)));

		// load shaders with parsing
		const std::filesystem::path vertex_file = assets::locate_asset("Assets/shaders/BatchRenderer2D/quad.vert");
		std::ifstream				vert_stream(vertex_file);
		std::stringstream			vert_text_stream;
		vert_text_stream << vert_stream.rdbuf();
		const std::string vertex_glsl = vert_text_stream.str();


		const std::filesystem::path fragment_file = assets::locate_asset("Assets/shaders/BatchRenderer2D/quad.frag");
		std::ifstream				frag_stream(fragment_file);
		std::stringstream			frag_text_stream;
		frag_text_stream << frag_stream.rdbuf();
		std::string		  frag_glsl		= frag_text_stream.str();
		const size_t	  first_newline = frag_glsl.find('\n');
		const std::string define_line	= "\n#define MAX_TEXTURE_SLOTS " + std::to_string(textureSlots.size());
		frag_glsl.insert(first_newline, define_line);

		texturingCombineShader = OpenGL::CreateShader(std::string_view{ vertex_glsl }, std::string_view{ frag_glsl });


		// have to set their binding index
		GL::UseProgram(texturingCombineShader.Shader);

		std::vector<int> sampler_binding_values(textureSlots.size());
		std::iota(sampler_binding_values.begin(), sampler_binding_values.end(), 0);
		const GLint location = GL::GetUniformLocation(texturingCombineShader.Shader, "uTextures");
		GL::Uniform1iv(location, static_cast<GLsizei>(textureSlots.size()), sampler_binding_values.data());

		GL::UseProgram(0);

		// create vertex array object, buffer vertices, buffer indices
		vertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(QuadVertex) * maxVertices));


		// setup index buffer

		// unlike vertex buffer that gonna change every frame, index don't change
		// i.e. 0 1 2 2 3 0 ... << this pattern repeat
		// but just amount of index gonna change(how many do we need?)
		std::vector<unsigned> indice_values(maxIndices);
		unsigned			  offset = 0;
		for (unsigned i = 0; i < maxIndices; i += 6)
		{
			indice_values[i + 0] = offset + 0;
			indice_values[i + 1] = offset + 1;
			indice_values[i + 2] = offset + 2;
			indice_values[i + 3] = offset + 2;
			indice_values[i + 4] = offset + 3;
			indice_values[i + 5] = offset + 0;
			offset += 4;
		}

		indexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Indices, std::as_bytes(std::span{ indice_values }));

		// Create vertex array object
		const auto layout = {
			OpenGL::VertexBuffer{ vertexBufferHandle, { OpenGL::Attribute::Float2, OpenGL::Attribute::Float2, OpenGL::Attribute::UByte4ToNormalized, OpenGL::Attribute::Int, OpenGL::Attribute::Float } }
		};
		modelHandle = OpenGL::CreateVertexArrayObject(layout, indexBufferHandle);


		// SDF
		//  create vertex array object, buffer vertices, buffer indices
		sdfShader = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/BatchRenderer2D/sdf.vert"), assets::locate_asset("Assets/shaders/BatchRenderer2D/sdf.frag"));

		sdfVertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(SDFVertex) * maxVertices));
		const auto sdfLayout  = {
			 OpenGL::VertexBuffer{ sdfVertexBufferHandle,
								   {
									   OpenGL::Attribute::Float2,			  // aWorldPosition
									   OpenGL::Attribute::Float2,			  // aTestPoint
									   OpenGL::Attribute::UByte4ToNormalized, // aFillColor
									   OpenGL::Attribute::UByte4ToNormalized, // aLineColor
									   OpenGL::Attribute::Float2,			  // aWorldSize
									   OpenGL::Attribute::Float,			  // aLineWidth
									   OpenGL::Attribute::Int,				  // aShape
									   OpenGL::Attribute::Float				  // aDepth
								   } }
		};
		sdfModelHandle = OpenGL::CreateVertexArrayObject(sdfLayout, indexBufferHandle);

		//- Create uniform buffer for camera/view-projection matrix
		camera_uniform_buffer = OpenGL::CreateBuffer(OpenGL::BufferType::UniformBlocks, sizeof(camera_array));

		OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");
		OpenGL::BindUniformBufferToShader(sdfShader.Shader, 0, camera_uniform_buffer, "NDC");
	}

	void BatchRenderer2D::Shutdown()
	{
		OpenGL::DestroyShader(texturingCombineShader);
		OpenGL::DestroyShader(sdfShader);

		GL::DeleteBuffers(1, &vertexBufferHandle), vertexBufferHandle		= 0;
		GL::DeleteBuffers(1, &indexBufferHandle), indexBufferHandle			= 0;
		GL::DeleteBuffers(1, &sdfVertexBufferHandle), sdfVertexBufferHandle = 0;

		GL::DeleteBuffers(1, &camera_uniform_buffer), camera_uniform_buffer = 0;

		GL::DeleteVertexArrays(1, &modelHandle), modelHandle	   = 0;
		GL::DeleteVertexArrays(1, &sdfModelHandle), sdfModelHandle = 0;
	}

	void BatchRenderer2D::BeginScene(const Math::TransformationMatrix& view_projection)
	{
		//- Store matrix for potential later use
		currentCameraMatrix = view_projection;

		//- Convert 3x3 matrix to 4x3 format for uniform buffer
		updateCameraUniformValues(currentCameraMatrix);

		//- Update uniform buffer with new matrix data
		OpenGL::UpdateBufferData(OpenGL::BufferType::UniformBlocks, camera_uniform_buffer, std::as_bytes(std::span{ camera_array }));

		//- Bind uniform buffer for use by shaders
		GL::BindBuffer(GL_UNIFORM_BUFFER, camera_uniform_buffer);

		draw_call	 = 0;
		texture_call = 0;
		startBatch();
	}

	void BatchRenderer2D::EndScene()
	{
		flush();
	}

	void BatchRenderer2D::DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth)
	{
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}

		if (indexCount + 6 > maxIndices)
		{
			flush();
		}

		int	 tex_index = 0;
		bool found	   = false;
		for (size_t i = 0; i < activeTextureSize; ++i)
		{
			if (textureSlots[i] == texture)
			{
				found	  = true;
				tex_index = static_cast<int>(i);
			}
		}

		if (!found)
		{
			if (activeTextureSize >= textureSlots.size())
			{
				flush();
			}
			tex_index						= static_cast<int>(activeTextureSize);
			textureSlots[activeTextureSize] = texture;
			++activeTextureSize;
		}

		// Convert texture_coords_lbrt (left, bottom, right, top) to texture coordinate transform matrix
		const float left   = static_cast<float>(texture_coord_bl.x);
		const float bottom = static_cast<float>(texture_coord_bl.y);
		const float right  = static_cast<float>(texture_coord_tr.x);
		const float top	   = static_cast<float>(texture_coord_tr.y);

		const std::array<float, 2> texture_coords[4] = {
			{  left, bottom }, //  bottom left
			{ right, bottom }, //  bottom right
			{ right,	 top }, //  top right
			{  left,	top }  //  top left
		};

		// we don't have to make texcoord_transform matrix, just use 4 texture coords right away!

		// const std::array<unsigned char, 4> tint = pack_color(tint_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};


		for (unsigned i = 0; i < 4; ++i) // i is for 4 vertex(bottom/top - right/left)
		{
			// matrix multiply manually (3by 3, transform matrix) * (3 by 1, position matrix) => model to world!
			const float x =
				static_cast<float>(static_cast<double>(model_positions[i][0])  * transform[0][0] + static_cast<double>(model_positions[i][1])  * transform[0][1] + transform[0][2]);
			const float y = static_cast<float>(static_cast<double>(model_positions[i][0]) * transform[1][0] + static_cast<double>(model_positions[i][1]) * transform[1][1] + transform[1][2]);

			vertexDataEnd->x			= x;
			vertexDataEnd->y			= y;
			vertexDataEnd->s			= texture_coords[i][0];
			vertexDataEnd->t			= texture_coords[i][1];
			vertexDataEnd->tint			= ColorArray(tintColor);
			vertexDataEnd->textureIndex = tex_index;
			vertexDataEnd->depth		= depth;
			++vertexDataEnd;
		}
		indexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawCircle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (indexCount + 6 > maxIndices)
		{
			flush();
		}
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}

		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};

		for (unsigned i = 0; i < 4; ++i)
		{
			const float x = model_positions[i][0] * sdf_transform.QuadTransform[0] + model_positions[i][1] * sdf_transform.QuadTransform[3] + sdf_transform.QuadTransform[6];
			const float y = model_positions[i][0] * sdf_transform.QuadTransform[1] + model_positions[i][1] * sdf_transform.QuadTransform[4] + sdf_transform.QuadTransform[7];

			const float s = model_positions[i][0] * sdf_transform.QuadSize[0];
			const float t = model_positions[i][1] * sdf_transform.QuadSize[1];

			sdfVertexDataEnd->x			  = x;
			sdfVertexDataEnd->y			  = y;
			sdfVertexDataEnd->testPoint_s = s;
			sdfVertexDataEnd->testPoint_t = t;
			sdfVertexDataEnd->fillColor	  = fill_bytes;
			sdfVertexDataEnd->lineColor	  = line_bytes;
			sdfVertexDataEnd->worldSize_x = sdf_transform.WorldSize[0];
			sdfVertexDataEnd->worldSize_y = sdf_transform.WorldSize[1];
			sdfVertexDataEnd->lineWidth	  = static_cast<float>(line_width);
			sdfVertexDataEnd->shape		  = static_cast<int>(SDFShape::Circle); // 0
			sdfVertexDataEnd->depth		  = depth;

			++sdfVertexDataEnd;
		}
		sdfIndexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawRectangle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (indexCount + 6 > maxIndices)
		{
			flush();
		}
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}
		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};

		for (unsigned i = 0; i < 4; ++i)
		{
			const float x = model_positions[i][0] * sdf_transform.QuadTransform[0] + model_positions[i][1] * sdf_transform.QuadTransform[3] + sdf_transform.QuadTransform[6];
			const float y = model_positions[i][0] * sdf_transform.QuadTransform[1] + model_positions[i][1] * sdf_transform.QuadTransform[4] + sdf_transform.QuadTransform[7];
			const float s = model_positions[i][0] * sdf_transform.QuadSize[0];
			const float t = model_positions[i][1] * sdf_transform.QuadSize[1];

			sdfVertexDataEnd->x			  = x;
			sdfVertexDataEnd->y			  = y;
			sdfVertexDataEnd->testPoint_s = s;
			sdfVertexDataEnd->testPoint_t = t;
			sdfVertexDataEnd->fillColor	  = fill_bytes;
			sdfVertexDataEnd->lineColor	  = line_bytes;
			sdfVertexDataEnd->worldSize_x = sdf_transform.WorldSize[0];
			sdfVertexDataEnd->worldSize_y = sdf_transform.WorldSize[1];
			sdfVertexDataEnd->lineWidth	  = static_cast<float>(line_width);
			sdfVertexDataEnd->shape		  = static_cast<int>(SDFShape::Rectangle); // 1
			sdfVertexDataEnd->depth		  = depth;

			++sdfVertexDataEnd;
		}
		sdfIndexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawLine(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color,
		[[maybe_unused]] double line_width, float depth)
	{
		const auto line_transform = Renderer2DUtils::CalculateLineTransform(transform, start_point, end_point, line_width);
		DrawRectangle(line_transform, line_color, line_color, line_width,depth);
	}

	void BatchRenderer2D::DrawLine([[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		DrawLine(Math::TransformationMatrix{}, start_point, end_point, line_color, line_width, depth);
	}

	void BatchRenderer2D::startBatch()
	{
		vertexDataEnd	  = vertexData.data();
		indexCount		  = 0;
		activeTextureSize = 0;

		sdfVertexDataEnd = sdfVertexData.data();
		sdfIndexCount	 = 0;

	}

	void BatchRenderer2D::flush()
	{
		if (indexCount > 0)
		{
			// upload our vertices(vertex buffer is dynamic)
			const ptrdiff_t					 vertex_count  = vertexDataEnd - vertexData.data();
			const std::span					 data_span	   = std::span{ vertexData.data(), static_cast<size_t>(vertex_count) };
			const std::span<const std::byte> bytes_to_send = std::as_bytes(data_span);

			GL::BindBuffer(GL_ARRAY_BUFFER, vertexBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(QuadVertex) * maxVertices), nullptr, GL_DYNAMIC_DRAW); // orphaning

			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, vertexBufferHandle, bytes_to_send);


			// select our texture
			for (size_t i = 0; i < activeTextureSize; ++i)
			{
				GL::ActiveTexture(static_cast<GLenum>(GL_TEXTURE0 + i));
				GL::BindTexture(GL_TEXTURE_2D, textureSlots[i]);
			}

			// draw
			GL::UseProgram(texturingCombineShader.Shader);
			GL::BindVertexArray(modelHandle);
			GL::DrawElements(GL_TRIANGLES, static_cast<GLsizei>(indexCount), GL_UNSIGNED_INT, nullptr);
			++draw_call;
		}

		if (sdfIndexCount > 0)
		{
			const ptrdiff_t					 sdf_vertex_count_ptrdiff = sdfVertexDataEnd - sdfVertexData.data();
			const std::span					 sdf_data_span			  = std::span{ sdfVertexData.data(), static_cast<size_t>(sdf_vertex_count_ptrdiff) };
			const std::span<const std::byte> sdf_bytes_to_send		  = std::as_bytes(sdf_data_span);

			GL::BindBuffer(GL_ARRAY_BUFFER, sdfVertexBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(SDFVertex) * maxVertices), nullptr, GL_DYNAMIC_DRAW); // orphaning
			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, sdfVertexBufferHandle, sdf_bytes_to_send);

			GL::UseProgram(sdfShader.Shader);
			GL::BindVertexArray(sdfModelHandle);
			GL::DrawElements(GL_TRIANGLES, static_cast<GLsizei>(sdfIndexCount), GL_UNSIGNED_INT, nullptr);
			++draw_call;
		}


		// unbind stuff
		GL::BindVertexArray(0);
		GL::UseProgram(0);
		GL::BindTexture(GL_TEXTURE_2D, 0);
		GL::BindBuffer(GL_ARRAY_BUFFER, 0);

		startBatch(); // reset
	}

	void BatchRenderer2D::updateCameraUniformValues(const Math::TransformationMatrix& view_projection)
	{
		const auto as_3x3 = Renderer2DUtils::to_opengl_mat3(view_projection);
		for (std::size_t col = 0; col < 3; ++col)
		{
			const std::size_t src_offset = col * 3;
			const std::size_t dst_offset = col * 4;

			camera_array[dst_offset + 0] = as_3x3[src_offset + 0]; // how?****
			camera_array[dst_offset + 1] = as_3x3[src_offset + 1];
			camera_array[dst_offset + 2] = as_3x3[src_offset + 2];
			camera_array[dst_offset + 3] = 0.0f;
		}
	}

	size_t BatchRenderer2D::GetDrawCallCounter()
	{
		return draw_call;
	}

	size_t BatchRenderer2D::GetDrawTextureCounter()
	{
		return texture_call;
	}

} // namespace CS200



================================================
FILE: source/CS200/BatchRenderer2D.h
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Matrix.h"
#include "IRenderer2D.h"
#include "OpenGL/Shader.h"
#include "OpenGL/VertexArray.h"
#include <array>
#include <vector>

/**
 *
 * basic idea - either buffer is full(reached max_quads) or user invoked endscene-> draw one time
 */
namespace CS200
{
	class BatchRenderer2D : public IRenderer2D
	{
	public:
		BatchRenderer2D(unsigned max_quads = 10'000);
		BatchRenderer2D(const BatchRenderer2D& other) = delete;
		BatchRenderer2D(BatchRenderer2D&& other) noexcept;
		BatchRenderer2D& operator=(const BatchRenderer2D& other) = delete;
		BatchRenderer2D& operator=(BatchRenderer2D&& other) noexcept;
		~BatchRenderer2D() override;

		void Init() override;
		void Shutdown() override;
		// void BeginScene(std::span<const float, 9> ndc_matrix) override;
		void BeginScene(const Math::TransformationMatrix& view_projection) override;
		void EndScene() override;
		void
			DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth) override;
		// void DrawQuad(std::span<const float, 9> transform, OpenGL::Handle texture, std::span<const float, 4> texture_coords_lbrt, std::span<const float, 4> tint_color) override;
		void DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;

	private:
		struct QuadVertex
		{
			float						 x = 0, y = 0;
			float						 s = 0, t = 0;
			std::array<unsigned char, 4> tint{};
			int							 textureIndex = 0;
			float						 depth;
		};

		std::vector<QuadVertex> vertexData{};
		OpenGL::BufferHandle	vertexBufferHandle{};

		OpenGL::CompiledShader texturingCombineShader{};

		OpenGL::VertexArrayHandle modelHandle{};

		// sdf
		struct SDFVertex
		{
			float						 x = 0, y = 0;					   // Layout 0: aWorldPosition
			float						 testPoint_s = 0, testPoint_t = 0; // Layout 1: aTestPoint
			std::array<unsigned char, 4> fillColor{};					   // Layout 2: aFillColor
			std::array<unsigned char, 4> lineColor{};					   // Layout 3: aLineColor
			float						 worldSize_x = 0, worldSize_y = 0; // Layout 4: aWorldSize
			float						 lineWidth = 0;					   // Layout 5: aLineWidth
			int							 shape	   = 0;					   // Layout 6: aShape (0=Circle, 1=Rect)
			float						 depth	   = 0;					   // Layout 7: aDepth
		};

		std::vector<SDFVertex>	  sdfVertexData{};
		OpenGL::BufferHandle	  sdfVertexBufferHandle{};
		OpenGL::CompiledShader	  sdfShader{};
		OpenGL::VertexArrayHandle sdfModelHandle{};
		SDFVertex*				  sdfVertexDataEnd = nullptr; // pointing where we are
		unsigned				  sdfIndexCount	   = 0;

		OpenGL::BufferHandle	   indexBufferHandle{};
		OpenGL::BufferHandle	   camera_uniform_buffer{};
		std::array<float, 12>	   camera_array{};
		Math::TransformationMatrix currentCameraMatrix{};
		// limit how much we're going to put into that vertex buffer
		unsigned				   maxVertices = 0;
		unsigned				   maxIndices  = 0;

		void updateCameraUniformValues(const Math::TransformationMatrix& view_projection);


		enum class SDFShape : uint8_t
		{
			Circle	  = 0,
			Rectangle = 1,
		};
		// void DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape);


		QuadVertex* vertexDataEnd = nullptr; // pointing where we are
		unsigned	indexCount	  = 0;

		// OpenGL::Handle theTexture = 0;
		std::vector<OpenGL::TextureHandle> textureSlots;
		size_t							   activeTextureSize = 0;

	private:
		void flush(); // when quad amount is reached to max_quad
		void startBatch();

		size_t draw_call = 0;
		size_t GetDrawCallCounter() override;

		size_t texture_call = 0;
		size_t GetDrawTextureCounter() override;
	};

}



================================================
FILE: source/CS200/Image.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Image.h"

#include "Engine/Error.h"
#include "Engine/Path.h"

#include <stb_image.h>
#include <utility>

namespace CS200
{
    Image::Image(const std::filesystem::path& image_path, bool flip_vertical)
    {
        const std::filesystem::path image_path_ctor = assets::locate_asset(image_path);
        stbi_set_flip_vertically_on_load(flip_vertical);
        constexpr int num_channels       = 4;                                                                                                            // rgba
        int           files_num_channels = 0;                                                                                                            // to here
        image_data                       = stbi_load(image_path_ctor.string().c_str(), &dimensions.x, &dimensions.y, &files_num_channels, num_channels); // loading, use dynamic memory so we need free
        if (!image_data)
        {
            throw_error_message("Loading Fail ");
        }
    }

    Image::Image(Image&& temporary) noexcept : image_data{ temporary.image_data }, dimensions{ temporary.dimensions }
    {
        temporary.image_data = nullptr;
        temporary.dimensions = { 0, 0 };
    }

    Image& Image::operator=(Image&& temporary) noexcept
    {
        std::swap(image_data, temporary.image_data);
        std::swap(dimensions, temporary.dimensions);
        return *this;
    }

    Image::~Image()
    {
        if (image_data)
        {
            stbi_image_free(image_data);
        }
    }

    const RGBA* Image::data() const noexcept
    {
        return reinterpret_cast<const RGBA*>(image_data);
    }

    RGBA* Image::data() noexcept
    {
        return reinterpret_cast<RGBA*>(image_data);
    }

    Math::ivec2 Image::GetSize() const noexcept
    {
        return dimensions;
    }


    
}



================================================
FILE: source/CS200/Image.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Vec2.h"
#include "RGBA.h"
#include <filesystem>
#include <gsl/gsl>

#include <stb_image.h>

namespace CS200
{
    /**
     * \brief RAII wrapper for loading and managing image pixel data from files
     *
     * The Image class provides a safe, automatic way to load image files (PNG, JPG, etc.)
     * and access their pixel data for use in graphics applications. It handles all the
     * complexity of file loading, memory management, and data conversion.
     *
     * Key Features:
     * - Automatic file loading using stb_image library
     * - Always converts to consistent RGBA format (4 bytes, 32bits per pixel)
     * - RAII memory management (automatic cleanup in destructor)
     * - Move-only semantics to prevent expensive copying
     * - Optional vertical flipping for different coordinate systems
     *
     * Common Use Cases:
     * - Loading textures for sprites, backgrounds, UI elements
     * - Reading image data for procedural generation or analysis
     * - Converting various image formats to a consistent RGBA format
     * - Preparing pixel data for upload to GPU textures
     *
     * Memory Layout:
     * - Pixels stored in row-major order (left-to-right, top-to-bottom)
     * - Each pixel is 4 bytes: Red, Green, Blue, Alpha (0-255 each)
     * - Total memory = width 횞 height 횞 4 bytes
     *
     * Example Usage:
     * \code
     * // Load an image file
     * Image sprite_image("sprites/player.png");
     *
     * // Get image properties
     * auto size = sprite_image.GetSize();
     * int width = size.x, height = size.y;
     *
     * // Access pixel data
     * const RGBA* pixels = sprite_image.data();
     * RGBA top_left_pixel = pixels[0];
     *
     * // Move to another Image (efficient)
     * Image moved_image = std::move(sprite_image);
     * \endcode
     */
    class Image
    {
    public:
        /**
         * \brief Load an image from file and store its pixel data
         * \param image_path Path to the image file (relative to Assets folder, like "Assets/ship.png")
         * \param flip_vertical Whether to flip the image vertically when loading (default: false)
         *
         * Implementation notes:
         * - Use assets::locate_asset() to find the full file path
         * - Use stb_image library functions to load the image data
         * - Always load as 4-channel RGBA regardless of source format
         * - Set stbi_set_flip_vertically_on_load() before loading
         * - Throw an error if loading fails
         * - Store the loaded pixel data and image dimensions
         */
        explicit Image(const std::filesystem::path& image_path, bool flip_vertical = false);

        /**
         * \brief Copy constructor - deleted to prevent accidental copying
         * Images manage dynamic memory and should not be copied
         */
        Image(const Image&) = delete;

        /**
         * \brief Copy assignment - deleted to prevent accidental copying
         * Images manage dynamic memory and should not be copied
         */
        Image& operator=(const Image&) = delete;

        /**
         * \brief Move constructor - transfer ownership of image data
         * \param temporary The temporary Image object to move from
         *
         * Implementation notes:
         * - Transfer ownership of pixel data pointer and size
         * - Set the source object's data to nullptr and size to {0,0}
         * - Use noexcept to enable move optimizations
         */
        Image(Image&& temporary) noexcept;

        /**
         * \brief Move assignment - transfer ownership of image data
         * \param temporary The temporary Image object to move from
         * \return Reference to this object
         *
         * Implementation notes:
         * - Use std::swap to exchange data between objects
         * - This safely handles self-assignment and cleanup
         */
        Image& operator=(Image&& temporary) noexcept;

        /**
         * \brief Destructor - free the allocated image data
         *
         * Implementation notes:
         * - Check if pixel data pointer is not nullptr
         * - Use stbi_image_free() to properly release memory allocated by stb_image
         */
        ~Image();

        /**
         * \brief Get read-only access to the pixel data array
         * \return Const pointer to the first RGBA pixel
         *
         * Implementation notes:
         * - Return the stored pixel data pointer as const
         * - Pixels are stored in row-major order (left-to-right, top-to-bottom)
         */
        const RGBA* data() const noexcept;

        /**
         * \brief Get read-write access to the pixel data array
         * \return Pointer to the first RGBA pixel for modification
         *
         * Implementation notes:
         * - Return the stored pixel data pointer for modification
         * - Pixels are stored in row-major order (left-to-right, top-to-bottom)
         */
        RGBA* data() noexcept;

        /**
         * \brief Get the dimensions of the loaded image
         * \return Vector containing width (x) and height (y) in pixels
         *
         * Implementation notes:
         * - Return the stored image dimensions
         * - Width and height are set during image loading
         */
        Math::ivec2 GetSize() const noexcept;

    private:
        
        stbi_uc*    image_data = nullptr;
        Math::ivec2 dimensions;
    };

}



================================================
FILE: source/CS200/ImGuiHelper.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "ImGuiHelper.h"

#include <SDL.h>
#include <backends/imgui_impl_opengl3.h>
#include <backends/imgui_impl_sdl2.h>
#include <imgui.h>
#include <imgui_internal.h> // for DockBuilderGetCentralNode until they stabilize make DockBuilder

namespace
{
    std::string   gImGuiSaveFilePath;
    SDL_Window*   gCachedWindow    = nullptr;
    SDL_GLContext gCachedGLContext = nullptr;
}

namespace ImGuiHelper
{
    void Initialize(gsl::not_null<SDL_Window*> sdl_window, gsl::not_null<SDL_GLContext> gl_context, const std::filesystem::path& ini_file_path)
    {
        // Cache the window and context for later use
        gCachedWindow    = sdl_window;
        gCachedGLContext = gl_context;

        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        {
            ImGuiIO& io = ImGui::GetIO();
            io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
            io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;
            gImGuiSaveFilePath = ini_file_path.string();
            io.IniFilename     = gImGuiSaveFilePath.c_str();
        }
        ImGui_ImplSDL2_InitForOpenGL(sdl_window, gl_context);
        ImGui_ImplOpenGL3_Init();
    }

    void FeedEvent(const SDL_Event& event)
    {
        ImGui_ImplSDL2_ProcessEvent(&event);
    }

    Viewport Begin()
    {
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame();
        ImGui::NewFrame();

        // enable docking on main window, based off of imgui docking demo
        {
            const ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_PassthruCentralNode | ImGuiDockNodeFlags_NoDockingInCentralNode;
            const ImGuiWindowFlags   window_flags = ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize |
                                                  ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
            const ImGuiViewport* const main_viewport   = ImGui::GetMainViewport();
            const auto                 window_position = main_viewport->Pos;
            const auto                 window_size     = main_viewport->Size;
            ImGui::SetNextWindowPos(window_position);
            ImGui::SetNextWindowSize(window_size);
            ImGui::SetNextWindowViewport(main_viewport->ID);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
            ImGui::Begin("Main Window Dockspace", nullptr, window_flags);
            ImGui::PopStyleVar(3);
            const ImGuiID dockspace_id = ImGui::GetID("Main Window Dockspace");
            ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);

            // How to get central area : https://github.com/ocornut/imgui/issues/5921#issuecomment-1327801959
            // Central Node is the middle area where we want the main display to be
            const ImGuiDockNode* const node = ImGui::DockBuilderGetCentralNode(dockspace_id);
            if (node == nullptr) [[unlikely]]
                return Viewport{ 0, 0, static_cast<int>(window_size.x), static_cast<int>(window_size.y) };
            // the central node's position is relative to the monitor, so we need main viewport to turn relative to the window
            const int opengl_x = static_cast<int>((node->Pos.x - window_position.x)); // convert relative to window x
            const int opengl_y =
                static_cast<int>((window_size.y - ((node->Pos.y - window_position.y) + node->Size.y))); // convert relative to window x and then convert to opengl convention where 0,0 is bottom left
            const int opengl_w = static_cast<int>(node->Size.x);                                        // width of central node is what we want
            const int opengl_h = static_cast<int>(node->Size.y);                                        // height of central node is what we want
            ImGui::End();                                                                               // end main window docking
            return Viewport{ opengl_x, opengl_y, opengl_w, opengl_h };
        }
    }

    void End()
    {
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        const ImGuiIO& io = ImGui::GetIO();
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            ImGui::UpdatePlatformWindows();
            ImGui::RenderPlatformWindowsDefault();
            SDL_GL_MakeCurrent(gCachedWindow, gCachedGLContext);
        }
    }

    void Shutdown()
    {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplSDL2_Shutdown();
        ImGui::DestroyContext();

        gCachedWindow    = nullptr;
        gCachedGLContext = nullptr;
    }
}



================================================
FILE: source/CS200/ImGuiHelper.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <filesystem>
#include <gsl/gsl>

struct SDL_Window;
typedef void* SDL_GLContext;
union SDL_Event;

namespace ImGuiHelper
{
    void Initialize(gsl::not_null<SDL_Window*> sdl_window, gsl::not_null<SDL_GLContext> gl_context, const std::filesystem::path& ini_file_path = "imgui.ini");
    void FeedEvent(const SDL_Event& event);

    struct Viewport
    {
        int  x = 0, y = 0;
        int  width = 0, height = 0;
        bool operator==(const Viewport&) const = default;
    };

    Viewport Begin();
    void     End();
    void     Shutdown();

}



================================================
FILE: source/CS200/ImmediateRenderer2D.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "ImmediateRenderer2D.h"
#include "Engine/Engine.h"
#include "Engine/Matrix.h"
#include "Engine/Path.h"
#include "Engine/Texture.h"
#include "Engine/Window.h"
#include "NDC.h"
#include "OpenGL/Buffer.h"
#include "OpenGL/GL.h"
#include "Renderer2DUtils.h"
#include "RenderingAPI.h"
#include <span>
#include <utility>

namespace CS200
{


    void ImmediateRenderer2D::Init()
    {
        /** - Create index buffer with quad indices (0,1,2,2,3,0)
         * - Create vertex buffer with quad vertices (-0.5 to 0.5 range)
         * - Set up VAO with position and texture coordinate attributes
         * - Create SDF vertex buffer (position-only attributes) */

        //- Load and compile vertex/fragment shaders from Assets/shaders/
        const std::filesystem::path vertex_file   = assets::locate_asset("Assets/shaders/ImmediateRenderer2D/quad.vert");
        const std::filesystem::path fragment_file = assets::locate_asset("Assets/shaders/ImmediateRenderer2D/quad.frag");
        texturingCombineShader                    = OpenGL::CreateShader(vertex_file, fragment_file);

        sdfShader = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/ImmediateRenderer2D/sdf.vert"), assets::locate_asset("Assets/shaders/ImmediateRenderer2D/sdf.frag"));

        struct position
        {
            float x, y;
        };

        struct texture_coordinate
        {
            float s, t;
        };

        constexpr std::array positions = {
            position{ -0.5f, -0.5f }, // bottom-left
            position{ -0.5f,  0.5f }, // top-left
            position{  0.5f,  0.5f }, // top-right
            position{  0.5f, -0.5f }  // bottom-right
        };

        constexpr std::array texture_coordinates = {
            texture_coordinate{ 0.0f, 0.0f }, // bottom-left
            texture_coordinate{ 0.0f, 1.0f }, // top-left
            texture_coordinate{ 1.0f, 1.0f }, // top-right
            texture_coordinate{ 1.0f, 0.0f }  // bottom-right
        };

        constexpr std::array<unsigned char, 6> indices = { 0, 3, 2, 0, 2, 1 };

        quad.positionBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ positions }));
        quad.texCoordBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ texture_coordinates }));
        quad.indexBufferHandle    = OpenGL::CreateBuffer(OpenGL::BufferType::Indices, std::as_bytes(std::span{ indices }));
        quad.indicesCount         = static_cast<GLsizei>(indices.size());
        const auto layout         = {
            OpenGL::VertexBuffer{ quad.positionBufferHandle, { OpenGL::Attribute::Float2 } },
            OpenGL::VertexBuffer{ quad.texCoordBufferHandle, { OpenGL::Attribute::Float2 } }
        };
        quad.modelHandle = OpenGL::CreateVertexArrayObject(layout, quad.indexBufferHandle);


        //- Create SDF vertex buffer (position-only attributes)

        sdfBufferHandle                 = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ positions }));
        const auto layout_position_only = {
            OpenGL::VertexBuffer{ quad.positionBufferHandle, { OpenGL::Attribute::Float2 } }
        };
        sdfVeretexArrayHandle = OpenGL::CreateVertexArrayObject(layout_position_only, quad.indexBufferHandle);
        //- Create uniform buffer for camera/view-projection matrix
       camera_uniform_buffer = OpenGL::CreateBuffer(OpenGL::BufferType::UniformBlocks, sizeof(camera_array));


        //- Bind uniform buffer to both shaders with name "Camera"
        //OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");
    }

    void ImmediateRenderer2D::Shutdown()
    {
        OpenGL::DestroyShader(texturingCombineShader);
        OpenGL::DestroyShader(sdfShader);

        GL::DeleteBuffers(1, &quad.positionBufferHandle), quad.positionBufferHandle = 0;
        GL::DeleteBuffers(1, &quad.texCoordBufferHandle), quad.texCoordBufferHandle = 0;
        GL::DeleteBuffers(1, &quad.indexBufferHandle), quad.indexBufferHandle       = 0;
        GL::DeleteBuffers(1, &sdfBufferHandle), sdfBufferHandle                     = 0;
        GL::DeleteBuffers(1, &camera_uniform_buffer), camera_uniform_buffer         = 0;

        GL::DeleteVertexArrays(1, &quad.modelHandle), quad.modelHandle           = 0;
        GL::DeleteVertexArrays(1, &sdfVeretexArrayHandle), sdfVeretexArrayHandle = 0;
    }

    void ImmediateRenderer2D::BeginScene([[maybe_unused]] const Math::TransformationMatrix& view_projection)
    {
        //- Store matrix for potential later use
        currentCameraMatrix = view_projection;

        //- Convert 3x3 matrix to 4x3 format for uniform buffer
        updateCameraUniformValues(currentCameraMatrix);

        //- Update uniform buffer with new matrix data
        OpenGL::UpdateBufferData(OpenGL::BufferType::UniformBlocks, camera_uniform_buffer, std::as_bytes(std::span{ camera_array }));

        //- Bind uniform buffer for use by shaders
        GL::BindBuffer(GL_UNIFORM_BUFFER, camera_uniform_buffer);

        OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");

        draw_call = 0;
		texture_call = 0;
    }

    void ImmediateRenderer2D::EndScene()
    {
		
    }

    void ImmediateRenderer2D::DrawQuad(
		[[maybe_unused]] const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth)
    {
        //- Bind texture to texture unit 0
        GL::UseProgram(texturingCombineShader.Shader);
        GL::ActiveTexture(GL_TEXTURE0);
        GL::BindTexture(GL_TEXTURE_2D, texture);

        // - Calculate texture coordinate transformation matrix - by bl and tr, and translate to opengl version !!
        std::array<float, 9> texture_transform = { static_cast<float>(texture_coord_tr.x - texture_coord_bl.x),
                                                   0.f,
                                                   0.f, // column1
                                                   0.f,
                                                   static_cast<float>(texture_coord_tr.y - texture_coord_bl.y),
                                                   0.f, // column2
                                                   static_cast<float>(texture_coord_bl.x),
                                                   static_cast<float>(texture_coord_bl.y),
                                                   1.f };

        //- Set shader uniforms: model matrix, depth, texture transform, tint color
        const auto& locations = texturingCombineShader.UniformLocations;
        GL::Uniform1i(locations.at("uTex2d"), 0);

        const auto world_transform_opengl = Renderer2DUtils::to_opengl_mat3(transform);
        // std::array<float,9> world_transform_opengl{ 128.f, 0.0f, 0.0f, 0.0f, 128.f, 0.0f, 0.0f,0.0f, 1.0f };
        GL::UniformMatrix3fv(locations.at("uModel"), 1, GL_FALSE, world_transform_opengl.data());

        GL::UniformMatrix3fv(locations.at("uTexCoordTransform"), 1, GL_FALSE, texture_transform.data());


        GL::Uniform1f(locations.at("uDepth"), depth);


        const auto colors = unpack_color(tintColor);
        GL::Uniform4f(locations.at("uTint"), colors[0], colors[1], colors[2], colors[3]);


        //- Draw using quad VAO and index buffer
        GL::BindVertexArray(quad.modelHandle);
        constexpr GLenum  primitive_pattern        = GL_TRIANGLES;
        constexpr GLenum  indices_type             = GL_UNSIGNED_BYTE;
        constexpr GLvoid* byte_offset_into_indices = nullptr;
        GL::DrawElements(primitive_pattern, quad.indicesCount, indices_type, byte_offset_into_indices);
		++draw_call;
		++texture_call;
        GL::BindTexture(GL_TEXTURE_2D, 0);
        GL::BindVertexArray(0);
        GL::UseProgram(0);
    }

    void ImmediateRenderer2D::DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawSDF(transform, fill_color, line_color, line_width, SDFShape::Circle, depth);
    }

    void ImmediateRenderer2D::DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawSDF(transform, fill_color, line_color, line_width, SDFShape::Rectangle, depth);
    }

    void ImmediateRenderer2D::DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth)
    {
        const auto line_transform = Renderer2DUtils::CalculateLineTransform(transform, start_point, end_point, line_width);
        DrawSDF(line_transform, line_color, line_color, line_width, SDFShape::Rectangle, depth);
    }

    void ImmediateRenderer2D::DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawLine(Math::TransformationMatrix{}, start_point, end_point, line_color, line_width, depth);
    }

    void ImmediateRenderer2D::updateCameraUniformValues(const Math::TransformationMatrix& view_projection)
    {
        const auto as_3x3 = Renderer2DUtils::to_opengl_mat3(view_projection);
        for (std::size_t col = 0; col < 3; ++col)
        {
            const std::size_t src_offset = col * 3;
            const std::size_t dst_offset = col * 4;

            camera_array[dst_offset + 0] = as_3x3[src_offset + 0]; // how?****
            camera_array[dst_offset + 1] = as_3x3[src_offset + 1];
            camera_array[dst_offset + 2] = as_3x3[src_offset + 2];
            camera_array[dst_offset + 3] = 0.0f;
        }
    }

    void ImmediateRenderer2D::DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape, float depth)
    {
        GL::UseProgram(sdfShader.Shader);
        // Calculate SDF-specific transform using Renderer2DUtils::CalculateSDFTransform()
        const auto  sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
        // Set all SDF shader uniforms (model, colors, size, line width, shape type)
        const auto& locations     = sdfShader.UniformLocations;

        // vertex
       //GL::UniformMatrix3fv(locations.at("uToNDC"), 1, GL_FALSE, CS200::Renderer2DUtils::to_opengl_mat3(CS200::build_ndc_matrix(Engine::GetWindow().GetSize())).data());
        GL::UniformMatrix3fv(locations.at("uModel"), 1, GL_FALSE, sdf_transform.QuadTransform.data());
        GL::Uniform2f(locations.at("uSDFScale"), sdf_transform.QuadSize[0], sdf_transform.QuadSize[1]);
        GL::Uniform1f(locations.at("uDepth"), depth);

        // fragment
        GL::Uniform4fv(locations.at("uFillColor"), 1, CS200::unpack_color(fill_color).data());
        GL::Uniform4fv(locations.at("uLineColor"), 1, CS200::unpack_color(line_color).data());
        GL::Uniform2fv(locations.at("uWorldSize"), 1, sdf_transform.WorldSize.data());
        GL::Uniform1f(locations.at("uLineWidth"), static_cast<float>(line_width));
        GL::Uniform1i(locations.at("uShape"), static_cast<int>(sdf_shape));

        // Use SDF vertex array and draw triangles
        GL::BindVertexArray(sdfVeretexArrayHandle);
        constexpr GLenum  primitive_pattern        = GL_TRIANGLES;
        constexpr GLenum  indices_type             = GL_UNSIGNED_BYTE;
        constexpr GLvoid* byte_offset_into_indices = nullptr;
        GL::DrawElements(primitive_pattern, quad.indicesCount, indices_type, byte_offset_into_indices);
		++draw_call;
		++texture_call;
        // Shape rendering handled entirely in fragment shader
        GL::BindVertexArray(0);
        GL::UseProgram(0);
	}

	size_t ImmediateRenderer2D::GetDrawCallCounter()
	{
		return draw_call;
	}

	size_t ImmediateRenderer2D::GetDrawTextureCounter()
	{
		return texture_call;
	}


    ImmediateRenderer2D::ImmediateRenderer2D(ImmediateRenderer2D&& other) noexcept
		: quad(other.quad),												   // 1.
		  texturingCombineShader(std::move(other.texturingCombineShader)), // 2.
		  camera_uniform_buffer(other.camera_uniform_buffer),			   // 3.
		  sdfBufferHandle(other.sdfBufferHandle),						   // 4.
		  sdfShader(std::move(other.sdfShader)),						   // 5.
		  sdfVeretexArrayHandle(other.sdfVeretexArrayHandle),			   // 6.
		  camera_array(other.camera_array),								   // 7.
		  currentCameraMatrix(other.currentCameraMatrix),				   // 8.
		  draw_call(other.draw_call),									   // 9.
		  texture_call(other.texture_call)								   // 10.
    {
		other.quad.positionBufferHandle = 0;
		other.quad.texCoordBufferHandle = 0;
		other.quad.indexBufferHandle	= 0;
		other.quad.indicesCount			= 0;
		other.quad.modelHandle			= 0;

		other.texturingCombineShader = {};
		other.camera_uniform_buffer	 = 0;
		other.sdfBufferHandle		 = 0;
		other.sdfShader				 = {};
		other.sdfVeretexArrayHandle	 = 0;

        other.draw_call	   = 0;
		other.texture_call = 0;
    }

    ImmediateRenderer2D& ImmediateRenderer2D::operator=(ImmediateRenderer2D&& other) noexcept
    {
        //- Use std::swap to exchange all resources
        //- Safely handles self-assignment

        if (this == &other)
		{
			return *this;
		}

		std::swap(quad, other.quad);
		std::swap(texturingCombineShader, other.texturingCombineShader);
		std::swap(camera_uniform_buffer, other.camera_uniform_buffer);
		std::swap(sdfBufferHandle, other.sdfBufferHandle);
		std::swap(sdfShader, other.sdfShader);
		std::swap(sdfVeretexArrayHandle, other.sdfVeretexArrayHandle);
		std::swap(camera_array, other.camera_array);
		std::swap(currentCameraMatrix, other.currentCameraMatrix);
		std::swap(draw_call, other.draw_call);
		std::swap(texture_call, other.texture_call);

		return *this;
    }

    ImmediateRenderer2D::~ImmediateRenderer2D()
    {
        Shutdown();
    }
}



================================================
FILE: source/CS200/ImmediateRenderer2D.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Matrix.h"
#include "IRenderer2D.h"
#include "OpenGL/Shader.h"
#include "OpenGL/VertexArray.h"
#include <array>

namespace CS200
{
	/**
	 * \brief Immediate-mode 2D renderer for drawing sprites, shapes, and lines
	 *
	 * ImmediateRenderer2D provides a simple, immediate-mode interface for 2D graphics rendering.
	 * "Immediate mode" means each draw call renders directly to the screen without batching or
	 * optimization - perfect for learning graphics programming and prototyping.
	 *
	 * Key Features:
	 * - Textured quad rendering with tint colors and texture coordinate mapping
	 * - SDF (Signed Distance Field) based shape rendering for perfect circles and rectangles
	 * - Line rendering with arbitrary thickness
	 * - Camera/view-projection matrix support for world-to-screen transformations
	 * - Hardware-accelerated OpenGL rendering with custom shaders
	 *
	 * Rendering Pipeline:
	 * 1. Init() - Set up OpenGL resources (shaders, buffers, vertex arrays)
	 * 2. BeginScene() - Set camera/view matrix for the frame
	 * 3. Draw*() calls - Render individual primitives immediately
	 * 4. EndScene() - Finalize the frame (currently no-op)
	 * 5. Shutdown() - Clean up OpenGL resources
	 *
	 * Technical Implementation:
	 * - Uses two rendering paths: textured quads and SDF shapes
	 * - Quad rendering: Standard texture mapping with transform and tint
	 * - SDF rendering: Fragment shader-based shapes with perfect edges and outlines
	 * - Uniform buffer for camera data shared between shaders
	 * - Immediate submission to GPU (no batching)
	 *
	 * Common Use Cases:
	 * - Sprite rendering for games (characters, backgrounds, UI)
	 * - Debug visualization (bounding boxes, collision shapes)
	 * - Simple 2D graphics applications
	 * - Educational graphics programming
	 *
	 * Example Usage:
	 * \code
	 * // Create and initialize renderer (typically done in Engine initialization)
	 * ImmediateRenderer2D renderer;
	 * renderer.Init();
	 *
	 * // In your game loop update/draw function:
	 *
	 * // Set up NDC camera matrix for screen-space rendering
	 * Math::ivec2 screen_size = {800, 600};  // Your window/viewport size
	 * auto ndc_matrix = CS200::build_ndc_matrix(screen_size);
	 * renderer.BeginScene(ndc_matrix);
	 *
	 * // Draw a textured sprite (position/rotation/scale transform)
	 * auto sprite_transform = Math::TranslationMatrix({100, 200}) *
	 *                        Math::RotationMatrix(45.0) *
	 *                        Math::ScaleMatrix({64, 64});
	 * renderer.DrawQuad(sprite_transform, texture_handle, {0,0}, {1,1}, CS200::WHITE);
	 *
	 * // Draw shapes with fills and outlines
	 * auto circle_transform = Math::TranslationMatrix({300, 300}) * Math::ScaleMatrix({50, 50});
	 * renderer.DrawCircle(circle_transform, CS200::WHITE, CS200::BLACK, 2.0);
	 *
	 * // Draw debug lines
	 * renderer.DrawLine({0, 0}, {100, 100}, CS200::WHITE, 1.0);
	 *
	 * renderer.EndScene();
	 *
	 * // Cleanup when shutting down
	 * renderer.Shutdown();
	 * \endcode
	 */
	class ImmediateRenderer2D : public IRenderer2D
	{
	public:
		/**
		 * \brief Default constructor - creates uninitialized renderer
		 *
		 * Implementation notes:
		 * - Initialize all handles/resources to invalid/zero values
		 * - Must call Init() before use
		 */
		ImmediateRenderer2D() = default;

		/**
		 * \brief Copy constructor deleted - renderer manages unique OpenGL resources
		 */
		ImmediateRenderer2D(const ImmediateRenderer2D& other) = delete;

		/**
		 * \brief Move constructor - transfer ownership of OpenGL resources
		 * \param other The renderer to move from
		 *
		 * Implementation notes:
		 * - Transfer all OpenGL handles (VAOs, buffers, shaders)
		 * - Set source object's handles to zero/invalid
		 * - Move shader objects using std::move()
		 * - Copy view projection matrix data
		 */
		ImmediateRenderer2D(ImmediateRenderer2D&& other) noexcept;

		/**
		 * \brief Copy assignment deleted - renderer manages unique OpenGL resources
		 */
		ImmediateRenderer2D& operator=(const ImmediateRenderer2D& other) = delete;

		/**
		 * \brief Move assignment - transfer ownership of OpenGL resources
		 * \param other The renderer to move from
		 * \return Reference to this object
		 *
		 * Implementation notes:
		 * - Use std::swap to exchange all resources
		 * - Safely handles self-assignment
		 * - Automatic cleanup of previous resources
		 */
		ImmediateRenderer2D& operator=(ImmediateRenderer2D&& other) noexcept;

		/**
		 * \brief Destructor - automatically cleans up OpenGL resources
		 *
		 * Implementation notes:
		 * - Call Shutdown() to clean up resources
		 * - Safe to call even if Init() was never called
		 */
		~ImmediateRenderer2D() override;

		/**
		 * \brief Initialize OpenGL resources for rendering
		 *
		 * Implementation notes:
		 * - Create index buffer with quad indices (0,1,2,2,3,0)
		 * - Create vertex buffer with quad vertices (-0.5 to 0.5 range)
		 * - Set up VAO with position and texture coordinate attributes
		 * - Create SDF vertex buffer (position-only attributes)
		 * - Load and compile vertex/fragment shaders from Assets/shaders/
		 * - Create uniform buffer for camera/view-projection matrix
		 * - Bind uniform buffer to both shaders with name "Camera"
		 */
		void Init() override;

		/**
		 * \brief Clean up all OpenGL resources
		 *
		 * Implementation notes:
		 * - Delete all vertex arrays, buffers using OpenGL delete functions
		 * - Destroy shader programs using OpenGL::DestroyShader()
		 * - Set all handles back to zero/invalid
		 * - Safe to call multiple times
		 */
		void Shutdown() override;

		/**
		 * \brief Begin a new frame with camera/view transformation
		 * \param view_projection Combined view and projection matrix for the frame
		 *
		 * Implementation notes:
		 * - Convert 3x3 matrix to 4x3 format for uniform buffer
		 * - Update uniform buffer with new matrix data
		 * - Bind uniform buffer for use by shaders
		 * - Store matrix for potential later use
		 */
		void BeginScene(const Math::TransformationMatrix& view_projection) override;

		/**
		 * \brief End the current frame (currently no operations needed)
		 *
		 * Implementation notes:
		 * - No cleanup or finalization needed for immediate mode
		 * - Could be used for debugging/profiling in future
		 */
		void EndScene() override;

		/**
		 * \brief Draw a textured quad with transformation and tinting
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param texture OpenGL texture handle to sample from
		 * \param texture_coord_bl Bottom-left texture coordinate (typically {0,0})
		 * \param texture_coord_tr Top-right texture coordinate (typically {1,1})
		 * \param tintColor Color to multiply with texture (RGBA::White for no tint)
		 *
		 * Implementation notes:
		 * - Calculate texture coordinate transformation matrix
		 * - Set shader uniforms: model matrix, depth, texture transform, tint color
		 * - Bind texture to texture unit 0
		 * - Draw using quad VAO and index buffer
		 * - Use GL_TRIANGLES with 6 indices (2 triangles)
		 */
		void
			DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth) override;

		/**
		 * \brief Draw a filled circle with optional outline using SDF rendering
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param fill_color Interior color of the circle
		 * \param line_color Outline color of the circle
		 * \param line_width Width of the outline in world units
		 *
		 * Implementation notes:
		 * - Use SDF (Signed Distance Field) shader for perfect circle
		 * - Call DrawSDF() with SDFShape::Circle
		 * - Radius determined by transform scale
		 */
		void DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a filled rectangle with optional outline using SDF rendering
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param fill_color Interior color of the rectangle
		 * \param line_color Outline color of the rectangle
		 * \param line_width Width of the outline in world units
		 *
		 * Implementation notes:
		 * - Use SDF (Signed Distance Field) shader for perfect rectangle
		 * - Call DrawSDF() with SDFShape::Rectangle
		 * - Size determined by transform scale
		 */
		void DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a line segment with specified thickness
		 * \param transform Additional transformation to apply to the line
		 * \param start_point Starting point of the line in local coordinates
		 * \param end_point Ending point of the line in local coordinates
		 * \param line_color Color of the line
		 * \param line_width Thickness of the line in world units
		 *
		 * Implementation notes:
		 * - Calculate line transformation using Renderer2DUtils::CalculateLineTransform()
		 * - Draw as a rotated/scaled rectangle using SDF rendering
		 * - Both fill and line colors set to same value
		 */
		void DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a line segment with specified thickness (identity transform)
		 * \param start_point Starting point of the line in world coordinates
		 * \param end_point Ending point of the line in world coordinates
		 * \param line_color Color of the line
		 * \param line_width Thickness of the line in world units
		 *
		 * Implementation notes:
		 * - Convenience overload that calls other DrawLine() with identity matrix
		 * - Useful for simple line drawing without additional transformations
		 */
		void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;


	private:

		struct object
		{
			OpenGL::BufferHandle	  positionBufferHandle{};
			OpenGL::BufferHandle	  texCoordBufferHandle{};
			OpenGL::BufferHandle	  indexBufferHandle{};
			GLsizei					  indicesCount{};
			OpenGL::VertexArrayHandle modelHandle{};
		} quad{};

		OpenGL::CompiledShader texturingCombineShader{};
		OpenGL::BufferHandle   camera_uniform_buffer{};

		// sdf
		OpenGL::BufferHandle	  sdfBufferHandle{};
		OpenGL::CompiledShader	  sdfShader{};
		OpenGL::VertexArrayHandle sdfVeretexArrayHandle{};

		std::array<float, 12> camera_array{};

		/**
		 * \brief Helper function for converting 3x3 matrix to 4x3 format for uniform buffer
		 * \param view_projection Combined view and projection matrix for the frame
		 *
		 */
		void updateCameraUniformValues(const Math::TransformationMatrix& view_projection);

		Math::TransformationMatrix currentCameraMatrix{};

		// SDF Shape identifiers - must be kept in sync with sdf.frag shader
		enum class SDFShape : uint8_t
		{
			Circle	  = 0,
			Rectangle = 1,
		};

		/**
		 * \brief Internal SDF rendering function used by shape drawing methods
		 * \param transform World transformation matrix
		 * \param fill_color Interior color of the shape
		 * \param line_color Outline color of the shape
		 * \param line_width Width of the outline in world units
		 * \param sdf_shape Type of SDF shape to render
		 *
		 * Implementation notes:
		 * - Calculate SDF-specific transform using Renderer2DUtils::CalculateSDFTransform()
		 * - Set all SDF shader uniforms (model, colors, size, line width, shape type)
		 * - Use SDF vertex array and draw triangles
		 * - Shape rendering handled entirely in fragment shader
		 */
		void DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape, float depth);

		size_t draw_call = 0;
		size_t GetDrawCallCounter() override;

		size_t texture_call = 0;
		size_t GetDrawTextureCounter() override;
	};
}



================================================
FILE: source/CS200/InstancedRenderer2D.cpp
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "InstancedRenderer2D.h"

#include "Engine/Path.h"

#include "OpenGL/Buffer.h"
#include "OpenGL/GL.h"
#include "OpenGL/VertexArray.h"
#include "Renderer2DUtils.h"

#include <fstream>
#include <numeric>
#include <sstream>

namespace CS200

{

	InstancedRenderer2D::InstancedRenderer2D([[maybe_unused]] unsigned max_sprites)
	{
		maxInstances	= max_sprites;
		maxSDFInstances = max_sprites;
		instanceData.reserve(maxInstances);
		sdfInstanceData.reserve(maxSDFInstances);
	}

	InstancedRenderer2D::InstancedRenderer2D(InstancedRenderer2D&& other) noexcept
		: instanceData(std::move(other.instanceData)),
          texturingCombineShader(std::move(other.texturingCombineShader)),
          fixedVertexBufferHandle(other.fixedVertexBufferHandle),
          instanceBufferHandle(other.instanceBufferHandle),
          modelHandle(other.modelHandle),
          sdfFixedVertexBufferHandle(other.sdfFixedVertexBufferHandle),
          sdfInstanceBufferHandle(other.sdfInstanceBufferHandle),
          sdfInstanceData(std::move(other.sdfInstanceData)),
          sdfShader(std::move(other.sdfShader)),
          sdfModelHandle(other.sdfModelHandle),
          maxSDFInstances(other.maxSDFInstances),
          indexBufferHandle(other.indexBufferHandle),
          camera_uniform_buffer(other.camera_uniform_buffer),
          camera_array(other.camera_array),
          currentCameraMatrix(other.currentCameraMatrix),
          maxInstances(other.maxInstances),
          textureSlots(std::move(other.textureSlots)),
          activeTextureSize(other.activeTextureSize),
          draw_call(other.draw_call),
          texture_call(other.texture_call)
	{
		other.fixedVertexBufferHandle	 = 0;
		other.instanceBufferHandle		 = 0;
		other.modelHandle				 = 0;
		other.sdfFixedVertexBufferHandle = 0;
		other.sdfInstanceBufferHandle	 = 0;
		other.sdfModelHandle			 = 0;
		other.indexBufferHandle			 = 0;
		other.camera_uniform_buffer		 = 0;

		other.texturingCombineShader = {};
		other.sdfShader				 = {};

		other.maxInstances		= 0;
		other.maxSDFInstances	= 0;
		other.activeTextureSize = 0;
		other.draw_call			= 0;
		other.texture_call		= 0;
	}

	InstancedRenderer2D& InstancedRenderer2D::operator=(InstancedRenderer2D&& other) noexcept
	{
		std::swap(instanceData, other.instanceData);
		std::swap(texturingCombineShader, other.texturingCombineShader);
		std::swap(fixedVertexBufferHandle, other.fixedVertexBufferHandle);
		std::swap(instanceBufferHandle, other.instanceBufferHandle);
		std::swap(modelHandle, other.modelHandle);

		std::swap(sdfInstanceData, other.sdfInstanceData);
		std::swap(sdfFixedVertexBufferHandle, other.sdfFixedVertexBufferHandle);
		std::swap(sdfInstanceBufferHandle, other.sdfInstanceBufferHandle);
		std::swap(sdfShader, other.sdfShader);
		std::swap(sdfModelHandle, other.sdfModelHandle);
		std::swap(maxSDFInstances, other.maxSDFInstances);

		std::swap(indexBufferHandle, other.indexBufferHandle);
		std::swap(camera_uniform_buffer, other.camera_uniform_buffer);
		std::swap(camera_array, other.camera_array);
		std::swap(currentCameraMatrix, other.currentCameraMatrix);
		std::swap(maxInstances, other.maxInstances);
		std::swap(textureSlots, other.textureSlots);
		std::swap(activeTextureSize, other.activeTextureSize);
		std::swap(draw_call, other.draw_call);
		std::swap(texture_call, other.texture_call);

		return *this;
	}

	InstancedRenderer2D::~InstancedRenderer2D()
	{
		Shutdown();
	}

	void InstancedRenderer2D::Init()

	{
		// get max texture units
		// get glsl code and update the fragment shader
		// create the shader
		// set th binding values for textures array

		// get how many texture opengl can draw
		GLint max_tex_units = 0;
		GL::GetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &max_tex_units); // check with docs.gl to get minimum(16) and maximum
		textureSlots.resize(static_cast<size_t>(std::min(max_tex_units, 64)));


		// load shaders with parsing
		const std::filesystem::path vertex_file = assets::locate_asset("Assets/shaders/InstancedRenderer2D/quad.vert");
		std::ifstream				vert_stream(vertex_file);
		std::stringstream			vert_text_stream;
		vert_text_stream << vert_stream.rdbuf();
		const std::string vertex_glsl = vert_text_stream.str();

		const std::filesystem::path fragment_file = assets::locate_asset("Assets/shaders/InstancedRenderer2D/quad.frag");
		std::ifstream				frag_stream(fragment_file);
		std::stringstream			frag_text_stream;
		frag_text_stream << frag_stream.rdbuf();
		std::string frag_glsl = frag_text_stream.str();

		const size_t	  first_newline = frag_glsl.find('\n');
		const std::string define_line	= "\n#define MAX_TEXTURE_SLOTS " + std::to_string(textureSlots.size());
		frag_glsl.insert(first_newline, define_line);

		texturingCombineShader = OpenGL::CreateShader(std::string_view{ vertex_glsl }, std::string_view{ frag_glsl });

		// have to set their binding index
		GL::UseProgram(texturingCombineShader.Shader);

		std::vector<int> sampler_binding_values(textureSlots.size());
		std::iota(sampler_binding_values.begin(), sampler_binding_values.end(), 0);
		const GLint location = GL::GetUniformLocation(texturingCombineShader.Shader, "uTextures");
		GL::Uniform1iv(location, static_cast<GLsizei>(textureSlots.size()), sampler_binding_values.data());

		GL::UseProgram(0);

		// create our fixed buffer data
		// create index buffer data
		// create our instanced buffer
		// create VAO

		constexpr float fixed_sprite_vertices[][4] = {
			// bottom left
			{ -0.5f, -0.5f, 0.0f, 0.0f },
			// bottom right
			{  0.5f, -0.5f, 1.0f, 0.0f },
			// top right
			{  0.5f,	0.5f, 1.0f, 1.0f },
			// top left
			{ -0.5f,	 0.5f, 0.0f, 1.0f }
		};

		constexpr unsigned char indicies[] = { 0, 1, 2, 0, 2, 3 };

		fixedVertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ fixed_sprite_vertices }));
		indexBufferHandle		= OpenGL::CreateBuffer(OpenGL::BufferType::Indices, std::as_bytes(std::span{ indicies }));
		instanceBufferHandle	= OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(QuadInstance) * maxInstances));

		auto fixedbuffer_and_instancebuffer = {
			OpenGL::VertexBuffer{ fixedVertexBufferHandle,{ OpenGL::Attribute::Float2, OpenGL::Attribute::Float2 }					},
			OpenGL::VertexBuffer{	  instanceBufferHandle,
								  { OpenGL::Attribute::Float3.WithDivisor(1), OpenGL::Attribute::Float3.WithDivisor(1), OpenGL::Attribute::UByte4ToNormalized.WithDivisor(1),
									OpenGL::Attribute::Float2.WithDivisor(1), OpenGL::Attribute::Float2.WithDivisor(1), OpenGL::Attribute::Int.WithDivisor(1),
									OpenGL::Attribute::Float.WithDivisor(1) } }
		};

		modelHandle = OpenGL::CreateVertexArrayObject(fixedbuffer_and_instancebuffer, indexBufferHandle);

		// SDF
		//  create vertex array object, buffer vertices, buffer indices
		sdfShader = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/InstancedRenderer2D/sdf.vert"), assets::locate_asset("Assets/shaders/InstancedRenderer2D/sdf.frag"));

		constexpr float position_vertices[][2] = {
			// bottom left
			{ -0.5f, -0.5f },
			// bottom right
			{  0.5f, -0.5f },
			// top right
			{  0.5f,	0.5f },
			// top left
			{ -0.5f,	 0.5f }
		};
		sdfFixedVertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ position_vertices }));
		sdfInstanceBufferHandle	   = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(SDFInstance) * maxInstances));

		const auto sdf_fix_instance = {
			OpenGL::VertexBuffer{ sdfFixedVertexBufferHandle,{ OpenGL::Attribute::Float2 }	}, //  Layout 0: aModelPosition														},
			OpenGL::VertexBuffer{	  sdfInstanceBufferHandle,
								  {
								  OpenGL::Attribute::Float3.WithDivisor(1),				// Layout 1: aModelRow0
								  OpenGL::Attribute::Float3.WithDivisor(1),				// Layout 2: aModelRow1
								  OpenGL::Attribute::UByte4ToNormalized.WithDivisor(1), // Layout 3: aFillColor
								  OpenGL::Attribute::UByte4ToNormalized.WithDivisor(1), // Layout 4: aLineColor
								  OpenGL::Attribute::Float2.WithDivisor(1),				// Layout 5: aWorldSize
								  OpenGL::Attribute::Float.WithDivisor(1),				// Layout 6: aLineWidth
								  OpenGL::Attribute::Int.WithDivisor(1),				// Layout 7: aShape (0=Circle, 1=Rect)
								  OpenGL::Attribute::Float.WithDivisor(1),				// Layout 8: aDepth
								  } }
		};
		sdfModelHandle = OpenGL::CreateVertexArrayObject(sdf_fix_instance, indexBufferHandle);

		camera_uniform_buffer = OpenGL::CreateBuffer(OpenGL::BufferType::UniformBlocks, sizeof(camera_array));
		OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");
		OpenGL::BindUniformBufferToShader(sdfShader.Shader, 0, camera_uniform_buffer, "NDC");
	}

	void InstancedRenderer2D::Shutdown()

	{
		OpenGL::DestroyShader(texturingCombineShader);
		OpenGL::DestroyShader(sdfShader);

		GL::DeleteBuffers(1, &fixedVertexBufferHandle), fixedVertexBufferHandle		  = 0;
		GL::DeleteBuffers(1, &instanceBufferHandle), instanceBufferHandle			  = 0;
		GL::DeleteBuffers(1, &sdfFixedVertexBufferHandle), sdfFixedVertexBufferHandle = 0;
		GL::DeleteBuffers(1, &sdfInstanceBufferHandle), sdfInstanceBufferHandle		  = 0;
		GL::DeleteBuffers(1, &indexBufferHandle), indexBufferHandle					  = 0;
		GL::DeleteBuffers(1, &camera_uniform_buffer), camera_uniform_buffer			  = 0;

		GL::DeleteVertexArrays(1, &modelHandle), modelHandle	   = 0;
		GL::DeleteVertexArrays(1, &sdfModelHandle), sdfModelHandle = 0;

		instanceData.clear();
		sdfInstanceData.clear();
		textureSlots.clear();

		activeTextureSize = 0;
		draw_call		  = 0;
		texture_call	  = 0;
	}

	void InstancedRenderer2D::BeginScene(const Math::TransformationMatrix& view_projection)
	{
		//- Store matrix for potential later use
		currentCameraMatrix = view_projection;

		//- Convert 3x3 matrix to 4x3 format for uniform buffer
		updateCameraUniformValues(currentCameraMatrix);


		//- Update uniform buffer with new matrix data
		OpenGL::UpdateBufferData(OpenGL::BufferType::UniformBlocks, camera_uniform_buffer, std::as_bytes(std::span{ camera_array }));

		//- Bind uniform buffer for use by shaders
		GL::BindBuffer(GL_UNIFORM_BUFFER, camera_uniform_buffer);

		draw_call	 = 0;
		texture_call = 0;
		startBatch();
	}

	void InstancedRenderer2D::EndScene()
	{
		flush();
	}

	void InstancedRenderer2D::DrawQuad(
		const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth)
	{
		if (instanceData.size() >= maxInstances)
		{
			flush();
		}

		if (sdfInstanceData.size() >= maxSDFInstances)
		{
			flush();
		}
		int tex_index = 0;
		bool found = false;

		for (size_t i = 0; i < activeTextureSize; ++i)
		{
			if (textureSlots[i] == texture)
			{
				found = true;
				tex_index = static_cast<int>(i);
			}
		}


		if (!found)
		{
			if (activeTextureSize >= textureSlots.size())
			{
				flush();
			}
			tex_index = static_cast<int>(activeTextureSize);
			textureSlots[activeTextureSize] = texture;
			++activeTextureSize;
		}


		const float left = static_cast<float>(texture_coord_bl.x);
		const float bottom = static_cast<float>(texture_coord_bl.y);
		const float right = static_cast<float>(texture_coord_tr.x);
		const float top = static_cast<float>(texture_coord_tr.y);

		QuadInstance instance;
		instance.textureIndex = tex_index;
		instance.texScale[0] = right - left;
		instance.texScale[1] = top - bottom;
		instance.texOffset[0] = left;
		instance.texOffset[1] = bottom;
		instance.transformrow0[0] = static_cast<float>(transform[0][0]);
		instance.transformrow0[1] = static_cast<float>(transform[0][1]);
		instance.transformrow0[2] = static_cast<float>(transform[0][2]);
		instance.transformrow1[0] = static_cast<float>(transform[1][0]);
		instance.transformrow1[1] = static_cast<float>(transform[1][1]);
		instance.transformrow1[2] = static_cast<float>(transform[1][2]);
		instance.tint = ColorArray(tintColor);
		instance.depth			  = depth;

		instanceData.push_back(instance);

		++texture_call;
	}

	void InstancedRenderer2D::startBatch()

	{
		instanceData.clear();

		activeTextureSize = 0;


		sdfInstanceData.clear();
	}

	void InstancedRenderer2D::flush()
	{
		if (!instanceData.empty()) [[unlikely]]
		{
			GL::BindBuffer(GL_ARRAY_BUFFER, instanceBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(QuadInstance) * maxInstances), nullptr, GL_DYNAMIC_DRAW);
			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, instanceBufferHandle, std::as_bytes(std::span{ instanceData.data(), instanceData.size() }));

			// select our texture
			for (size_t i = 0; i < activeTextureSize; ++i)
			{
				GL::ActiveTexture(static_cast<GLenum>(GL_TEXTURE0 + i));
				GL::BindTexture(GL_TEXTURE_2D, textureSlots[i]);
			}
			GL::UseProgram(texturingCombineShader.Shader);
			GL::BindVertexArray(modelHandle);
			GL::DrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, nullptr, static_cast<GLsizei>(instanceData.size()));
			++draw_call;
		}

		if (!sdfInstanceData.empty())
		{
			GL::BindBuffer(GL_ARRAY_BUFFER, sdfInstanceBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(SDFInstance) * maxSDFInstances), nullptr, GL_DYNAMIC_DRAW);

			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, sdfInstanceBufferHandle, std::as_bytes(std::span{ sdfInstanceData.data(), sdfInstanceData.size() }));

			GL::UseProgram(sdfShader.Shader);
			GL::BindVertexArray(sdfModelHandle);
			GL::DrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, nullptr, static_cast<GLsizei>(sdfInstanceData.size()));
			++draw_call;
		}
		GL::BindVertexArray(0);
		GL::UseProgram(0);
		GL::BindTexture(GL_TEXTURE_2D, 0);
		GL::BindBuffer(GL_ARRAY_BUFFER, 0);

		startBatch();
	}

	void InstancedRenderer2D::DrawCircle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (instanceData.size() >= maxInstances)
		{
			flush();
		}

		if (sdfInstanceData.size() >= maxSDFInstances)
		{
			flush();
		}

		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		SDFInstance sdf_instance;

		sdf_instance.transformrow0[0] = sdf_transform.QuadTransform[0];
		sdf_instance.transformrow0[1] = sdf_transform.QuadTransform[3];
		sdf_instance.transformrow0[2] = sdf_transform.QuadTransform[6];

		sdf_instance.transformrow1[0] = sdf_transform.QuadTransform[1];		
		sdf_instance.transformrow1[1] = sdf_transform.QuadTransform[4];
		sdf_instance.transformrow1[2] = sdf_transform.QuadTransform[7];

		sdf_instance.fillColor	 = fill_bytes;
		sdf_instance.lineColor	 = line_bytes;
		sdf_instance.worldSize_x = static_cast<float>(sdf_transform.WorldSize[0]);
		sdf_instance.worldSize_y = static_cast<float>(sdf_transform.WorldSize[1]);
		sdf_instance.lineWidth	 = static_cast<float>(line_width);
		sdf_instance.shape		 = static_cast<int>(SDFShape::Circle); // 0
		sdf_instance.depth		 = depth;

		sdfInstanceData.push_back(sdf_instance);

		++texture_call;
	}

	void InstancedRenderer2D::DrawRectangle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (instanceData.size() >= maxInstances)
		{
			flush();
		}

		if (sdfInstanceData.size() >= maxSDFInstances)
		{
			flush();
		}

		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		SDFInstance sdf_instance;

		sdf_instance.transformrow0[0] = sdf_transform.QuadTransform[0];
		sdf_instance.transformrow0[1] = sdf_transform.QuadTransform[3];
		sdf_instance.transformrow0[2] = sdf_transform.QuadTransform[6];

		sdf_instance.transformrow1[0] = sdf_transform.QuadTransform[1];
		sdf_instance.transformrow1[1] = sdf_transform.QuadTransform[4];
		sdf_instance.transformrow1[2] = sdf_transform.QuadTransform[7];

		sdf_instance.fillColor	 = fill_bytes;
		sdf_instance.lineColor	 = line_bytes;
		sdf_instance.worldSize_x = static_cast<float>(sdf_transform.WorldSize[0]);
		sdf_instance.worldSize_y = static_cast<float>(sdf_transform.WorldSize[1]);
		sdf_instance.lineWidth	 = static_cast<float>(line_width);
		sdf_instance.shape		 = static_cast<int>(SDFShape::Rectangle); // 1
		sdf_instance.depth		 = depth;

		sdfInstanceData.push_back(sdf_instance);

		++texture_call;
	}

	void InstancedRenderer2D::DrawLine(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color,
		[[maybe_unused]] double line_width, float depth)
	{
		const auto line_transform = Renderer2DUtils::CalculateLineTransform(transform, start_point, end_point, line_width);
		DrawRectangle(line_transform, line_color, line_color, line_width, depth);
	}

	void InstancedRenderer2D::DrawLine(
		[[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		DrawLine(Math::TransformationMatrix{}, start_point, end_point, line_color, line_width, depth);
	}

	void InstancedRenderer2D::updateCameraUniformValues(const Math::TransformationMatrix& view_projection)
	{
		const auto as_3x3 = Renderer2DUtils::to_opengl_mat3(view_projection);
		for (std::size_t col = 0; col < 3; ++col)
		{
			const std::size_t src_offset = col * 3;
			const std::size_t dst_offset = col * 4;


			camera_array[dst_offset + 0] = as_3x3[src_offset + 0]; // how?****
			camera_array[dst_offset + 1] = as_3x3[src_offset + 1];
			camera_array[dst_offset + 2] = as_3x3[src_offset + 2];
			camera_array[dst_offset + 3] = 0.0f;
		}
	}

	size_t InstancedRenderer2D::GetDrawCallCounter()
	{
		return draw_call;
	}

	size_t InstancedRenderer2D::GetDrawTextureCounter()
	{
		return texture_call;
	}
}


================================================
FILE: source/CS200/InstancedRenderer2D.h
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once

#include "IRenderer2D.h"

#include "Engine/Matrix.h"

#include "OpenGL/Shader.h"
#include "OpenGL/VertexArray.h"
#include <array>
#include <vector>

/**
 one model,
 lots of instances
 sharing buffer static -> positions(because we use single quad!!)
and each instance has their own dynamic buffer

 ->color
 ->texture
 ->model xform
 ->texcoords xform
 */


namespace CS200
{
	class InstancedRenderer2D : public IRenderer2D
	{
	public:
		InstancedRenderer2D(unsigned max_sprites = 10'000); // means max_instances
		InstancedRenderer2D(const InstancedRenderer2D& other) = delete;
		InstancedRenderer2D(InstancedRenderer2D&& other) noexcept;
		InstancedRenderer2D& operator=(const InstancedRenderer2D& other) = delete;
		InstancedRenderer2D& operator=(InstancedRenderer2D&& other) noexcept;
		~InstancedRenderer2D() override;

		void Init() override;
		void Shutdown() override;
		void BeginScene(const Math::TransformationMatrix& view_projection) override;
		void EndScene() override;
		void
			DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth) override;
		// void DrawQuad(std::span<const float, 9> transform, OpenGL::Handle texture, std::span<const float, 4> texture_coords_lbrt, std::span<const float, 4> tint_color) override;

		void DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;

	private:
		struct QuadInstance // maybe we can make more compact? bit width, ...
		{
			/*float x = 0, y = 0;*/							 // don't need for each instance anymore!!
			float						 transformrow0[3]{}; // instead having vertex for each instance, we have transform mat for each instance!
			float						 transformrow1[3]{};
			std::array<unsigned char, 4> tint{};		// caution !!! to use createvao helper func, make order same as in shader's attrib!!!!!
			/*float s = 0, t = 0;*/						// don't need for each instance anymore!!
			float						 texScale[2]{}; // instead having texcoord for each instance, we have transform mat of texcoord for each instance with compacted version
			float						 texOffset[2]{};
			int							 textureIndex = 0;
			float						 depth		  = 0.f;
		};

		std::vector<QuadInstance> instanceData{};
		OpenGL::CompiledShader	  texturingCombineShader;
		OpenGL::BufferHandle	  fixedVertexBufferHandle{};
		OpenGL::BufferHandle	  instanceBufferHandle{};
		OpenGL::VertexArrayHandle modelHandle{};

		// sdf
		struct SDFInstance
		{
			// float						 x = 0, y = 0;
			float						 transformrow0[3]{};			   // Layout 1: aModelRow0
			float						 transformrow1[3]{};			   // Layout 2: aModelRow1
			std::array<unsigned char, 4> fillColor{};					   // Layout 3: aFillColor
			std::array<unsigned char, 4> lineColor{};					   // Layout 4: aLineColor
			float						 worldSize_x = 0, worldSize_y = 0; // Layout 5: aWorldSize
			float						 lineWidth = 0;					   // Layout 6: aLineWidth
			int							 shape	   = 0;					   // Layout 7: aShape (0=Circle, 1=Rect)
			float						 depth	   = 0.f;					   // Layout 8: aDepth
		};

		OpenGL::BufferHandle	  sdfFixedVertexBufferHandle{};
		OpenGL::BufferHandle	  sdfInstanceBufferHandle{};
		std::vector<SDFInstance>  sdfInstanceData{};
		OpenGL::CompiledShader	  sdfShader{};
		OpenGL::VertexArrayHandle sdfModelHandle{};

		unsigned maxSDFInstances = 0;

		OpenGL::BufferHandle indexBufferHandle{};

		enum class SDFShape : uint8_t
		{
			Circle	  = 0,
			Rectangle = 1,
		};


		// ndc block

		OpenGL::BufferHandle camera_uniform_buffer{};

		std::array<float, 12> camera_array{};

		Math::TransformationMatrix currentCameraMatrix{};


		unsigned maxInstances = 0;


		std::vector<OpenGL::TextureHandle> textureSlots;

		size_t activeTextureSize = 0;


	private:

		void updateCameraUniformValues(const Math::TransformationMatrix& view_projection);

		void flush(); // when quad amount is reached to max_quad

		void startBatch();

		size_t draw_call;
		size_t GetDrawCallCounter() override;

		size_t texture_call = 0;
		size_t GetDrawTextureCounter() override;
	};

}



================================================
FILE: source/CS200/IRenderer2D.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Vec2.h"
#include "OpenGL/Texture.h"
#include "RGBA.h"

namespace Math
{
    class TransformationMatrix;
}

namespace CS200
{
    class IRenderer2D
    {
    public:
        
        virtual ~IRenderer2D() = default;

        virtual void Init() = 0;        
        virtual void Shutdown() = 0;
        virtual void BeginScene(const Math::TransformationMatrix& view_projection) = 0;
        virtual void EndScene() = 0;

        virtual void DrawQuad(
            const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl = Math::vec2{ 0.0, 0.0 }, Math::vec2 texture_coord_tr = Math::vec2{ 1.0, 1.0 },
            CS200::RGBA tintColor = CS200::WHITE, float depth = 1.f) = 0;
        virtual void
			DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color = CS200::CLEAR, CS200::RGBA line_color = CS200::WHITE, double line_width = 2.0, float depth = 0.f) = 0;
        virtual void
			DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color = CS200::CLEAR, CS200::RGBA line_color = CS200::WHITE, double line_width = 2.0, float depth = 0.f) = 0;
        virtual void
			DrawLine(const Math::TransformationMatrix& transform, Math::vec2 startPoint, Math::vec2 endPoint, CS200::RGBA line_color = CS200::WHITE, double line_width = 2.0, float depth = 0.f) = 0;
        virtual void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color = CS200::WHITE, double line_width = 2.0, float depth = 0.f) = 0;

        virtual size_t GetDrawCallCounter() = 0;
        virtual size_t GetDrawTextureCounter() = 0;
    };

}



================================================
FILE: source/CS200/NDC.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include "Engine/Matrix.h"
#include "Engine/Vec2.h"

namespace CS200
{
    /**
     * \brief Create a transformation matrix that converts screen coordinates to NDC
     * \param view_size Width and height of the viewport/screen in pixels
     * \return Transformation matrix for screen-to-NDC conversion
     *
     * \note The returned matrix transforms FROM screen coordinates TO NDC coordinates
     * \note This is typically used once per frame in BeginScene()
     * \note Screen coordinates assume (0,0) at bottom-left, (width,height) at top-right
     *
     * NDC (Normalized Device Coordinates) is a standard coordinate system used by graphics
     * APIs where all visible coordinates range from -1 to +1 in both X and Y axes.
     * This system is hardware-standard and allows graphics pipelines to work consistently
     * across different screen resolutions and aspect ratios.
     *
     * Purpose and Benefits:
     * - Provides resolution-independent coordinate system for rendering
     * - Standardizes coordinate space for graphics hardware (GPUs expect NDC)
     * - Enables consistent camera/viewport transformations
     * - Simplifies clipping and culling operations in graphics pipeline
     * - Makes shaders and rendering code portable across different screen sizes
     *
     * Coordinate System Mapping:
     * \code
     * We want to map (0, w) to (-1,1) and (0,h) to (-1,1)
     *             (w,h)                  (1,1)
     *      +--------+             +--------+
     *      |        |             |        |
     *      | cam    |     --->    | ndc    |
     *      +--------+             +--------+
     *    (0,0)                 (-1,-1)
     * \endcode
     *
     * Mathematical Transformation:
     * 1. Scale: Divide by half-dimensions to get 0-2 range
     * 2. Translate: Subtract 1 to center around origin (-1 to +1)
     * 3. Formula: ndc = (screen_coord / (dimension/2)) - 1
     *
     * Common Use Cases:
     * - Camera/view matrix setup for 2D rendering
     * - Converting mouse coordinates to world coordinates
     * - Setting up orthographic projections
     * - Viewport-independent UI positioning
     * - Cross-platform graphics coordinate normalization
     *
     * Integration with Graphics Pipeline:
     * Window Coordinates -> World Coordinates -> NDC -> GPU Rendering
     */
    inline Math::TransformationMatrix build_ndc_matrix(Math::ivec2 view_size, [[maybe_unused]] bool is_centered = false) noexcept
    {
        if(is_centered)
        {
            return Math::ScaleMatrix({ 2.0 / view_size.x, 2.0 / view_size.y });
        }
        return Math::TranslationMatrix(Math::vec2{ -1.0, -1.0 }) * Math::ScaleMatrix({ 2.0 / view_size.x, 2.0 / view_size.y });
    }
}



================================================
FILE: source/CS200/OffscreenFramebuffer.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


#include "OffscreenFramebuffer.h"
#include "OpenGL/GL.h"
#include <algorithm>
#include <iostream>

namespace
{
    int ValidateMSAASamples(int samples)
    {
        GLint max_samples = 0;
        GL::GetIntegerv(GL_MAX_SAMPLES, &max_samples);

        samples = std::max(2, std::min(samples, max_samples));

        samples = samples & ~1;

        return samples;
    }
}

OffscreenFramebuffer::~OffscreenFramebuffer()
{
    Shutdown();
}

void OffscreenFramebuffer::Initialize(int width, int height, [[maybe_unused]] MSAA use_msaa, [[maybe_unused]] int msaa_samples)
{
    currentWidth  = width;
    currentHeight = height;

    useMSAA       = (use_msaa == MSAA::True);
    msaaSamples   = ValidateMSAASamples(msaa_samples);

    createResolveFramebuffer();
    createMSAAFramebuffer();
}

void OffscreenFramebuffer::BindForRendering()
{

    GLuint target = useMSAA ? msaaFramebuffer : resolveFramebuffer;
    // GLuint target = resolveFramebuffer;
    GL::BindFramebuffer(GL_FRAMEBUFFER, target);
}

OpenGL::TextureHandle OffscreenFramebuffer::GetTexture()
{
    resolveMSAA();
    return resolveTexture;
}

void OffscreenFramebuffer::Resize(int width, int height)
{
    currentWidth  = width;
    currentHeight = height;

    createResolveFramebuffer();
    createMSAAFramebuffer();
}

void OffscreenFramebuffer::SetMSAA([[maybe_unused]] MSAA use_msaa, [[maybe_unused]] int msaa_samples)
{
    useMSAA     = use_msaa == MSAA::False ? false : true;
    msaaSamples = ValidateMSAASamples(msaa_samples);

    if (currentWidth > 0 && currentHeight > 0)
    {
        createMSAAFramebuffer();
    }
}

void OffscreenFramebuffer::Shutdown()
{
    if (resolveFramebuffer != 0)
    {
        GL::DeleteFramebuffers(1, &resolveFramebuffer);resolveFramebuffer = 0;
    }
    if (resolveTexture != 0)
    {
        GL::DeleteTextures(1, &resolveTexture);resolveTexture = 0;
    }

    if (msaaFramebuffer != 0)
    {
        GL::DeleteFramebuffers(1, &msaaFramebuffer);msaaFramebuffer = 0;
    }
    if (msaaColorRenderbuffer != 0)
    {
        GL::DeleteRenderbuffers(1, &msaaColorRenderbuffer);msaaColorRenderbuffer = 0;
    }

    if (depthRenderbuffer != 0)
    {
        GL::DeleteRenderbuffers(1, &depthRenderbuffer);
        depthRenderbuffer = 0;
    }
}

void OffscreenFramebuffer::createResolveFramebuffer()
{
    if (resolveFramebuffer == 0)
    {
        GL::GenFramebuffers(1, &resolveFramebuffer);
    }

    if (resolveTexture != 0)
    {
        GL::DeleteTextures(1, &resolveTexture);
        resolveTexture = 0;
    }

    GL::GenTextures(1, &resolveTexture);
    GL::BindTexture(GL_TEXTURE_2D, resolveTexture);
    GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

#ifdef IS_WEBGL2
    GL::TexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, currentWidth, currentHeight);
#else
    GL::TexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, currentWidth, currentHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
#endif
    GL::BindTexture(GL_TEXTURE_2D, 0);
    GL::BindFramebuffer(GL_FRAMEBUFFER, resolveFramebuffer);
    GL::FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, resolveTexture, 0);

    if (!useMSAA) 
    {
        if (depthRenderbuffer != 0) { GL::DeleteRenderbuffers(1, &depthRenderbuffer); depthRenderbuffer = 0; }
        GL::GenRenderbuffers(1, &depthRenderbuffer);
        GL::BindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);
        GL::RenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, currentWidth, currentHeight);
        GL::BindRenderbuffer(GL_RENDERBUFFER, 0);

        GL::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);
    }
    auto status = GL::CheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE)
    {
        std::cerr << "Failed to create resolve framebuffer\n";
        std::exit(-1);
    }
    GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
}

void OffscreenFramebuffer::createMSAAFramebuffer()
{
    if (!useMSAA)
        return;

    if (msaaFramebuffer == 0)
    {
        GL::GenFramebuffers(1, &msaaFramebuffer);
    }

    if (msaaColorRenderbuffer != 0)
    {
        GL::DeleteRenderbuffers(1, &msaaColorRenderbuffer);
        msaaColorRenderbuffer = 0;
    }

    GL::GenRenderbuffers(1, &msaaColorRenderbuffer);
    GL::BindRenderbuffer(GL_RENDERBUFFER, msaaColorRenderbuffer);
    GL::RenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, GL_RGBA8, currentWidth, currentHeight);
    GL::BindRenderbuffer(GL_RENDERBUFFER, 0);

    GL::BindFramebuffer(GL_FRAMEBUFFER, msaaFramebuffer);
    GL::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, msaaColorRenderbuffer);

    if (depthRenderbuffer != 0) { GL::DeleteRenderbuffers(1, &depthRenderbuffer); depthRenderbuffer = 0; }
    GL::GenRenderbuffers(1, &depthRenderbuffer);
    GL::BindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);
    //use GL::RenderbufferStorageMultisample to create a multisampled depth-stencil renderbuffer
    GL::RenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, GL_DEPTH24_STENCIL8, currentWidth, currentHeight);
    GL::BindRenderbuffer(GL_RENDERBUFFER, 0);


    GL::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);
    auto status = GL::CheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE)
    {
        std::cerr << "Failed to create MSAA framebuffer\n";
        std::exit(-1);
    }
    GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
}

void OffscreenFramebuffer::resolveMSAA()
{

    if (!useMSAA)
        return;

    GL::BindFramebuffer(GL_READ_FRAMEBUFFER, msaaFramebuffer);
    GL::BindFramebuffer(GL_DRAW_FRAMEBUFFER, resolveFramebuffer);
    GL::BlitFramebuffer(0, 0, currentWidth, currentHeight, 0, 0, currentWidth, currentHeight, GL_COLOR_BUFFER_BIT, GL_LINEAR);
    GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
}



================================================
FILE: source/CS200/OffscreenFramebuffer.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


#pragma once

#include "OpenGL/Shader.h"
#include "OpenGL/Framebuffer.h"
#include <GL/glew.h>

class OffscreenFramebuffer
{
public:
    OffscreenFramebuffer() = default;
    ~OffscreenFramebuffer();


    OffscreenFramebuffer(const OffscreenFramebuffer&)            = delete;
    OffscreenFramebuffer& operator=(const OffscreenFramebuffer&) = delete;

    enum class MSAA : bool
    {
        False,
        True
    };
    void   Initialize(int width, int height, MSAA use_msaa = MSAA::False, int msaa_samples = 4);
    void   BindForRendering();
    OpenGL::TextureHandle GetTexture();
    void   Resize(int width, int height);
    void   SetMSAA(MSAA use_msaa, int msaa_samples);

    int GetMSAASamples() const
    {
        return msaaSamples;
        // return 0;
    }

    void Shutdown();

private:
    int            currentWidth{ 0 };
    int            currentHeight{ 0 };

    bool           useMSAA{ false };
    int            msaaSamples{ 4 };
    OpenGL::FramebufferHandle resolveFramebuffer{ 0 };
    OpenGL::TextureHandle resolveTexture{ 0 };

    OpenGL::FramebufferHandle msaaFramebuffer{ 0 };
    OpenGL::Handle msaaColorRenderbuffer{ 0 };
    OpenGL::Handle depthRenderbuffer{ 0 };

    void createResolveFramebuffer();
    void createMSAAFramebuffer();
    void resolveMSAA();
};



================================================
FILE: source/CS200/PostProcessingPipeline.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


#include "PostProcessingPipeline.h"

#include "OpenGL/GL.h"
#include "OpenGL/Buffer.h"
#include "OpenGL/VertexArray.h"
#include <array>
#include <iostream>

PostProcessingPipeline::~PostProcessingPipeline()
{
    Shutdown();
}

void PostProcessingPipeline::Initialize(int width, int height)
{
    currentWidth  = width;
    currentHeight = height;

    setupFullscreenTriangle();

    for (auto& effect : effects)
    {
        createFramebuffer(effect);
    }
}

void PostProcessingPipeline::AddEffect(PostProcessingEffect&& effect)
{
    effects.push_back(std::move(effect));

    if (currentWidth > 0 && currentHeight > 0)
    {
        createFramebuffer(effects.back());
    }
}

OpenGL::TextureHandle PostProcessingPipeline::Apply(OpenGL::TextureHandle input_texture)
{
    OpenGL::TextureHandle current_texture = input_texture;

    for (const auto& effect : effects)
    {
        if (effect.Enabled == PostProcessingEffect::Enable::True && effect.Framebuffer)
        {
            renderEffect(effect, current_texture);
            current_texture = effect.Framebuffer->GetTexture();
        }
    }

    return current_texture;
}

void PostProcessingPipeline::Resize(int width, int height)
{
    currentWidth  = width;
    currentHeight = height;

    for (auto& effect : effects)
    {
        if (effect.Framebuffer)
        {
            effect.Framebuffer->Resize(currentWidth, currentHeight);
        }
    }
}

void PostProcessingPipeline::Shutdown()
{
    for (auto& effect : effects)
    {
        if (effect.Framebuffer)
        {
            effect.Framebuffer->Shutdown();
            effect.Framebuffer.reset();
        }
        if (effect.Shader.Shader != 0)
        {
            GL::DeleteProgram(effect.Shader.Shader);
            effect.Shader.Shader = 0;
        }
    }
    effects.clear();

    if (fullscreenVAO != 0)
    {
        GL::DeleteVertexArrays(1, &fullscreenVAO);
        fullscreenVAO = 0;
    }
    if (fullscreenVBO != 0)
    {
        GL::DeleteBuffers(1, &fullscreenVBO);
        fullscreenVBO = 0;
    }
}

PostProcessingEffect* PostProcessingPipeline::GetEffect(const std::string& name)
{
    for (auto& effect : effects)
    {
        if (effect.Name == name)
        {
            return &effect;
        }
    }
    return nullptr;
}

void PostProcessingPipeline::createFramebuffer(PostProcessingEffect& effect)
{
    if (!effect.Framebuffer)
    {
        effect.Framebuffer = std::make_unique<OffscreenFramebuffer>();
    }

    effect.Framebuffer->Initialize(currentWidth, currentHeight, OffscreenFramebuffer::MSAA::False);
}

void PostProcessingPipeline::renderEffect(const PostProcessingEffect& effect, GLuint input_texture)
{
    effect.Framebuffer->BindForRendering();
    GL::ClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    GL::Clear(GL_COLOR_BUFFER_BIT);
    GL::Viewport(0, 0, currentWidth, currentHeight);

    GL::UseProgram(effect.Shader.Shader);

    effect.SetUniforms(effect.Shader);

    GL::ActiveTexture(GL_TEXTURE0);
    GL::BindTexture(GL_TEXTURE_2D, input_texture);
    GL::Uniform1i(effect.Shader.UniformLocations.at("uColorTexture"), 0);

    GL::BindVertexArray(fullscreenVAO);
    GL::DrawArrays(GL_TRIANGLES, 0, fullscreenVertexCount);
    GL::BindVertexArray(0);
    GL::BindTexture(GL_TEXTURE_2D, 0);
    GL::UseProgram(0);
    GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
}

void PostProcessingPipeline::setupFullscreenTriangle()
{
    struct FullscreenVertex
    {
        float x, y;
        float u, v;
    };

    const FullscreenVertex vertices[] = {
        { -1.0f, -1.0f, 0.0f, 0.0f },
        {  3.0f, -1.0f, 2.0f, 0.0f },
        { -1.0f,  3.0f, 0.0f, 2.0f },
    };

    fullscreenVertexCount = static_cast<GLsizei>(std::ssize(vertices));

    fullscreenVBO = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ vertices }));

    const auto layout = {
        OpenGL::VertexBuffer{ 
            fullscreenVBO, 
            { 
                OpenGL::Attribute::Float2, // Position
                OpenGL::Attribute::Float2  // UV
            } 
        }
    };

    fullscreenVAO = OpenGL::CreateVertexArrayObject(layout);
}



================================================
FILE: source/CS200/PostProcessingPipeline.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


#pragma once

#include "OffscreenFramebuffer.h"
#include "OpenGL/Shader.h"
#include "OpenGL/Texture.h"
#include <GL/glew.h>
#include <functional>
#include <memory>
#include <string>
#include <vector>

struct PostProcessingEffect
{
    std::string Name;
    enum class Enable : bool
    {
        False,
        True
    };
    Enable                                Enabled;
    OpenGL::CompiledShader                Shader;
    std::unique_ptr<OffscreenFramebuffer> Framebuffer;

    using SetUniformsFunction = std::function<void(const OpenGL::CompiledShader&)>;
    SetUniformsFunction SetUniforms;

    PostProcessingEffect(
        const std::string& name, Enable enabled, OpenGL::CompiledShader shader, SetUniformsFunction set_uniforms = [](const OpenGL::CompiledShader&) { })
        : Name(name), Enabled(enabled), Shader(shader), Framebuffer(nullptr), SetUniforms(set_uniforms)
    {
    }
};

class PostProcessingPipeline
{
public:
    PostProcessingPipeline() = default;
    ~PostProcessingPipeline();

    PostProcessingPipeline(const PostProcessingPipeline&)            = delete;
    PostProcessingPipeline& operator=(const PostProcessingPipeline&) = delete;

    void                  Initialize(int width, int height);
    void                  AddEffect(PostProcessingEffect&& effect);
    OpenGL::TextureHandle Apply(OpenGL::TextureHandle input_texture);
    void                  Resize(int width, int height);
    void                  Shutdown();
    PostProcessingEffect* GetEffect(const std::string& name);

private:
    std::vector<PostProcessingEffect> effects{};
    int                               currentWidth{ 0 };
    int                               currentHeight{ 0 };
    OpenGL::Handle                    fullscreenVAO{ 0 };
    OpenGL::Handle                    fullscreenVBO{ 0 };
    GLsizei                           fullscreenVertexCount{ 0 };

    void createFramebuffer(PostProcessingEffect& effect);
    void renderEffect(const PostProcessingEffect& effect, GLuint input_texture);
    void setupFullscreenTriangle();
};



================================================
FILE: source/CS200/Renderer2DUtils.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Renderer2DUtils.h"

#include <algorithm>
#include <cmath>

namespace CS200::Renderer2DUtils
{
    Math::TransformationMatrix CalculateLineTransform(const Math::TransformationMatrix& transform, const Math::vec2& start_point, const Math::vec2& end_point, double line_width) noexcept
    {
        const Math::vec2 line_vector = end_point - start_point;

        const double            angle             = std::atan2(line_vector.y, line_vector.x);
        constexpr double        center_multiplier = 0.5;
        const Math::vec2        center_point      = (start_point + end_point) * center_multiplier;
        const Math::ScaleMatrix scale_matrix{
            { line_vector.Length(), line_width }
        };
        const Math::RotationMatrix    rotation_matrix{ angle };
        const Math::TranslationMatrix translation_matrix{ center_point };
        const auto                    final_transform = transform * translation_matrix * rotation_matrix * scale_matrix;
        return final_transform;
    }

    SDFTransform CalculateSDFTransform(const Math::TransformationMatrix& transform, double line_width) noexcept
    {
        const vec2  world_size{ static_cast<float>(std::sqrt(transform[0][0] * transform[0][0] + transform[1][0] * transform[1][0])),
                               static_cast<float>(std::sqrt(transform[0][1] * transform[0][1] + transform[1][1] * transform[1][1])) };
        const float line_width_addition = std::max(static_cast<float>(line_width), 0.0f);
        const vec2  quad_size           = { world_size[0] + line_width_addition, world_size[1] + line_width_addition };

        const vec2 scale_up       = { quad_size[0] / world_size[0], quad_size[1] / world_size[1] };
        mat3       quad_transform = to_opengl_mat3(transform);
        quad_transform[0] *= scale_up[0];
        quad_transform[1] *= scale_up[0];
        quad_transform[3] *= scale_up[1];
        quad_transform[4] *= scale_up[1];
        return { quad_transform, world_size, quad_size };
    }
}



================================================
FILE: source/CS200/Renderer2DUtils.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Matrix.h"
#include "Engine/Vec2.h"
#include "RGBA.h"
#include <array>
#include <optional>

namespace CS200::Renderer2DUtils
{
    
    using mat3 = std::array<float, 9>; 
    using vec2 = std::array<float, 2>; 

   
    inline mat3 to_opengl_mat3(const Math::TransformationMatrix& transform) noexcept
    {
        return { static_cast<float>(transform[0][0]), static_cast<float>(transform[1][0]), static_cast<float>(transform[2][0]),
                 static_cast<float>(transform[0][1]), static_cast<float>(transform[1][1]), static_cast<float>(transform[2][1]),
                 static_cast<float>(transform[0][2]), static_cast<float>(transform[1][2]), static_cast<float>(transform[2][2]) };
    }

    
    Math::TransformationMatrix CalculateLineTransform(const Math::TransformationMatrix& transform, const Math::vec2& start_point, const Math::vec2& end_point, double line_width) noexcept;

    
    struct SDFTransform
    {
        mat3 QuadTransform; 
        vec2 WorldSize;     
        vec2 QuadSize;      
    };

    
    SDFTransform CalculateSDFTransform(const Math::TransformationMatrix& transform, double line_width) noexcept;
}



================================================
FILE: source/CS200/RenderingAPI.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "RenderingAPI.h"

#include "Engine/Engine.h"
#include "Engine/Error.h"
#include "Engine/Logger.h"
#include "OpenGL/Environment.h"
#include <GL/glew.h>
#include <cassert>

#include "OpenGL/GL.h"

namespace
{
#if defined(DEVELOPER_VERSION) && not defined(IS_WEBGL2)
    void OpenGLMessageCallback(
        [[maybe_unused]] unsigned source, [[maybe_unused]] unsigned type, [[maybe_unused]] unsigned id, unsigned severity, [[maybe_unused]] int length, const char* message,
        [[maybe_unused]] const void* userParam)
    {
        switch (severity)
        {
            case GL_DEBUG_SEVERITY_HIGH: Engine::GetLogger().LogError(message); return;
            case GL_DEBUG_SEVERITY_MEDIUM: Engine::GetLogger().LogError(message); return;
            case GL_DEBUG_SEVERITY_LOW: Engine::GetLogger().LogVerbose(message); return;
            case GL_DEBUG_SEVERITY_NOTIFICATION: Engine::GetLogger().LogVerbose(message); return;
        }

        assert(false && "Unknown severity level!");
    }
#endif
}

namespace CS200::RenderingAPI
{
    void Init() noexcept
    {
        GLint major = 0, minor = 0;

        GL::GetIntegerv(GL_MAJOR_VERSION, &major);
        GL::GetIntegerv(GL_MINOR_VERSION, &minor);
        if (OpenGL::version(major, minor) < OpenGL::version(OpenGL::MinimumRequiredMajorVersion, OpenGL::MinimumRequiredMinorVersion))
            throw_error_message("Unsupported OpenGL version ", major, '.', minor, "\n We need OpenGL ", OpenGL::MinimumRequiredMajorVersion, '.', OpenGL::MinimumRequiredMinorVersion, " or higher");

        if (OpenGL::MajorVersion == 0)
        {
            OpenGL::MajorVersion = major;
            OpenGL::MinorVersion = minor;
        }

        GL::GetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &OpenGL::MaxTextureImageUnits);
        GL::GetIntegerv(GL_MAX_TEXTURE_SIZE, &OpenGL::MaxTextureSize);
        GL::GetIntegerv(GL_MAJOR_VERSION, &OpenGL::MajorVersion);
        GL::GetIntegerv(GL_MINOR_VERSION, &OpenGL::MinorVersion);
        int max_element_vertices;
        GL::GetIntegerv(GL_MAX_ELEMENTS_VERTICES, &max_element_vertices);
        int max_element_indices;
        GL::GetIntegerv(GL_MAX_ELEMENTS_INDICES, &max_element_indices);
        int max_viewport_dims[2];
        GL::GetIntegerv(GL_MAX_VIEWPORT_DIMS, max_viewport_dims);

#if defined(DEVELOPER_VERSION) && not defined(IS_WEBGL2)
        // Debug callback functionality requires OpenGL 4.3+ or KHR_debug extension
        if (OpenGL::current_version() >= OpenGL::version(4, 3))
        {
            GL::Enable(GL_DEBUG_OUTPUT);
            GL::Enable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
            GL::DebugMessageCallback(OpenGLMessageCallback, nullptr);
            GL::DebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION, 0, nullptr, GL_FALSE);
        }
#endif

        GL::Enable(GL_BLEND);
        GL::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        //GL::Disable(GL_DEPTH_TEST);
		GL::Enable(GL_DEPTH_TEST);

        // GL_MAX_TEXTURE_IMAGE_UNITS, GL_MAX_TEXTURE_SIZE, GL_MAX_VIEWPORT_DIMS
        Engine::GetLogger().LogDebug("VENDOR : " + std::to_string(GL_VENDOR));
        Engine::GetLogger().LogDebug("RENDERER : " + std::to_string(GL_RENDERER));
        Engine::GetLogger().LogDebug("VERSION : " + std::to_string(GL_VERSION));
        Engine::GetLogger().LogDebug("SHADING LANGUAGE VERSION : " + std::to_string(GL_SHADING_LANGUAGE_VERSION));
        Engine::GetLogger().LogDebug("MAJOR VERSION : " + std::to_string(OpenGL::MajorVersion));
        Engine::GetLogger().LogDebug("MINOR VERSION : " + std::to_string(OpenGL::MinorVersion));
        Engine::GetLogger().LogDebug("MAX ELEMENTS VERTICES : " + std::to_string(max_element_vertices));
        Engine::GetLogger().LogDebug("MAX ELEMENTS INDICES : " + std::to_string(max_element_indices));
        Engine::GetLogger().LogDebug("MAX TEXTURE IMAGE UNITS : " + std::to_string(OpenGL::MaxTextureImageUnits));
        Engine::GetLogger().LogDebug("MAX TEXTURE SIZE : " + std::to_string(OpenGL::MaxTextureSize));
        Engine::GetLogger().LogDebug("MAX VIEWPORT DIMS : " + std::to_string(max_viewport_dims[0]) + ", " + std::to_string(max_viewport_dims[1]));
    }

    void SetClearColor(CS200::RGBA color) noexcept
    {
        const auto rgba = CS200::unpack_color(color);
        GL::ClearColor(rgba[0], rgba[1], rgba[2], rgba[3]);
    }

    void Clear() noexcept
    {
        //GL::Clear(GL_COLOR_BUFFER_BIT);
		GL::Clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    void SetViewport(Math::ivec2 size, Math::ivec2 anchor_left_bottom) noexcept
    {
        GL::Viewport(anchor_left_bottom.x, anchor_left_bottom.y, size.x, size.y);
    }
}



================================================
FILE: source/CS200/RenderingAPI.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Vec2.h"
#include "RGBA.h"

namespace CS200::RenderingAPI
{
    void Init() noexcept;
    void SetClearColor(CS200::RGBA color) noexcept;
    void Clear() noexcept;
    void SetViewport(Math::ivec2 size, Math::ivec2 anchor_left_bottom = { 0, 0 }) noexcept;
}



================================================
FILE: source/CS200/RGBA.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <array>
#include <cstdint>

namespace CS200
{
    /**
     * \brief Compact 32-bit color representation for efficient graphics operations
     *
     * RGBA provides a memory-efficient way to store and manipulate colors using a single
     * 32-bit integer. This format is widely used in graphics programming because it packs
     * four 8-bit color channels (Red, Green, Blue, Alpha) into one value that can be
     * easily passed around, stored in arrays, and processed by graphics hardware.
     *
     * The color format uses the layout: 0xRRGGBBAA where:
     * - RR = Red channel (bits 31-24)
     * - GG = Green channel (bits 23-16)
     * - BB = Blue channel (bits 15-8)
     * - AA = Alpha channel (bits 7-0)
     *
     * Each channel ranges from 0x00 (0) to 0xFF (255), providing 256 levels per channel
     * and over 16 million possible color combinations with transparency support.
     *
     * This compact representation is ideal for:
     * - Storing vertex colors in graphics buffers
     * - Passing colors as function parameters
     * - Performing fast bitwise color operations
     * - Interfacing with graphics APIs that expect packed colors
     */
    using RGBA = uint32_t;

    /** \brief Pure white color (255, 255, 255, 255) - fully opaque white */
    constexpr RGBA WHITE = 0xffffffff;

    /** \brief Pure black color (0, 0, 0, 255) - fully opaque black */
    constexpr RGBA BLACK = 0x000000ff;

    /** \brief Transparent color (0, 0, 0, 0) - completely transparent black */
    constexpr RGBA CLEAR = 0x00000000;

    /** \brief Light Gray color (200, 200, 200, 255) */
    constexpr RGBA LIGHTGRAY = 0xc8c8c8ff;

    /** \brief Gray color (130, 130, 130, 255) */
    constexpr RGBA GRAY = 0x828282ff;

    /** \brief Dark Gray color (80, 80, 80, 255) */
    constexpr RGBA DARKGRAY = 0x505050ff;

    /** \brief Yellow color (253, 249, 0, 255) */
    constexpr RGBA YELLOW = 0xfdf900ff;

    /** \brief Gold color (255, 203, 0, 255) */
    constexpr RGBA GOLD = 0xffcb00ff;

    /** \brief Orange color (255, 161, 0, 255) */
    constexpr RGBA ORANGE = 0xffa100ff;

    /** \brief Pink color (255, 109, 194, 255) */
    constexpr RGBA PINK = 0xff6dc2ff;

    /** \brief Red color (230, 41, 55, 255) */
    constexpr RGBA RED = 0xe62937ff;

    /** \brief Maroon color (190, 33, 55, 255) */
    constexpr RGBA MAROON = 0xbe2137ff;

    /** \brief Green color (0, 228, 48, 255) */
    constexpr RGBA GREEN = 0x00e430ff;

    /** \brief Lime color (0, 158, 47, 255) */
    constexpr RGBA LIME = 0x009e2fff;

    /** \brief Dark Green color (0, 117, 44, 255) */
    constexpr RGBA DARKGREEN = 0x00752cff;

    /** \brief Sky Blue color (102, 191, 255, 255) */
    constexpr RGBA SKYBLUE = 0x66bffff;

    /** \brief Blue color (0, 121, 241, 255) */
    constexpr RGBA BLUE = 0x0079f1ff;

    /** \brief Dark Blue color (0, 82, 172, 255) */
    constexpr RGBA DARKBLUE = 0x0052acff;

    /** \brief Purple color (200, 122, 255, 255) */
    constexpr RGBA PURPLE = 0xc87affff;

    /** \brief Violet color (135, 60, 190, 255) */
    constexpr RGBA VIOLET = 0x873cbeff;

    /** \brief Dark Purple color (112, 31, 126, 255) */
    constexpr RGBA DARKPURPLE = 0x701f7eff;

    /** \brief Beige color (211, 176, 131, 255) */
    constexpr RGBA BEIGE = 0xd3b083ff;

    /** \brief Brown color (127, 106, 79, 255) */
    constexpr RGBA BROWN = 0x7f6a4fff;

    /** \brief Dark Brown color (76, 63, 47, 255) */
    constexpr RGBA DARKBROWN = 0x4c3f2fff;

    /** \brief Magenta color (255, 0, 255, 255) */
    constexpr RGBA MAGENTA = 0xff00ffff;



    /**
     * \brief Convert packed RGBA color to floating-point component array
     * \param rgba 32-bit packed color in RGBA format
     * \return Array of 4 floats [r, g, b, a] normalized to [0.0, 1.0] range
     *
     * Unpacks a compact RGBA color into separate floating-point components that
     * are commonly required by graphics APIs like OpenGL. Each 8-bit integer
     * channel (0-255) is converted to a normalized float (0.0-1.0).
     *
     * This conversion is essential for:
     * - Passing colors to OpenGL shader uniforms
     * - Performing floating-point color math operations
     * - Interfacing with APIs that expect normalized color values
     * - Blending and interpolation calculations
     *
     * The bit extraction isolates each color channel:
     * - Red: (rgba & 0xff000000) >> 24
     * - Green: (rgba & 0x00ff0000) >> 16
     * - Blue: (rgba & 0x0000ff00) >> 8
     * - Alpha: (rgba & 0x000000ff) >> 0
     *
     * Each extracted value is then divided by 255.0f to normalize to [0.0, 1.0].
     */
    constexpr std::array<float, 4> unpack_color(RGBA rgba) noexcept
    {
        constexpr float scale = 1.0f / 255.0f;
        return { static_cast<float>((rgba & 0xff000000) >> 24) * scale, static_cast<float>((rgba & 0x00ff0000) >> 16) * scale, static_cast<float>((rgba & 0x0000ff00) >> 8) * scale,
                 static_cast<float>((rgba & 0x000000ff) >> 0) * scale };
    }

    /**
     * \brief Convert floating-point color components to packed RGBA format
     * \param color Array of 4 floats [r, g, b, a] in normalized [0.0, 1.0] range
     * \return 32-bit packed color in RGBA format (0xRRGGBBAA)
     *
     * Packs separate floating-point color components into a compact RGBA color
     * suitable for efficient storage and graphics operations. This is the inverse
     * operation of unpack_color(), converting normalized float values back into
     * the 8-bit integer format used by graphics hardware and APIs.
     *
     * This conversion is essential for:
     * - Converting computed color results back to graphics-friendly format
     * - Storing blended or interpolated colors efficiently
     * - Interfacing with graphics APIs that expect packed color values
     * - Optimizing memory usage in color arrays and vertex buffers
     *
     * The packing process:
     * 1. Scale each float component from [0.0, 1.0] to [0.0, 255.0]
     * 2. Clamp values to valid range [0, 255] to handle out-of-bounds inputs
     * 3. Convert to 8-bit integers (uint8_t)
     * 4. Shift and combine channels into final RGBA format:
     *    - Red: bits 31-24 (R << 24)
     *    - Green: bits 23-16 (G << 16)
     *    - Blue: bits 15-8 (B << 8)
     *    - Alpha: bits 7-0 (A << 0)
     *
     * Input values are automatically clamped to [0.0, 1.0] range to prevent
     * overflow and ensure valid color output even with out-of-range inputs.
     */
    constexpr RGBA pack_color(const std::array<float, 4>& color) noexcept
    {
        constexpr float scale = 255.0f;
        const float     r = color[0] * scale, g = color[1] * scale, b = color[2] * scale, a = color[3] * scale;
        const uint8_t   R = static_cast<uint8_t>(r <= 255.0f ? (r >= 0.0f ? r : 0.0f) : 255.0f);
        const uint8_t   G = static_cast<uint8_t>(g <= 255.0f ? (g >= 0.0f ? g : 0.0f) : 255.0f);
        const uint8_t   B = static_cast<uint8_t>(b <= 255.0f ? (b >= 0.0f ? b : 0.0f) : 255.0f);
        const uint8_t   A = static_cast<uint8_t>(a <= 255.0f ? (a >= 0.0f ? a : 0.0f) : 255.0f);
        return (static_cast<RGBA>(R) << 24) | (static_cast<RGBA>(G) << 16) | (static_cast<RGBA>(B) << 8) | (static_cast<RGBA>(A) << 0);
    }
    constexpr RGBA pack_color(const std::array<uint8_t, 4>& color) noexcept
    {
        return (static_cast<RGBA>(color[0]) << 24) | (static_cast<RGBA>(color[1]) << 16) | (static_cast<RGBA>(color[2]) << 8) | (static_cast<RGBA>(color[3]) << 0);
    }
    /**
     * \brief Convert RGBA format to ABGR format by reversing byte order
     * \param rgba Color in RGBA format (0xRRGGBBAA)
     * \return Color converted to ABGR format (0xAABBGGRR)
     *
     * Converts between different color byte ordering formats that are used by
     * various graphics systems and file formats. This conversion is necessary
     * when interfacing with systems that expect colors in ABGR order instead
     * of the standard RGBA order.
     *
     * The conversion process:
     * 1. Extract each color channel from the original RGBA value
     * 2. Rearrange the channels from RGBA order to ABGR order
     * 3. Pack the rearranged channels into a new 32-bit value
     *
     * Common use cases:
     * - Converting colors for specific graphics APIs or hardware
     * - Interfacing with image file formats that use different byte orders
     * - Preparing colors for systems with different endianness
     * - Working with legacy graphics formats that expect ABGR ordering
     *
     * The byte reversal ensures compatibility across different systems while
     * maintaining the same color information in a different memory layout.
     */
    constexpr uint32_t rgba_to_abgr(RGBA rgba) noexcept
    {
        const uint8_t r = static_cast<uint8_t>((rgba & 0xff000000) >> 24);
        const uint8_t g = static_cast<uint8_t>((rgba & 0x00ff0000) >> 16);
        const uint8_t b = static_cast<uint8_t>((rgba & 0x0000ff00) >> 8);
        const uint8_t a = static_cast<uint8_t>((rgba & 0x000000ff) >> 0);

        return (static_cast<uint32_t>(a) << 24) | (static_cast<uint32_t>(b) << 16) | (static_cast<uint32_t>(g) << 8) | (static_cast<uint32_t>(r) << 0);
    }

    constexpr uint32_t argb_to_rgba(RGBA rgba) noexcept
    {
        const uint8_t r = static_cast<uint8_t>((rgba & 0x00ff0000) >> 16);
        const uint8_t g = static_cast<uint8_t>((rgba & 0x0000ff00) >> 8);
        const uint8_t b = static_cast<uint8_t>((rgba & 0x000000ff) >> 0);
        const uint8_t a = static_cast<uint8_t>((rgba & 0xff000000) >> 24);

        return (static_cast<uint32_t>(a) << 24) | (static_cast<uint32_t>(b) << 16) | (static_cast<uint32_t>(g) << 8) | (static_cast<uint32_t>(r) << 0);
    }

    constexpr std::array<unsigned char, 4> ColorArray(RGBA rgba)
    {
        return std::array<unsigned char, 4>({ static_cast<unsigned char>((rgba & 0xff000000) >> 24), static_cast<unsigned char>((rgba & 0x00ff0000) >> 16),
                                              static_cast<unsigned char>((rgba & 0x0000ff00) >> 8), static_cast<unsigned char>((rgba & 0x000000ff) >> 0) });
    }


}



================================================
FILE: source/CS200/Shape.cpp
================================================
#include "Shape.h"
#include "CS200/RGBA.h"
#include "CS200/Renderer2DUtils.h"
#include "Engine/Path.h"
#include "OpenGL/GL.h"
#include <span>

namespace CS230
{
  Shape::Shape(PrimitivePattern pattern, std::span<const Vertex> vertices)
  {
	setup(pattern, /* WhiteTexture() */ OpenGL::CreateTextureFromMemory({ 1, 1 }, std::array<CS200::RGBA, 1>{ CS200::WHITE }), vertices);
  }

  Shape::Shape(PrimitivePattern pattern, OpenGL::TextureHandle texture, std::span<const Vertex> vertices)
  {
	setup(pattern, texture, vertices);
  }

  Shape::~Shape()
  {
	GL::DeleteBuffers(1, &vertexBuffer), vertexBuffer				 = 0;
	GL::DeleteTextures(1, &textureHandle), textureHandle			 = 0;
	GL::DeleteVertexArrays(1, &vertexArrayObject), vertexArrayObject = 0;
	OpenGL::DestroyShader(shapeShader);
  }

  Shape::Shape(Shape&& other) noexcept
	  : vertexBuffer(other.vertexBuffer), vertexArrayObject(other.vertexArrayObject), textureHandle(other.textureHandle), shapeShader(std::move(other.shapeShader)), primitivePattern(other.primitivePattern),
		vertexCount(other.vertexCount)
  {
	other.vertexBuffer		= 0;
	other.vertexArrayObject = 0;
	other.textureHandle		= 0;
	other.vertexCount		= 0;
	other.shapeShader		= {};
  }

  Shape& Shape::operator=(Shape&& other) noexcept
  {
	std::swap(vertexBuffer, other.vertexBuffer);
	std::swap(vertexArrayObject, other.vertexArrayObject);
	std::swap(textureHandle, other.textureHandle);
	std::swap(primitivePattern, other.primitivePattern);
	std::swap(vertexCount, other.vertexCount);
	std::swap(shapeShader, other.shapeShader);
	return *this;
  }

  void Shape::Draw(Math::TransformationMatrix model_matrix, unsigned int color, float depth) const noexcept
  {
	GL::UseProgram(shapeShader.Shader);

	const auto&				   locations			 = shapeShader.UniformLocations;
	Math::TransformationMatrix anchored_model_matrix = model_matrix * Math::TranslationMatrix(Math::vec2{ 0.5, 0.5 });
	const auto				   model_matrix_opengl	 = CS200::Renderer2DUtils::to_opengl_mat3(anchored_model_matrix);
	GL::UniformMatrix3fv(locations.at("uTransform"), 1, GL_FALSE, model_matrix_opengl.data());
	GL::Uniform4fv(locations.at("uTint"), 1, CS200::unpack_color(color).data());
	GL::Uniform1f(locations.at("uDepth"), depth);

	GL::ActiveTexture(GL_TEXTURE0);
	GL::BindTexture(GL_TEXTURE_2D, textureHandle);
	GL::BindVertexArray(vertexArrayObject);

	GL::DrawArrays(static_cast<GLenum>(primitivePattern), 0, vertexCount);

	GL::BindTexture(GL_TEXTURE_2D, 0);
	GL::BindVertexArray(0);
	GL::UseProgram(0);
  }

  void Shape::setup(PrimitivePattern pattern, OpenGL::TextureHandle texture, std::span<const Vertex> vertices)
  {
	shapeShader		 = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/shape/shape.vert"), assets::locate_asset("Assets/shaders/shape/shape.frag"));
	primitivePattern = pattern;
	textureHandle	 = texture;
	vertexCount		 = static_cast<GLsizei>(vertices.size());

	// Create vertex buffer
	vertexBuffer = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(vertices));

	// no index buffer this time

	// Create vertex array object
	const auto layout = {
	  OpenGL::VertexBuffer{ vertexBuffer, { OpenGL::Attribute::Float2, OpenGL::Attribute::Float2 } }
	};
	vertexArrayObject = OpenGL::CreateVertexArrayObject(layout);
  }
}



================================================
FILE: source/CS200/Shape.h
================================================
#pragma once

#include "OpenGL/Buffer.h"
#include "OpenGL/Shader.h"
#include "OpenGL/Texture.h"
#include "OpenGL/VertexArray.h"

#include "Engine/Component.h"
#include "Engine/Matrix.h"

#include <GL/glew.h>
#include <array>
#include <memory>
#include <span>

namespace CS230
{
	class Shape : public Component
	{
	public:
		enum class PrimitivePattern : GLenum
		{
			Points		  = GL_POINTS,
			Lines		  = GL_LINES,
			LineStrip	  = GL_LINE_STRIP,
			LineLoop	  = GL_LINE_LOOP,
			Triangles	  = GL_TRIANGLES,
			TriangleStrip = GL_TRIANGLE_STRIP,
			TriangleFan	  = GL_TRIANGLE_FAN
		};

		struct Vertex
		{
			float						 x = 0, y = 0; //layout1
			float						 s = 0, t = 0; //layout2
			// std::array<unsigned char, 4> tint{ 255, 255, 255, 255 }; //layout3

			constexpr Vertex() noexcept = default;

			constexpr Vertex(float x_, float y_, float s_, float t_) noexcept : x(x_), y(y_), s(s_), t(t_)
			{
			}

			constexpr Vertex(float x_, float y_) noexcept : Vertex(x_, y_, 0.0f, 0.0f)
			{
			}


		};

	public:
		Shape(PrimitivePattern pattern, std::span<const Vertex> vertices);
		Shape(PrimitivePattern pattern, OpenGL::TextureHandle texture, std::span<const Vertex> vertices);

		~Shape();
		Shape(const Shape&)			   = delete;
		Shape& operator=(const Shape&) = delete;
		Shape(Shape&& other) noexcept;
		Shape& operator=(Shape&& other) noexcept;

		void Draw(Math::TransformationMatrix model_matrix, unsigned int color = 0xFFFFFFFF, float depth = 0.5f) const noexcept;


	private:
		OpenGL::BufferHandle	  vertexBuffer		= 0;
		OpenGL::VertexArrayHandle vertexArrayObject = 0;
		OpenGL::TextureHandle	  textureHandle		= 0;
		OpenGL::CompiledShader	  shapeShader{};
		PrimitivePattern		  primitivePattern = PrimitivePattern::Triangles;
		GLsizei					  vertexCount	   = 0;

	private:
		void setup(PrimitivePattern pattern, OpenGL::TextureHandle texture, std::span<const Vertex> vertices);
	};
}



================================================
FILE: source/Demo/DemoDepthPost.cpp
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Demo/DemoDepthPost.h"
#include "DemoDepthPost.h"
#include "Engine/TextureManager.h"
#include <algorithm>
#include <random>

#include "Engine/Collision.h"
#include "Engine/Input.h"
#include "Engine/Path.h"
#include "Engine/Random.h"
#include "Engine/TextureManager.h"
#include "Engine/Timer.h"
#include "Engine/Window.h"
#include <imgui.h>

#include "CS200/IRenderer2D.h"
#include "CS200/ImGuiHelper.h"
#include "CS200/NDC.h"
#include "CS200/RenderingAPI.h"

#include "OpenGL/Buffer.h"
#include "OpenGL/Environment.h"
#include "OpenGL/GL.h"

#include "Game/MainMenu.h"

void DemoDepthPost::setupScreenTriangle()
{
	struct ScreenVertex
	{
		float x, y;
		float u, v;
	};

	const ScreenVertex vertices[] = {
		{ -1.0f, -1.0f, 0.0f, 0.0f },
		{  3.0f, -1.0f, 2.0f, 0.0f },
		{ -1.0f,	 3.0f, 0.0f, 2.0f },
	};

	screenVertexCount = static_cast<GLsizei>(std::ssize(vertices));

	screenVBO = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ vertices }));

	const auto layout = {
		OpenGL::VertexBuffer{ screenVBO,
							  {
								  OpenGL::Attribute::Float2, // Location 0: Position (x, y)
								  OpenGL::Attribute::Float2	 // Location 1: TexCoord (u, v)
							  } }
	};

	screenVAO = OpenGL::CreateVertexArrayObject(layout);
}

void DemoDepthPost::Load()
{
	// #if !defined(__EMSCRIPTEN__)
	Engine::GetWindow().ForceResize(default_window_size.x, default_window_size.y);
	Engine::GetWindow().SetWindowPosition(SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
	// #endif

	auto& texture_manager = Engine::GetTextureManager();
	for (size_t i = 0; i < NUM_LAYERS; ++i)
	{
		background_layers[i].texture = texture_manager.Load("Assets/images/DemoDepthPost/background_" + std::to_string(i) + ".png");
		background_layers[i].depth	 = static_cast<float>(i) / NUM_LAYERS; // Depth from 0.0, 0.125, ..., 0.875
	}
	CS200::RenderingAPI::SetClearColor(CS200::WHITE);

	texture_manager.SwitchRenderer(CS230::TextureManager::RendererType::Batch);

	// Initialize FPS tracking
	LastTicks = SDL_GetTicks();

	// Initialize ducks
	duck_texture = texture_manager.Load("Assets/images/DemoDepthPost/duck.png");
	for (size_t i = 0; i < NUM_DUCKS; ++i)
	{
#if defined(__EMSCRIPTEN__)
		ducks[i].position = { static_cast<double>(util::random(500, 900)), static_cast<double>(util::random(500, 800)) };
#else
		Math::ivec2 window_size = Engine::GetWindow().GetSize();
		ducks[i].position = { static_cast<double>(util::random(100, window_size.x - 100)), static_cast<double>(util::random(100, window_size.y - 100)) };
#endif
		uint8_t r	   = static_cast<uint8_t>(util::random(256));
		uint8_t g	   = static_cast<uint8_t>(util::random(256));
		uint8_t b	   = static_cast<uint8_t>(util::random(256));
		uint8_t a	   = static_cast<uint8_t>(util::random(100, 250)); // get transparency between 100 and 250
		ducks[i].color = CS200::pack_color(std::array<uint8_t, 4>{ r, g, b, a });
		ducks[i].depth = static_cast<float>(util::random(-0.9, -0.1)); // Depth between -0.9 to -0.1
	}

	// sort ducks by depth back to front(painter's algorithm)
	std::sort(std::begin(ducks), std::end(ducks), [](const Duck& left, const Duck& right) { return left.depth > right.depth; });

	// msaa settings
	const auto use_msaa = useMSAA ? OffscreenFramebuffer::MSAA::True : OffscreenFramebuffer::MSAA::False;
	offscreenBuffer.Initialize(default_window_size.x, default_window_size.y, use_msaa, MSAASamples);

	const std::filesystem::path screen_vert = assets::locate_asset("Assets/shaders/PostProcess/simple.vert");
	const std::filesystem::path screen_frag = assets::locate_asset("Assets/shaders/PostProcess/simple-texture.frag");
	screenShader							= OpenGL::CreateShader(screen_vert, screen_frag);

	setupScreenTriangle();

	postProcessing.Initialize(default_window_size.x, default_window_size.y);

	{
		const std::filesystem::path box_blur_vert	= assets::locate_asset("Assets/shaders/PostProcess/simple.vert");
		const std::filesystem::path box_blur_frag	= assets::locate_asset("Assets/shaders/PostProcess/box-blur.frag");
		auto						box_blur_shader = OpenGL::CreateShader(box_blur_vert, box_blur_frag);

		postProcessing.AddEffect(PostProcessingEffect(
			"Box Blur", PostProcessingEffect::Enable::False, box_blur_shader,
			[&](const OpenGL::CompiledShader& shader)
			{
				GL::Uniform1i(shader.UniformLocations.at("uBlurSize"), static_cast<int>(boxBlurSize));
				GL::Uniform1f(shader.UniformLocations.at("uSeparation"), boxBlurSeparation);
			}));
	}


	{
		const std::filesystem::path chroma_vert	  = assets::locate_asset("Assets/shaders/PostProcess/simple.vert");
		const std::filesystem::path chroma_frag	  = assets::locate_asset("Assets/shaders/PostProcess/chromatic-aberration.frag");
		auto						chroma_shader = OpenGL::CreateShader(chroma_vert, chroma_frag);

		postProcessing.AddEffect(PostProcessingEffect(
			"Chromatic Aberration", PostProcessingEffect::Enable::False, chroma_shader,
			[&](const OpenGL::CompiledShader& shader) { GL::Uniform2f(shader.UniformLocations.at("uMouseFocusPoint"), chromaticAberrationMouseX, chromaticAberrationMouseY); }));
	}
	{
		const std::filesystem::path pixel_vert	 = assets::locate_asset("Assets/shaders/PostProcess/simple.vert");
		const std::filesystem::path pixel_frag	 = assets::locate_asset("Assets/shaders/PostProcess/pixelize.frag");
		auto						pixel_shader = OpenGL::CreateShader(pixel_vert, pixel_frag);

		postProcessing.AddEffect(PostProcessingEffect(
			"Pixelization", PostProcessingEffect::Enable::False, pixel_shader,
			[&](const OpenGL::CompiledShader& shader) { GL::Uniform1i(shader.UniformLocations.at("pixelSize"), pixelSize); })); // must be odd
	}

	{
		const std::filesystem::path gamma_vert	 = assets::locate_asset("Assets/shaders/PostProcess/simple.vert");
		const std::filesystem::path gamma_frag	 = assets::locate_asset("Assets/shaders/PostProcess/gamma-correct.frag");
		auto						gamma_shader = OpenGL::CreateShader(gamma_vert, gamma_frag);

		postProcessing.AddEffect(PostProcessingEffect(
			"Gamma Correction", PostProcessingEffect::Enable::False, gamma_shader, [&](const OpenGL::CompiledShader& shader) { GL::Uniform1f(shader.UniformLocations.at("uGamma"), gammaValue); }));
	}

	GL::Enable(GL_BLEND);
	GL::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	if (useMSAA)
	{
		GL::Enable(GL_MULTISAMPLE);
	}
}

void DemoDepthPost::Update([[maybe_unused]] double dt)
{
	// Update FPS tracker
	const Uint32 currentTicks = SDL_GetTicks();
	const Uint32 deltaTicks	  = currentTicks - LastTicks;
	const double deltaSeconds = deltaTicks / 1000.0;
	LastTicks				  = currentTicks;
	FPSTracker.Update(deltaSeconds);

	if (Engine::GetInput().KeyJustReleased(CS230::Input::Keys::Escape))
	{
		Engine::GetGameStateManager().PopState();
		Engine::GetGameStateManager().PushState<MainMenu>();
	}
}

void DemoDepthPost::Unload()
{
	offscreenBuffer.Shutdown();
	postProcessing.Shutdown();
	if (screenVAO != 0)
	{
		GL::DeleteVertexArrays(1, &screenVAO);
		screenVAO = 0;
	}
	if (screenVBO != 0)
	{
		GL::DeleteBuffers(1, &screenVBO);
		screenVBO = 0;
	}
	if (screenShader.Shader != 0)
	{
		OpenGL::DestroyShader(screenShader);
	}
}

void DemoDepthPost::Draw()
{
	static int		  last_width  = 0;
	static int		  last_height = 0;
	const Math::ivec2 window_size = Engine::GetWindow().GetSize();
	ratio						  = static_cast<double>(window_size.x) / default_window_size.x;
#if defined(__EMSCRIPTEN__)
	ratio = 0.3;
#endif
	if (window_size.x != last_width || window_size.y != last_height)
	{
		offscreenBuffer.Resize(window_size.x, window_size.y);
		postProcessing.Resize(window_size.x, window_size.y);
		last_width	= window_size.x;
		last_height = window_size.y;
	}
	// 1. Render to Offscreen FBO
	GL::Enable(GL_DEPTH_TEST);
	offscreenBuffer.BindForRendering();
	CS200::IRenderer2D* renderer_2d = Engine::GetTextureManager().GetRenderer2D();
	renderer_2d->BeginScene(CS200::build_ndc_matrix(window_size));


	CS200::RenderingAPI::Clear(); // Clear Color & Depth

	// opaque background layers
	GL::DepthMask(GL_TRUE); // enable depth write
	GL::DepthFunc(GL_LESS); // set depth function to less

	CS200::RenderingAPI::SetViewport(window_size, { 0, 0 });

	for (const auto& layer : background_layers)
	{
		layer.texture->Draw(Math::TransformationMatrix() * Math::ScaleMatrix(ratio), 0xFFFFFFFF, layer.depth);
	}

	// transparent ducks
	GL::DepthMask(GL_FALSE); // disable depth write
	for (const auto& duck : ducks)
	{
#if defined(__EMSCRIPTEN__)
		duck_texture->Draw(Math::TranslationMatrix(Math::vec2{ -500, -500 }) * Math::TranslationMatrix(duck.position) * Math::ScaleMatrix(ratio), duck.color, duck.depth);
#else
		duck_texture->Draw(Math::TranslationMatrix(duck.position) * Math::ScaleMatrix(ratio), duck.color, duck.depth);
#endif
	}
	GL::DepthMask(GL_TRUE); // enable depth write
	renderer_2d->EndScene();

	// 2. Resolve (MSAA -> Texture) & PostProcess
	OpenGL::TextureHandle scene_texture = offscreenBuffer.GetTexture();
	OpenGL::TextureHandle final_texture = scene_texture;

	GL::Disable(GL_DEPTH_TEST);
	if (enablePostFX)
	{
		final_texture = postProcessing.Apply(scene_texture);
	}

	// 3. Render Final Texture to Screen
	GL::Clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	GL::Viewport(0, 0, default_window_size.x, default_window_size.y);


	GL::UseProgram(screenShader.Shader);

	GL::ActiveTexture(GL_TEXTURE0);
	GL::BindTexture(GL_TEXTURE_2D, final_texture);

	if (screenShader.UniformLocations.count("uColorTexture"))
	{
		GL::Uniform1i(screenShader.UniformLocations.at("uColorTexture"), 0);
	}

	GL::BindVertexArray(screenVAO);
	GL::DrawArrays(GL_TRIANGLES, 0, screenVertexCount);

	GL::BindVertexArray(0);
	GL::BindTexture(GL_TEXTURE_2D, 0);
	GL::UseProgram(0);


	GL::Enable(GL_DEPTH_TEST);
	renderer_2d->EndScene();
}

void DemoDepthPost::DrawImGui()
{
	ImGui::Begin("Demo Depth & Post-Processing Controls");
	// Display FPS at the top
	ImGui::Text("FPS: %d", static_cast<int>(FPSTracker));
	ImGui::Separator();

	ImGui::SeparatorText("Depth Settings");

	if (ImGui::Button("Sort as Painters Algorithm"))
	{
		std::sort(std::begin(background_layers), std::end(background_layers), [](const BackGroundLayer& left, const BackGroundLayer& right) { return left.depth > right.depth; });
	}

	if (ImGui::Button("Sort as Front to Back"))
	{
		std::sort(
			std::begin(background_layers), std::end(background_layers),
			[](const BackGroundLayer& left, const BackGroundLayer& right)
			{
				return left.depth < right.depth; // then smaller depth drawn first, and frag of larger depth gonna be skipped over by depth test, and hopefully save effort of fragment shader
			});
	}

	if (ImGui::Button("Sort Randomly"))
	{
		std::random_device rd;
		std::mt19937	   g(rd());
		std::shuffle(std::begin(background_layers), std::end(background_layers), g);
	}
	ImGui::SeparatorText("MSAA Settings");
	bool msaa_changed = ImGui::Checkbox("Enable MSAA", &useMSAA);

	ImGui::BeginDisabled(!useMSAA);


	static GLint max_msaa_samples = 0;
	if (max_msaa_samples == 0)
	{
		GL::GetIntegerv(GL_MAX_SAMPLES, &max_msaa_samples);
	}


	static std::vector<int> valid_samples;
	if (valid_samples.empty())
	{
		for (int samples = 2; samples <= max_msaa_samples; samples *= 2)
		{
			valid_samples.push_back(samples);
		}
	}


	int current_index = 0;
	for (size_t i = 0; i < valid_samples.size(); ++i)
	{
		if (valid_samples[i] == MSAASamples)
		{
			current_index = static_cast<int>(i);
			break;
		}
	}


	std::string preview = std::to_string(MSAASamples) + "x";
	if (ImGui::BeginCombo("MSAA Samples", preview.c_str()))
	{
		for (size_t i = 0; i < valid_samples.size(); ++i)
		{
			bool		is_selected = (current_index == static_cast<int>(i));
			std::string label		= std::to_string(valid_samples[i]) + "x";

			if (ImGui::Selectable(label.c_str(), is_selected))
			{
				MSAASamples	 = valid_samples[i];
				msaa_changed = true;
			}

			if (is_selected)
			{
				ImGui::SetItemDefaultFocus();
			}
		}
		ImGui::EndCombo();
	}

	ImGui::EndDisabled();

	if (msaa_changed)
	{
		const auto use_msaa = useMSAA ? OffscreenFramebuffer::MSAA::True : OffscreenFramebuffer::MSAA::False;
		offscreenBuffer.SetMSAA(use_msaa, MSAASamples);

		MSAASamples = offscreenBuffer.GetMSAASamples();

		if (useMSAA)
		{
			GL::Enable(GL_MULTISAMPLE);
		}
		else
		{
			GL::Disable(GL_MULTISAMPLE);
		}
	}

	ImGui::SeparatorText("Post-Processing Effects");
	ImGui::Checkbox("Enable Post-FX", &enablePostFX);

	ImGui::BeginDisabled(!enablePostFX);


	if (auto* box_blur = postProcessing.GetEffect("Box Blur"))
	{
		ImGui::Checkbox(box_blur->Name.c_str(), reinterpret_cast<bool*>(&box_blur->Enabled));

		ImGui::BeginDisabled(box_blur->Enabled == PostProcessingEffect::Enable::False);
		ImGui::Indent();
		ImGui::SliderFloat("Blur Size", &boxBlurSize, 0.0f, 10.0f);
		ImGui::SliderFloat("Blur Separation", &boxBlurSeparation, 1.0f, 5.0f);
		ImGui::Unindent();
		ImGui::EndDisabled();
	}


	if (auto* gamma = postProcessing.GetEffect("Gamma Correction"))
	{
		ImGui::Checkbox(gamma->Name.c_str(), reinterpret_cast<bool*>(&gamma->Enabled));

		ImGui::BeginDisabled(gamma->Enabled == PostProcessingEffect::Enable::False);
		ImGui::Indent();
		ImGui::SliderFloat("Gamma", &gammaValue, 0.5f, 4.0f);
		ImGui::Unindent();
		ImGui::EndDisabled();
	}


	if (auto* chroma = postProcessing.GetEffect("Chromatic Aberration"))
	{
		ImGui::Checkbox(chroma->Name.c_str(), reinterpret_cast<bool*>(&chroma->Enabled));

		ImGui::BeginDisabled(chroma->Enabled == PostProcessingEffect::Enable::False);
		ImGui::Indent();
		ImGui::SliderFloat("Focus X", &chromaticAberrationMouseX, 0.0f, 1.0f);
		ImGui::SliderFloat("Focus Y", &chromaticAberrationMouseY, 0.0f, 1.0f);
		ImGui::Unindent();
		ImGui::EndDisabled();
	}

	if (auto* pixelization = postProcessing.GetEffect("Pixelization"))
	{
		ImGui::Checkbox(pixelization->Name.c_str(), reinterpret_cast<bool*>(&pixelization->Enabled));

		ImGui::BeginDisabled(pixelization->Enabled == PostProcessingEffect::Enable::False);
		ImGui::SliderInt("Pixel Size", &pixelSize, 1, 800);
		if ((pixelSize & 1) == 0)
		{
			pixelSize += 1; // make sure it's odd
		}
		// ImGui::Indent();
		// ImGui::Unindent();
		ImGui::EndDisabled();
	}

	ImGui::EndDisabled();

	ImGui::SeparatorText("Render Textures");


	static int		   selected_effect_index = -1;
	static const char* effect_names[]		 = { "Box Blur", "Gamma Correction", "Chromatic Aberration", "Pixelization" };
	static const char* current_effect_name	 = "None";

	if (selected_effect_index >= 0 && selected_effect_index < 4)
	{
		current_effect_name = effect_names[selected_effect_index];
	}

	if (ImGui::BeginCombo("View Effect", current_effect_name))
	{
		if (ImGui::Selectable("None", selected_effect_index == -1))
		{
			selected_effect_index = -1;
		}

		for (int i = 0; i < 4; i++)
		{
			bool is_selected = (selected_effect_index == i);
			if (ImGui::Selectable(effect_names[i], is_selected))
			{
				selected_effect_index = i;
			}
			if (is_selected)
			{
				ImGui::SetItemDefaultFocus();
			}
		}
		ImGui::EndCombo();
	}


	if (enablePostFX && selected_effect_index >= 0 && selected_effect_index < 4)
	{
		if (auto* effect = postProcessing.GetEffect(effect_names[selected_effect_index]))
		{
			if (effect->Enabled == PostProcessingEffect::Enable::True && effect->Framebuffer)
			{
				ImGui::Text("Output Texture (%s):", effect->Name.c_str());
				OpenGL::TextureHandle texture = effect->Framebuffer->GetTexture();

				const float		aspect_ratio   = static_cast<float>(default_window_size.x) / static_cast<float>(default_window_size.y);
				constexpr float display_width  = 400.0f;
				const float		display_height = display_width / aspect_ratio;

				ImGui::Image(static_cast<ImTextureRef>(texture), ImVec2(display_width, display_height), ImVec2(0, 1), ImVec2(1, 0));
			}
			else if (effect->Enabled == PostProcessingEffect::Enable::False)
			{
				ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "Effect is disabled");
			}
		}
	}
	ImGui::End();
}



================================================
FILE: source/Demo/DemoDepthPost.h
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include <SDL.h>

#include "Engine/FPS.h"
#include "Engine/GameObjectManager.h"
#include "Engine/GameState.h"
#include "Engine/Particle.h"
#include "Engine/Vec2.h"

#include "CS200/OffscreenFramebuffer.h"
#include "CS200/PostProcessingPipeline.h"
#include "OpenGL/VertexArray.h"

class DemoDepthPost : public CS230::GameState
{
public:
	DemoDepthPost() = default;
	void Load() override;
	void Update(double dt) override;
	void Unload() override;
	void Draw() override;
	void DrawImGui() override;

	gsl::czstring GetName() const override
	{
		return "Demo Depth & Post-Processing";
	}

private:
	struct BackGroundLayer
	{
		std::shared_ptr<CS230::Texture> texture;
		float							depth;
	};

	static constexpr size_t					NUM_LAYERS = 8;
	std::array<BackGroundLayer, NUM_LAYERS> background_layers{};
	static constexpr Math::ivec2			default_window_size{ 1920, 1080 };
	inline static double ratio = 1.0;

	struct Duck
	{
		Math::vec2	position;
		CS200::RGBA color;
		float		depth;
	};

	std::shared_ptr<CS230::Texture> duck_texture;

	static constexpr size_t		NUM_DUCKS = 10;
	std::array<Duck, NUM_DUCKS> ducks{};

	util::FPS FPSTracker;
	Uint32	  LastTicks = 0;

	// msaa, post-processing
	bool				 useMSAA = true;
	OffscreenFramebuffer offscreenBuffer{};
	int					 MSAASamples = 4;

	OpenGL::CompiledShader	  screenShader{};
	OpenGL::BufferHandle	  screenVBO{};
	OpenGL::VertexArrayHandle screenVAO{};
	GLsizei					  screenVertexCount = 0;

	void setupScreenTriangle();

	PostProcessingPipeline postProcessing{};

	bool enablePostFX = true;


	float boxBlurSize				= 2.0f;
	float boxBlurSeparation			= 1.0f;
	float gammaValue				= 2.2f;
	float chromaticAberrationMouseX = 0.5f;
	float chromaticAberrationMouseY = 0.5f;
	int	  pixelSize					= 5;
};


================================================
FILE: source/Engine/Animation.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Animation.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 16, 2025
*/
#include "Animation.h"
#include "Logger.h"
#include "Path.h"

CS230::Animation::Animation(const std::filesystem::path& animation_file) : current_command(0)
{
    const std::filesystem::path anm_path = assets::locate_asset(animation_file);

    if (anm_path.extension() != ".anm")
    {
        throw std::runtime_error(animation_file.generic_string() + " is not a .anm file");
    }


    std::ifstream in_file(anm_path);
    if (in_file.is_open() == false)
    {
        throw std::runtime_error("Failed to load " + animation_file.generic_string());
    }

    std::string command;
    while (in_file.eof() == false)
    {
        in_file >> command;
        if (command == "PlayFrame")
        {
            size_t frame;
            float  target_time;
            in_file >> frame;
            in_file >> target_time;

            commands.push_back(new PlayFrame(frame, static_cast<double>(target_time)));
        }
        else if (command == "Loop")
        {
            size_t loop_to_frame;
            in_file >> loop_to_frame;
            commands.push_back(new Loop(loop_to_frame));
        }
        else if (command == "End")
        {
            commands.push_back(new End());
        }
        else
        {
            Engine::GetLogger().LogError(command + " in " + animation_file.generic_string());
        }
    }
    Reset();
}

CS230::Animation::Animation() : Animation("./Assets/animations/None.anm")
{
}

CS230::Animation::~Animation()
{
    for (Command* command : commands)
    {
        delete command;
    }
    commands.clear();
}

void CS230::Animation::Update(double dt)
{
    current_frame->Update(dt);
    if (current_frame->Ended() == true)
    {
        current_frame->ResetTime();
        current_command++;
        if (commands[current_command]->Type() == CommandType::PlayFrame)
        {
            current_frame = static_cast<PlayFrame*>(commands[current_command]);
        }
        else if (commands[current_command]->Type() == CommandType::Loop)
        {
            Loop* loop_data = static_cast<Loop*>(commands[current_command]);
            current_command = loop_data->LoopIndex();
            if (commands[current_command]->Type() == CommandType::PlayFrame)
            {
                current_frame = static_cast<PlayFrame*>(commands[current_command]);
            }
            else
            {
                Engine::GetLogger().LogError("Loop does not go to PlayFrame");
                Reset();
            }
        }
        else if (commands[current_command]->Type() == CommandType::End)
        {
            ended = true;
        }
    }
}

size_t CS230::Animation::CurrentFrame()
{
    return current_frame->Frame();
}

void CS230::Animation::Reset()
{
    current_command = 0;
    ended           = false;
    current_frame   = static_cast<PlayFrame*>(commands[current_command]);
    current_frame->ResetTime();
}

bool CS230::Animation::Ended()
{
    return ended;
}

CS230::Animation::PlayFrame::PlayFrame(size_t _frame, double duration) : frame(_frame), target_time(duration), timer(0.0)
{
}

void CS230::Animation::PlayFrame::Update(double dt)
{
    timer += dt;
}

bool CS230::Animation::PlayFrame::Ended()
{
    if (timer >= target_time)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void CS230::Animation::PlayFrame::ResetTime()
{
    timer = 0.0;
}

size_t CS230::Animation::PlayFrame::Frame()
{
    return frame;
}

CS230::Animation::Loop::Loop(size_t _loop_index) : loop_index(_loop_index)
{
}

size_t CS230::Animation::Loop::LoopIndex()
{
    return loop_index;
}



================================================
FILE: source/Engine/Animation.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Animation.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 16, 2025
*/

#pragma once
#include <vector>
#include <filesystem>
#include "Engine.h"

namespace CS230 {
    class Animation {
    public:
        Animation();
        Animation(const std::filesystem::path& animation_file);
        ~Animation();

        void Update(double dt);
        size_t CurrentFrame();
        void Reset();
        bool Ended();
    private:
        enum class CommandType {
            PlayFrame,
            Loop,
            End,
        };
        class Command {
        public:
            virtual ~Command() {}
            virtual CommandType Type() = 0;
        };


        class End : public Command {
        public:
            virtual CommandType Type() override { return CommandType::End; }
        private:
        };


        class Loop : public Command {
        public:
            Loop(size_t loop_index);
            virtual CommandType Type() override { return CommandType::Loop; }
            size_t LoopIndex();
        private:
            size_t loop_index;
        };

        class PlayFrame : public Command {
        public:
            PlayFrame(size_t frame, double duration);
            virtual CommandType Type() override { return CommandType::PlayFrame; }
            void Update(double dt);
            bool Ended();
            void ResetTime();
            size_t Frame();
        private:
            size_t frame;
            double target_time;
            double timer;
        };

        size_t current_command;
        std::vector<Command*> commands;
        bool ended;
        PlayFrame* current_frame;
    };
}




================================================
FILE: source/Engine/Camera.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Camera.cpp
Project:    CS230 Engine
Author:     Jonathan Holmes
Created:    March 8, 2023
*/
#include "Camera.h"
#include "Engine.h"
#include "Matrix.h"

namespace
{
  template <typename T, typename FLOAT = double>
  void ease_to_target(T& current, const T& target, FLOAT delta_time, FLOAT weight = 1.0)
  {
	const auto easing = std::min(delta_time * weight, static_cast<FLOAT>(1.0));
	current += easing * (target - current);
  }
} // namespace

CS230::Camera::Camera(Math::rect _player_zone, size_t camera_amount)
{
  cameras.resize(camera_amount);
  for (CameraSettings& cam : cameras)
  {
	cam.player_zone = _player_zone;
	cam.position	= Math::vec2{ 0.0, 0.0 };
	cam.offset		= Math::vec2{ 0.0, 0.0 };
	cam.rotation	= 0.0;
	cam.scale		= Math::vec2{ 1.0, 1.0 };
  }
}

bool& CS230::Camera::SetFirstPersonView(size_t camera_index)
{
  return cameras[camera_index].first_person_view;
}

bool& CS230::Camera::SetAnchoring(size_t camera_index)
{
  return cameras[camera_index].anchoring;
}

bool& CS230::Camera::SetSmoothing(size_t camera_index)
{
  return cameras[camera_index].enable_smoothing;
}

void CS230::Camera::SetPosition(Math::vec2 new_position, size_t camera_index)
{
  cameras[camera_index].position			 = new_position;
  cameras[camera_index].is_position_outdated = true;
}

void CS230::Camera::SetRotation(double new_rotation, size_t camera_index)
{
  if (cameras[camera_index].first_person_view)
  {
	cameras[camera_index].rotation			   = new_rotation;
	cameras[camera_index].is_rotation_outdated = true;
  }
}

void CS230::Camera::SetScale(Math::vec2 new_scale, size_t camera_index)
{
  cameras[camera_index].scale			  = new_scale;
  cameras[camera_index].is_scale_outdated = true;
}

void CS230::Camera::SetPositionOffset(Math::vec2 new_offset, size_t camera_index)
{
  cameras[camera_index].offset				 = new_offset;
  cameras[camera_index].is_position_outdated = true;
}

const Math::vec2& CS230::Camera::GetPosition(size_t camera_index) const
{
  return cameras[camera_index].position;
}

void CS230::Camera::SetLimit(Math::irect new_limit, size_t camera_index)
{
  cameras[camera_index].limit = new_limit;
}

void CS230::Camera::Update(const Math::vec2& player_position, double dt, size_t camera_index)
{
  CameraSettings& cam = cameras[camera_index];

  // 1. Target Position Calculation Step
  //    Start based on current position, adjust target according to player zone
  Math::vec2 targetPos = cam.position;

  if (cam.anchoring)
  {
	targetPos = player_position;
  }
  else
  {
	// Player Zone Check: Adjust target position if player leaves the box
	if (player_position.x > cam.player_zone.Right() + targetPos.x)
	{
	  targetPos.x = player_position.x - cam.player_zone.Right();
	}
	if (player_position.x - targetPos.x < cam.player_zone.Left())
	{
	  targetPos.x = player_position.x - cam.player_zone.Left();
	}

	if (player_position.y > cam.player_zone.Top() + targetPos.y)
	{
	  targetPos.y = player_position.y - cam.player_zone.Top();
	}
	if (player_position.y - targetPos.y < cam.player_zone.Bottom())
	{
	  targetPos.y = player_position.y - cam.player_zone.Bottom();
	}
  }

  // World Limit Check: Ensure target position doesn't go out of map bounds
  if (targetPos.x < cam.limit.Left())
	targetPos.x = cam.limit.Left();
  if (targetPos.x > cam.limit.Right())
	targetPos.x = cam.limit.Right();
  if (targetPos.y < cam.limit.Bottom())
	targetPos.y = cam.limit.Bottom();
  if (targetPos.y > cam.limit.Top())
	targetPos.y = cam.limit.Top();


  // 2. Final Application Step (Use SetPosition)
  if (cam.enable_smoothing)
  {
	// Get current position
	Math::vec2 nextPos = GetPosition(camera_index);

	// Move nextPos slightly towards targetPos using interpolation function (Weight 5.0)
	ease_to_target(nextPos, targetPos, dt, 5.0);

	// Apply calculated position
	SetPosition(nextPos, camera_index);
  }
  else
  {
	// If smoothing is off, move to target position immediately
	// (Call only when values differ to reduce unnecessary operations)
	if (cam.position.x != targetPos.x || cam.position.y != targetPos.y)
	{
	  SetPosition(targetPos, camera_index);
	}
  }
}

Math::TransformationMatrix CS230::Camera::GetMatrix(size_t camera_index)
{
  if (cameras[camera_index].first_person_view)
  {
	if (cameras[camera_index].is_position_outdated || cameras[camera_index].is_rotation_outdated || cameras[camera_index].is_scale_outdated)
	{
	  cameras[camera_index].camera_matrix =
		Math::TranslationMatrix(cameras[camera_index].position - cameras[camera_index].offset) * Math::RotationMatrix(cameras[camera_index].rotation) * Math::ScaleMatrix(cameras[camera_index].scale);
	  cameras[camera_index].view_matrix = cameras[camera_index].camera_matrix;
	  std::swap(cameras[camera_index].view_matrix[0][1], cameras[camera_index].view_matrix[1][0]);
	  cameras[camera_index].view_matrix[0][2] =
		-(cameras[camera_index].camera_matrix[0][0] * cameras[camera_index].camera_matrix[0][2] + cameras[camera_index].camera_matrix[1][0] * cameras[camera_index].camera_matrix[1][2]);
	  cameras[camera_index].view_matrix[1][2] =
		-(cameras[camera_index].camera_matrix[0][1] * cameras[camera_index].camera_matrix[0][2] + cameras[camera_index].camera_matrix[1][1] * cameras[camera_index].camera_matrix[1][2]);
	  cameras[camera_index].is_position_outdated = false;
	  cameras[camera_index].is_rotation_outdated = false;
	  cameras[camera_index].is_scale_outdated	 = false;
	}
  }
  else
  {
	if (cameras[camera_index].is_position_outdated || cameras[camera_index].is_scale_outdated)
	{
	  cameras[camera_index].camera_matrix =
		Math::TranslationMatrix(cameras[camera_index].position - cameras[camera_index].offset) * Math::ScaleMatrix(cameras[camera_index].scale);
	  cameras[camera_index].view_matrix = cameras[camera_index].camera_matrix;
	  std::swap(cameras[camera_index].view_matrix[0][1], cameras[camera_index].view_matrix[1][0]);
	  cameras[camera_index].view_matrix[0][2] =
		-(cameras[camera_index].camera_matrix[0][0] * cameras[camera_index].camera_matrix[0][2] + cameras[camera_index].camera_matrix[1][0] * cameras[camera_index].camera_matrix[1][2]);
	  cameras[camera_index].view_matrix[1][2] =
		-(cameras[camera_index].camera_matrix[0][1] * cameras[camera_index].camera_matrix[0][2] + cameras[camera_index].camera_matrix[1][1] * cameras[camera_index].camera_matrix[1][2]);
	  cameras[camera_index].is_position_outdated = false;
	  cameras[camera_index].is_scale_outdated	 = false;
	}
	// if(cameras[camera_index].is_position_outdated){
	//     cameras[camera_index].camera_matrix = Math::TranslationMatrix(cameras[camera_index].position - cameras[camera_index].offset) ;
	//     cameras[camera_index].view_matrix = cameras[camera_index].camera_matrix;
	//     cameras[camera_index].view_matrix[0][2] = -(cameras[camera_index].camera_matrix[0][0] * cameras[camera_index].camera_matrix[0][2] + cameras[camera_index].camera_matrix[1][0] *
	//     cameras[camera_index].camera_matrix[1][2]); cameras[camera_index].view_matrix[1][2] = -(cameras[camera_index].camera_matrix[0][1] * cameras[camera_index].camera_matrix[0][2] +
	//     cameras[camera_index].camera_matrix[1][1] * cameras[camera_index].camera_matrix[1][2]); cameras[camera_index].is_position_outdated = false;
	// }
  }
  return cameras[camera_index].view_matrix;
}



================================================
FILE: source/Engine/Camera.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Camera.h
Project:    CS230 Engine
Author:     Jonathan Holmes
Created:    March 8, 2023
*/

#pragma once

#include "Component.h"
#include "Matrix.h"
#include "Rect.h"
#include "Vec2.h"
#include <vector>
namespace CS230
{
	class Camera : public Component
	{
	public:
		Camera(Math::rect player_zone, size_t camera_amount = 1);
		bool&			  SetFirstPersonView(size_t camera_index = 0);
		bool&			  SetAnchoring(size_t camera_index = 0);
		bool&             SetSmoothing(size_t camera_index = 0);
		void			  SetPosition(Math::vec2 new_position, size_t camera_index = 0);
		void			  SetRotation(double new_rotation, size_t camera_index = 0);
		void			  SetScale(Math::vec2 new_scale, size_t camera_index = 0);
		void			  SetPositionOffset(Math::vec2 new_offset, size_t camera_index = 0);
		const Math::vec2& GetPosition(size_t camera_index = 0) const;
		void			  SetLimit(Math::irect new_limit, size_t camera_index = 0);
		using Component::Update; // say i'll use this version too, so don't hide anymore
		void			  Update(const Math::vec2& player_position, double dt, size_t camera_index = 0);
		Math::TransformationMatrix GetMatrix(size_t camera_index = 0);

	private:
		struct CameraSettings
		{
			Math::irect				   limit;
			bool					   first_person_view{ true };
			bool					   anchoring{ true };
			bool                       enable_smoothing{ true };
			Math::vec2				   position;
			Math::vec2				   offset;
			bool					   is_position_outdated{ true };
			double					   rotation;
			bool					   is_rotation_outdated{ true };
			Math::vec2				   scale;
			bool					   is_scale_outdated{ true };
			Math::rect				   player_zone;
			Math::TransformationMatrix camera_matrix{};
			Math::TransformationMatrix view_matrix{};
		} ;
		std::vector<CameraSettings> cameras;
	};
}



================================================
FILE: source/Engine/Collision.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Component.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 17, 2025
*/

#include "Collision.h"
#include "../CS200/IRenderer2D.h"
#include "../CS200/RGBA.h"
#include "Engine.h"
#include "Logger.h"
#include "TextureManager.h"

namespace CS230
{
    RectCollision::RectCollision(Math::irect _boundary, CS230::GameObject* _object) : boundary(_boundary), object(_object)
    {
    }

    void RectCollision::Draw(Math::TransformationMatrix display_matrix, float depth)
    {
        /*const double render_height = rlGetFramebufferHeight();

        bottom_left.y = bottom_left.y * -1 + render_height;
        bottom_right.y = bottom_right.y * -1 + render_height;
        top_left.y = top_left.y * -1 + render_height;
        top_right.y = top_right.y * -1 + render_height;


        DrawLine(int(top_left.x), int(top_left.y), int(top_right.x), int(top_right.y), WHITE);
        DrawLine(int(bottom_right.x), int(bottom_right.y), int(top_right.x), int(top_right.y), WHITE);
        DrawLine(int(bottom_right.x), int(bottom_right.y), int(bottom_left.x), int(bottom_left.y), WHITE);
        DrawLine(int(top_left.x), int(top_left.y), int(bottom_left.x), int(bottom_left.y), WHITE);*/
		auto& texture_manager = Engine::GetTextureManager();
		//texture_manager.SwitchRenderer(CS230::TextureManager::RendererType::Immediate);
        Math::rect world_boundary = WorldBoundary();
		auto	   renderer2d	  = texture_manager.GetRenderer2D();

        // [[maybe_unused]] Math::vec2 bottom_left  = /*display_matrix * */ Math::vec2{ world_boundary.Left(), world_boundary.Bottom() };
        // [[maybe_unused]] Math::vec2 bottom_right = /*display_matrix * */ Math::vec2{ world_boundary.Right(), world_boundary.Bottom() };
        // [[maybe_unused]] Math::vec2 top_left     = /*display_matrix * */ Math::vec2{ world_boundary.Left(), world_boundary.Top() };
        // [[maybe_unused]] Math::vec2 top_right    = /*display_matrix * */ Math::vec2{ world_boundary.Right(), world_boundary.Top() };

        // const auto center_matrix = display_matrix * Math::TranslationMatrix(world_boundary.Center());

        renderer2d->DrawRectangle(display_matrix*Math::TranslationMatrix(world_boundary.Center())*Math::ScaleMatrix(world_boundary.Size()), CS200::CLEAR, CS200::BLACK, line_width,depth);
    }

    Math::rect RectCollision::WorldBoundary()
    {
        return { object->GetMatrix() * static_cast<Math::vec2>(boundary.point_1), object->GetMatrix() * static_cast<Math::vec2>(boundary.point_2) };
    }

    bool RectCollision::IsCollidingWith(GameObject* other_object)
    {
        Collision* other_collider = other_object->GetGOComponent<Collision>();


        if (other_collider == nullptr)
        {
            // Engine::GetLogger().LogError("No collision component found");
            return false;
        }


        if (other_collider->Shape() != CollisionShape::Rect)
        {
            Engine::GetLogger().LogError("Rect vs unsupported type");
            return false;
        }

        Math::rect rectangle_1 = WorldBoundary();
        Math::rect rectangle_2 = dynamic_cast<RectCollision*>(other_collider)->WorldBoundary();

        if (!((rectangle_1.Right() <= rectangle_2.Left()) || (rectangle_1.Left() >= rectangle_2.Right()) || (rectangle_1.Top() <= rectangle_2.Bottom()) || (rectangle_1.Bottom() >= rectangle_2.Top())))
        {
            return true;
        }
        return false;
    }

    bool RectCollision::IsCollidingWith(Math::vec2 point)
    {
        Math::rect rectangle = WorldBoundary();
        if (!((rectangle.Left() > point.x) || (rectangle.Right() < point.x) || (rectangle.Top() < point.y) || (rectangle.Bottom() > point.y)))
        {
            return true;
        }
        return false;
    }

    CircleCollision::CircleCollision(double _radius, GameObject* _object) :  object(_object), radius(_radius)
    {
    }

    void CircleCollision::Draw(Math::TransformationMatrix display_matrix,float depth)
    {
        // const double render_height = rlGetFramebufferHeight();
        // Math::vec2 transformed_position = display_matrix * object->GetPosition();
        // transformed_position.y = transformed_position.y * -1 + render_height;
        // const int num_segments = 36;
        // Math::vec2 previous_vertex;
        // for (int i = 0; i <= num_segments + 1; i++) {
        //     double theta = 2.0 * PI * static_cast<double>(i) / static_cast<double>(num_segments);
        //     Math::vec2 vertex = {
        //         transformed_position.x + GetRadius() * std::cos(theta),
        //         transformed_position.y + GetRadius() * std::sin(theta)
        //     };
        //     if (i > 0) {
        //         DrawLine(int(vertex.x), int(vertex.y), int(previous_vertex.x), int(previous_vertex.y), WHITE);
        //     }
        //     previous_vertex = vertex;
        // }
		auto& texture_manager = Engine::GetTextureManager();
		//texture_manager.SwitchRenderer(CS230::TextureManager::RendererType::Immediate);
        const auto transform = display_matrix * Math::TranslationMatrix(object->GetPosition()) * Math::ScaleMatrix(2 * GetRadius());
		auto	   renderer2d = texture_manager.GetRenderer2D();
		renderer2d->DrawCircle(transform, CS200::CLEAR, CS200::BLACK, line_width, depth);
    }

    double CircleCollision::GetRadius()
    {
        return std::min(object->GetScale().x, object->GetScale().x) * radius;
    }

    bool CircleCollision::IsCollidingWith(GameObject* other_object)
    {
        Collision* other_collider = other_object->GetGOComponent<Collision>();


        if (other_collider == nullptr)
        {
            // Engine::GetLogger().LogError("No collision component found");
            return false;
        }


        if (other_collider->Shape() != CollisionShape::Circle)
        {
            Engine::GetLogger().LogError("Circle vs unsupported type");
            return false;
        }
        double     _radius        = GetRadius();
        Math::vec2 position       = object->GetPosition();
        double     other_radius   = dynamic_cast<CircleCollision*>(other_collider)->GetRadius();
        Math::vec2 other_position = other_object->GetPosition();

        if (((position.x - other_position.x) * (position.x - other_position.x) + (position.y - other_position.y) * (position.y - other_position.y)) <
            ((_radius + other_radius) * (_radius + other_radius)))
        {
            return true;
        }
        return false;
    }

    bool CircleCollision::IsCollidingWith(Math::vec2 point)
    {
        double     _radius  = GetRadius();
        Math::vec2 position = object->GetPosition();

        if (((position.x - point.x) * (position.x - point.x) + (position.y - point.y) * (position.y - point.y)) < (_radius * _radius))
        {
            return true;
        }
        return false;
    }
}



================================================
FILE: source/Engine/Collision.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Collision.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 18, 2025
*/
#pragma once
#include "Component.h"
#include "Rect.h"
#include "GameObject.h"
#include "Matrix.h"

namespace Math {
    class TransformationMatrix;
}

namespace CS230 {
    class GameObject;

    class Collision : public Component {
    public:
        enum class CollisionShape {
            Rect,
            Circle
        };
        virtual CollisionShape Shape() = 0;
        virtual void Draw(Math::TransformationMatrix display_matrix,float depth = 0.f) = 0;
        virtual bool IsCollidingWith(GameObject* other_object) = 0;
        virtual bool IsCollidingWith(Math::vec2 point) = 0;
    };

    class RectCollision : public Collision {
    public:
        RectCollision(Math::irect _boundary, GameObject* _object);
        CollisionShape Shape() override {
            return CollisionShape::Rect;
        }
        void Draw(Math::TransformationMatrix display_matrix, float depth) override;
        Math::rect WorldBoundary();
        bool IsCollidingWith(GameObject* other_object) override;
        bool IsCollidingWith(Math::vec2 point) override;
    private:
        Math::irect boundary;
        GameObject* object;
        
        static constexpr double line_width = 2.0;
    };

    class CircleCollision : public Collision {
    public:
        CircleCollision(double radius, GameObject* object);
        CollisionShape Shape() override {
            return CollisionShape::Circle;
        }

        void Draw(Math::TransformationMatrix display_matrix,float depth) override;
        double GetRadius();
        bool IsCollidingWith(GameObject* other_object) override;
        bool IsCollidingWith(Math::vec2 point) override;
    private:
        GameObject* object;
        double radius;
        static constexpr double line_width = 5.0;
    };

}




================================================
FILE: source/Engine/Component.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Component.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 17, 2025
*/
#pragma once

namespace CS230 {
    class Component {
    public:
        virtual ~Component() {};
        virtual void Update([[maybe_unused]] double dt) {};
    };
}




================================================
FILE: source/Engine/ComponentManager.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  ComponentManager.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 17, 2025
*/
#pragma once
#include <algorithm>
#include <vector>
#include <stdexcept>

#include "Component.h"

namespace CS230
{
    class ComponentManager
    {
    public:
        ~ComponentManager()
        {
            Clear();
        }

        void UpdateAll(double dt)
        {
            for (Component* component : components)
            {
                component->Update(dt);
            }
        }

        void AddComponent(Component* component)
        {
            components.push_back(component);
        }

        template <typename T>
        T* GetComponent()
        {
            for (Component* component : components)
            {
                T* ptr = dynamic_cast<T*>(component);
                if (ptr != nullptr)
                {
                    return ptr;
                }
            }
            return nullptr;
        }

        template <typename T>
        void RemoveComponent()
        {
            auto it = std::find_if(components.begin(), components.end(), [](Component* element) { return (dynamic_cast<T*>(element) != nullptr); });
            delete *it;
            components.erase(it);
        }

        void Clear()
        {
            for (Component* component : components)
            {
                delete component;
            }
            components.clear();
        }

    private:
        std::vector<Component*> components;
    };
}



================================================
FILE: source/Engine/Engine.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Engine.h"
#include "CS200/ImGuiHelper.h"
#include "CS200/ImmediateRenderer2D.h"
#include "CS200/NDC.h"
#include "CS200/RenderingAPI.h"
#include "FPS.h"
#include "Font.h"
#include "GameState.h"
#include "GameStateManager.h"
#include "Input.h"
#include "Logger.h"
#include "TextManager.h"
#include "TextureManager.h"
#include "Timer.h"
#include "Window.h"

#include <chrono>

// Pimpl implementation class
class Engine::Impl
{
public:
	Impl()
		:
#ifdef DEVELOPER_VERSION
		  logger(CS230::Logger::Severity::Debug, true, std::chrono::system_clock::now())
#else
		  logger(CS230::Logger::Severity::Debug, true, std::chrono::system_clock::now())
#endif
		  ,
		  window{}, input{}
	{
	}

	CS230::Logger			logger;
	CS230::Window			window{};
	CS230::Input			input{};
	ImGuiHelper::Viewport	viewport{};
	util::FPS				fps{};
	util::Timer				timer{};
	WindowEnvironment		environment{};
	CS230::GameStateManager gameStateManager{};
	// CS200::IRenderer2D*		renderer2D = nullptr;
	CS230::TextureManager	textureManager{};
	TextManager				textManager{};
};

Engine& Engine::Instance()
{
	static Engine instance;
	return instance;
}

CS230::Logger& Engine::GetLogger()
{
	return Instance().impl->logger;
}

CS230::Window& Engine::GetWindow()
{
	return Instance().impl->window;
}

CS230::Input& Engine::GetInput()
{
	return Instance().impl->input;
}

const WindowEnvironment& Engine::GetWindowEnvironment()
{
	return Instance().impl->environment;
}

CS230::GameStateManager& Engine::GetGameStateManager()
{
	return Instance().impl->gameStateManager;
}

// CS200::IRenderer2D& Engine::GetRenderer2D()
// {
// 	return Instance().impl->renderer2D;
// }

CS230::TextureManager& Engine::GetTextureManager()
{
	return Instance().impl->textureManager;
}

TextManager& Engine::GetTextManager()
{
	return Instance().impl->textManager;
}

void Engine::Start(std::string_view window_title)
{
	impl->logger.LogEvent("Engine Started");
#if defined(DEVELOPER_VERSION)
	impl->logger.LogEvent("Developer Build");
#endif
	impl->window.Start(window_title);
	auto& window = impl->window;

	const auto window_size = window.GetSize();
	impl->viewport		   = { 0, 0, window_size.x, window_size.y };
	CS200::RenderingAPI::SetViewport(window_size);
	impl->environment.DisplaySize = { static_cast<double>(window_size.x), static_cast<double>(window_size.y) };
	ImGuiHelper::Initialize(window.GetSDLWindow(), window.GetGLContext());
	window.SetEventCallback(ImGuiHelper::FeedEvent);
    impl->textureManager.Init();
	// impl->renderer2D.Init();
	impl->timer.ResetTimeStamp();
	impl->textManager.Init();
}

void Engine::Stop()
{
    impl->textureManager.Shutdown();
	// impl->renderer2D.Shutdown();
	impl->gameStateManager.Clear();
	ImGuiHelper::Shutdown();
	impl->logger.LogEvent("Engine Stopped");
}

void Engine::Update()
{
	updateEnvironment();

	// service update
	auto& environment = impl->environment;
	impl->window.Update();
	impl->input.Update();

	auto& state_manager = impl->gameStateManager;
	state_manager.Update(environment.DeltaTime);
	const auto		  viewport		= impl->viewport;
	const Math::ivec2 viewport_size = { viewport.width, viewport.height };
	CS200::RenderingAPI::SetViewport(viewport_size, { viewport.x, viewport.y });
	state_manager.Draw();
	impl->viewport = ImGuiHelper::Begin();
	state_manager.DrawImGui();
	ImGuiHelper::End();
}

bool Engine::HasGameEnded()
{
	return impl->window.IsClosed() || impl->gameStateManager.HasGameEnded();
}

Engine::Engine() : impl(new Impl())
{
}

Engine::~Engine()
{
	delete impl;
}

void Engine::updateEnvironment()
{
	auto& environment	  = impl->environment;
	environment.DeltaTime = impl->timer.GetElapsedSeconds();
	impl->timer.ResetTimeStamp();
	environment.ElapsedTime += environment.DeltaTime;
	++environment.FrameCount;
	impl->fps.Update(environment.DeltaTime);
	environment.FPS				  = impl->fps;
	const auto viewport			  = impl->viewport;
	impl->environment.DisplaySize = { static_cast<double>(viewport.width), static_cast<double>(viewport.height) };
}



================================================
FILE: source/Engine/Engine.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Vec2.h"
#include <filesystem>
#include <gsl/gsl>
#include <memory>
#include <string_view>

namespace CS230
{
    class Logger;
    class Window;
    class Input;
    class GameState;
    class GameStateManager;
    class TextureManager;
    class Font;

}

namespace CS200
{
    class IRenderer2D;
}

class TextManager;
class EventBus;
class CombatSystem;

/**
 * \brief Runtime information about the window and application state
 *
 * WindowEnvironment provides access to essential runtime metrics and window
 * properties that are commonly needed by game logic, rendering systems, and
 * debugging tools. This information is updated each frame to reflect the
 * current state of the application.
 *
 * Timing Information:
 * - DeltaTime: Time elapsed since the last frame (for frame-rate independent movement)
 * - ElapsedTime: Total time since application started (for animations and effects)
 * - FrameCount: Total number of frames rendered (for debugging and profiling)
 * - FPS: Current frames per second (for performance monitoring)
 *
 * Display Information:
 * - DisplaySize: Current viewport dimensions in pixels (for coordinate calculations)
 *
 * Common use cases:
 * - Frame-rate independent animations and movement
 * - Performance monitoring and debugging
 * - UI scaling based on viewport size
 * - Time-based effects and animations
 */
struct WindowEnvironment
{
    int        FPS         = 0;   ///< Current frames per second
    uint64_t   FrameCount  = 0;   ///< Total frames rendered since start
    double     DeltaTime   = 0.0; ///< Time in seconds since last frame
    double     ElapsedTime = 0.0; ///< Total time in seconds since application start
    Math::vec2 DisplaySize{};     ///< Current viewport size in pixels
};

/**
 * \brief Central application engine managing all core systems and subsystems
 *
 * Engine serves as the main application framework that coordinates all major
 * subsystems including windowing, input handling, rendering, game state management,
 * and resource management. It implements the singleton pattern to provide global
 * access to these systems while maintaining proper initialization order and
 * cleanup procedures.
 *
 * Architecture and Design:
 * - Singleton pattern ensures single engine instance across the application
 * - Pimpl idiom hides implementation details and reduces compilation dependencies
 * - Static accessor methods provide convenient access to subsystems
 * - Manages complete application lifecycle from startup to shutdown
 *
 * Core Subsystems:
 * - Window: SDL-based window management and OpenGL context creation
 * - Input: Keyboard, mouse, and controller input handling
 * - Renderer2D: High-level 2D graphics rendering system
 * - GameStateManager: State machine for different application screens/modes
 * - TextureManager: Resource management for texture assets
 * - Logger: Debug and event logging system
 *
 * Application Lifecycle:
 * 1. Start(): Initialize all subsystems and create window
 * 2. Update(): Process one frame of the main loop (input, logic, rendering)
 * 3. HasGameEnded(): Check if application should terminate
 * 4. Stop(): Clean shutdown of all subsystems
 *
 * The engine handles the complex initialization order required by modern
 * graphics applications, including OpenGL context creation, ImGui setup,
 * and proper resource management throughout the application lifecycle.
 */

class Engine
{
public:
    /**
     * \brief Get the singleton Engine instance
     * \return Reference to the single Engine instance
     *
     * Provides access to the singleton Engine instance, creating it on first
     * access using lazy initialization. This ensures the engine is available
     * throughout the application lifetime while maintaining single-instance
     * semantics.
     *
     * The singleton is implemented with a static local variable, providing
     * thread-safe initialization in C++11 and later, and automatic cleanup
     * when the application terminates.
     */
    static Engine& Instance();

    /**
     * \brief Access the application logging system
     * \return Reference to the Logger instance for debug and event logging
     *
     * Provides access to the centralized logging system for debug output,
     * error reporting, and event tracking. The logger configuration differs
     * between development and release builds, with more verbose output
     * available in development versions.
     *
     * Common uses:
     * - Debug information and variable values
     * - Error reporting and exception details
     * - Performance metrics and timing information
     * - Application lifecycle events
     */
    static CS230::Logger& GetLogger();

    /**
     * \brief Access the window management system
     * \return Reference to the Window instance for display and context management
     *
     * Provides access to the window system that manages the application window,
     * OpenGL context, and display properties. This includes window creation,
     * resizing, fullscreen control, and event handling integration.
     *
     * Window capabilities:
     * - Window creation and destruction
     * - OpenGL context management
     * - Display mode and resolution control
     * - Event system integration
     * - Cross-platform window handling
     */
    static CS230::Window& GetWindow();

    /**
     * \brief Access the input handling system
     * \return Reference to the Input instance for keyboard, mouse, and controller input
     *
     * Provides access to the unified input system that handles all user input
     * devices including keyboard, mouse, and game controllers. The system
     * provides both immediate state queries and event-based input handling.
     *
     * Input capabilities:
     * - Keyboard state and key press/release events
     * - Mouse position, button states, and scroll wheel
     * - Game controller support with analog and digital inputs
     * - Input mapping and configuration
     * - Frame-coherent input state management
     */
    static CS230::Input& GetInput();

    /**
     * \brief Access current window and timing environment information
     * \return Const reference to WindowEnvironment with current frame data
     *
     * Provides read-only access to essential runtime information including
     * timing data, frame statistics, and display properties. This information
     * is updated each frame and is commonly used for frame-rate independent
     * calculations and performance monitoring.
     *
     * Available information:
     * - Delta time for frame-rate independent movement
     * - Total elapsed time for animations and effects
     * - Current FPS for performance monitoring
     * - Frame count for debugging and profiling
     * - Current viewport size for coordinate calculations
     */
    static const WindowEnvironment& GetWindowEnvironment();

    /**
     * \brief Access the game state management system
     * \return Reference to GameStateManager for application state control
     *
     * Provides access to the state machine that manages different application
     * modes such as menus, gameplay, pause screens, and loading states. The
     * state manager handles transitions between states and ensures proper
     * initialization and cleanup of state-specific resources.
     *
     * State management features:
     * - State transitions with proper lifecycle management
     * - State stack for overlay states (pause menus, dialogs)
     * - Automatic resource management per state
     * - Event propagation to active states
     * - Clean separation of application logic by state
     */
    static CS230::GameStateManager& GetGameStateManager();

    /**
     * \brief Access the 2D rendering system
     * \return Reference to IRenderer2D for all 2D graphics operations
     *
     * Provides access to the high-level 2D rendering system that abstracts
     * OpenGL complexity and provides efficient rendering of 2D graphics
     * primitives. The renderer handles batching, state management, and
     * coordinate system transformations automatically.
     *
     * Rendering capabilities:
     * - Sprite and texture rendering with transformations
     * - Primitive shapes (rectangles, circles, lines)
     * - Text rendering with font support
     * - Efficient batch rendering for performance
     * - Camera and viewport transformations
     * - Blend modes and rendering effects
     */
    // static CS200::IRenderer2D& GetRenderer2D();

    /**
     * \brief Access the texture resource management system
     * \return Reference to TextureManager for texture loading and caching
     *
     * Provides access to the texture management system that handles loading,
     * caching, and lifecycle management of texture resources. The manager
     * prevents duplicate loading of textures and ensures efficient GPU
     * memory usage.
     *
     * Texture management features:
     * - Automatic texture loading from various image formats
     * - Reference counting and automatic cleanup
     * - Texture caching to prevent duplicate resources
     * - Efficient GPU memory management
     * - Support for different texture formats and properties
     */
    static CS230::TextureManager& GetTextureManager();

    static TextManager& GetTextManager();


public:
    /**
     * \brief Initialize and start the engine with all subsystems
     * \param window_title Title to display in the window title bar
     *
     * Performs complete engine initialization including window creation, OpenGL
     * context setup, subsystem initialization, and resource loading. This must
     * be called before any other engine operations and establishes the foundation
     * for all subsequent application functionality.
     *
     * Initialization sequence:
     * - Creates application window with OpenGL context
     * - Initializes OpenGL state and rendering API
     * - Sets up ImGui for debugging and development UI
     * - Initializes 2D renderer and graphics systems
     * - Configures input handling and event processing
     * - Starts timing systems for frame rate calculation
     *
     * The function handles the complex dependencies between subsystems and
     * ensures everything is properly configured before the application begins
     * its main execution loop.
     *
     * Error handling:
     * If initialization fails, the function may throw exceptions or log
     * critical errors. The application should handle these cases appropriately.
     */
    void Start(std::string_view window_title);

    /**
     * \brief Shutdown the engine and clean up all resources
     *
     * Performs orderly shutdown of all engine subsystems, ensuring proper
     * cleanup of resources and graceful termination. This should be called
     * when the application is ready to exit, typically after the main loop
     * has ended.
     *
     * Shutdown sequence:
     * - Cleans up 2D renderer and graphics resources
     * - Clears all game states and their resources
     * - Shuts down ImGui and development tools
     * - Releases OpenGL context and window resources
     * - Performs final logging and cleanup
     *
     * The shutdown process ensures that all GPU resources are properly
     * released and that the application can terminate cleanly without
     * resource leaks or system instability.
     */
    void Stop();

    /**
     * \brief Process one frame of the application main loop
     *
     * Executes a complete frame cycle including input processing, game logic
     * updates, rendering operations, and timing calculations. This function
     * should be called repeatedly in the main application loop until the
     * application is ready to terminate.
     *
     * Frame processing sequence:
     * - Updates timing information and frame statistics
     * - Processes window events and input state
     * - Updates the current game state logic
     * - Sets up rendering viewport and coordinate systems
     * - Renders the current game state with 2D graphics
     * - Handles ImGui rendering for development tools
     * - Prepares for the next frame
     *
     * The function handles the coordination between all subsystems and
     * ensures that each frame is processed consistently and efficiently.
     * It also manages the rendering pipeline and coordinate system
     * transformations automatically.
     */
    void Update();

    /**
     * \brief Check if the application should terminate
     * \return True if the application should exit, false to continue running
     *
     * Determines whether the application main loop should continue or terminate
     * based on window close events, user input, or game state conditions.
     * This is typically checked after each Update() call to decide whether
     * to continue the main loop.
     *
     * Termination conditions:
     * - User closes the window (clicking X button or Alt+F4)
     * - Game state manager signals application end
     * - Critical errors that require application termination
     *
     * The function provides a clean way to check for termination conditions
     * without requiring direct access to window or state management internals.
     */
    bool HasGameEnded();

private:
    // Forward declaration for Pimpl (Pointer to Implementation) idiom
    // This hides implementation details and reduces compilation dependencies
    class Impl;
    gsl::owner<Impl*> impl = nullptr;

private:
    // Singleton pattern: private constructor and destructor
    // prevent external instantiation and ensure single instance
    Engine();
    ~Engine();

    // Internal method for updating frame timing and window environment
    // Called each frame to maintain current runtime statistics
    void updateEnvironment();
};



================================================
FILE: source/Engine/Error.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine.h"
#include "Logger.h"
#include <filesystem>
#include <source_location>
#include <sstream>
#include <utility>

namespace details
{
    template <typename... Messages>
    [[noreturn]] void internal_throw_report_and_throw_error(std::source_location caller_location, Messages&&... more_messages)
    {
        std::ostringstream error_message_stream;
        error_message_stream << '{' << std::filesystem::path(caller_location.file_name()).filename().string() << "}(" << caller_location.line() << ") : " << caller_location.function_name() << '\n';
        (error_message_stream << ... << std::forward<Messages>(more_messages));
        const auto message_string = error_message_stream.str();
        Engine::GetLogger().LogError(message_string);
        throw std::runtime_error{ message_string };
    }
}

template <typename M1>
[[noreturn]] void throw_error_message(M1&& m1, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1));
}

template <typename M1, typename M2>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1), std::forward<M2>(m2));
}

template <typename M1, typename M2, typename M3>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3));
}

template <typename M1, typename M2, typename M3, typename M4>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5, typename M6>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, M6&& m6, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5), std::forward<M6>(m6));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, M6&& m6, M7&& m7, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(
        caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5), std::forward<M6>(m6), std::forward<M7>(m7));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, M6&& m6, M7&& m7, M8&& m8, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(
        caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5), std::forward<M6>(m6), std::forward<M7>(m7),
        std::forward<M8>(m8));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8, typename M9>
[[noreturn]] void throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, M6&& m6, M7&& m7, M8&& m8, M9&& m9, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(
        caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5), std::forward<M6>(m6), std::forward<M7>(m7), std::forward<M8>(m8),
        std::forward<M9>(m9));
}

template <typename M1, typename M2, typename M3, typename M4, typename M5, typename M6, typename M7, typename M8, typename M9, typename M10>
[[noreturn]] void
    throw_error_message(M1&& m1, M2&& m2, M3&& m3, M4&& m4, M5&& m5, M6&& m6, M7&& m7, M8&& m8, M9&& m9, M10&& m10, std::source_location caller_location = std::source_location::current())
{
    details::internal_throw_report_and_throw_error(
        caller_location, std::forward<M1>(m1), std::forward<M2>(m2), std::forward<M3>(m3), std::forward<M4>(m4), std::forward<M5>(m5), std::forward<M6>(m6), std::forward<M7>(m7), std::forward<M8>(m8),
        std::forward<M9>(m9), std::forward<M10>(m10));
}



================================================
FILE: source/Engine/Font.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Font.h"

#include "CS200/Image.h"
#include "Engine.h"
#include "Error.h"
#include "Matrix.h"
#include "Path.h"
#include "TextureManager.h"
#include <algorithm>
#include <stb_image.h>

/*
 * 1. Load font texture and parse character boundaries during construction
 * 2. Measure text dimensions for layout calculations
 * 3. Render text to texture or directly to screen using character sprites
 * 4. Support for colored text and transformation matrices
 */
namespace CS230
{
    Font::Font(const std::filesystem::path& file_name) : texture(file_name), image(file_name /*std::filesystem::path("Assets/Test.png")*/, is_image_flipped)
    {
        //  * Font Image Requirements:
        //  * - Characters arranged horizontally in a single row
        //  * - First pixel must be white (0xFFFFFFFF) as a format marker


        /*[[maybe_unused]] const auto _00       = GetPixel({ 0, 0 });
        [[maybe_unused]] const auto _00_array = CS200::ColorArray(_00);

        [[maybe_unused]] const auto _10       = GetPixel({ 1, 0 });
        [[maybe_unused]] const auto _10_array = CS200::ColorArray(_10);

        [[maybe_unused]] const auto _20       = GetPixel({ 2, 0 });
        [[maybe_unused]] const auto _20_array = CS200::ColorArray(_20);

        [[maybe_unused]] const auto _30       = GetPixel({ 3, 0 });
        [[maybe_unused]] const auto _30_array = CS200::ColorArray(_30);

        [[maybe_unused]] const auto _01       = GetPixel({ 0, 1 });
        [[maybe_unused]] const auto _01_array = CS200::ColorArray(_01);

        [[maybe_unused]] const auto _11       = GetPixel({ 1, 1 });
        [[maybe_unused]] const auto _11_array = CS200::ColorArray(_11);

        [[maybe_unused]] const auto _21       = GetPixel({ 2, 1 });
        [[maybe_unused]] const auto _21_array = CS200::ColorArray(_21);

        [[maybe_unused]] const auto _31       = GetPixel({ 3, 1 });
        [[maybe_unused]] const auto _31_array = CS200::ColorArray(_31);

        [[maybe_unused]] const auto _02       = GetPixel({ 0, 2 });
        [[maybe_unused]] const auto _02_array = CS200::ColorArray(_02);

        [[maybe_unused]] const auto _12       = GetPixel({ 1, 2 });
        [[maybe_unused]] const auto _12_array = CS200::ColorArray(_12);

        [[maybe_unused]] const auto _22       = GetPixel({ 2, 2 });
        [[maybe_unused]] const auto _22_array = CS200::ColorArray(_22);

        [[maybe_unused]] const auto _32       = GetPixel({ 3, 2 });
        [[maybe_unused]] const auto _32_array = CS200::ColorArray(_32);*/


        if (GetPixel({ 0, 0 }) == CS200::WHITE)
        {
            FindCharRects();
        }
        else
        {
            Engine::GetLogger().LogError("Font " + file_name.string() + " texture has wrong format!");
            throw std::runtime_error("Font fromat error");
        }
        //  * - Color changes between characters indicate boundaries
        //  * - Characters cover ASCII range from space (' ') to 'z'
        //  * - Image should contain exactly the expected number of characters
        //  *
        //  * Parsing Process:
        //  * The constructor scans the top row of pixels to detect color changes,
        //  * which indicate character boundaries. Each character's rectangular
        //  * region is calculated and stored for later use during text rendering.
        //  *
        //  * Error Handling:
        //  * If the font file is malformed (wrong format, missing characters, or
        //  * incorrect structure), the constructor will throw an error to indicate
        //  * the problem. This ensures that only valid fonts are used for rendering.
    }

    std::shared_ptr<Texture> Font::PrintToTexture(const std::string& text, CS200::RGBA color)
    {
        const auto&       window_environment = Engine::GetWindowEnvironment();
        //  * Advanced Caching System:
        //  * - Cache key: Combination of text string and color (format: "text_0xCOLOR")
        const std::string cache_key{ text + std::string("_0x") + std::to_string(color) };

        //  * - Frame tracking: Each cached texture records when it was last accessed
        for (auto it = textures.begin(); it != textures.end();)
        {
            // ++(it->second.time);
            //  * - Reference counting: Uses shared_ptr for automatic memory management

            //  * - Intelligent cleanup: Removes old textures only when they have single reference and are older than 60 frames
            if ((window_environment.FrameCount - it->second.timestamp) > 60 && it->second.texture.use_count() == 1)
            {
                it = textures.erase(it);
            }
            else
            {
                ++it;
            }
        }

        //  * - Performance optimization: Eliminates redundant text rendering operations

        //          * Caching Strategy:
        //  * 1. Check cache using generated key (text + color combination)
        //  * 2. If found: Update last-used frame timestamp and return cached texture
        //  * 3. If not found: Create new texture, cache it, and return
        //  * 4. Periodic cleanup: Remove textures older than 60 frames with reference count of 1

        if (textures.find(cache_key) == textures.end())
        {
            //          * Rendering Process (for new textures):
            //  * 1. Measure total text dimensions to determine optimal texture size
            const Math::ivec2 text_size = MeasureText(text /*std::string("hello")*/);

            //  * 2. Create render target texture using TextureManager
            auto& texture_manager = Engine::GetTextureManager();
            texture_manager.StartRenderTextureMode(text_size.x, text_size.y);
            Math::TransformationMatrix matrix{};
            for (const char c : text /*std::string("hello")*/)
            {
                DrawChar(matrix, c, color);
            }
            auto target_texture = texture_manager.EndRenderTextureMode();
            //  * 3. Render each character from font atlas to the target texture

            //  * 4. Store in cache with current frame timestamp
            //  * 5. Return shared_ptr for client use

            textures[cache_key] = { window_environment.FrameCount, target_texture };

            Engine::GetLogger().LogEvent("Loading Texture: " + text);
        }
        else
        {
            textures[cache_key].timestamp = window_environment.FrameCount;
        }
        return textures[cache_key].texture;
    }

    void Font::FindCharRects()
    {
        CS200::RGBA check_color = GetPixel({ 0, 0 });
        CS200::RGBA next_color;

        int height = texture.GetSize().y;

        int x = 0;
        for (int index = 0; index < num_chars; index++)
        {
            int width = 0;

            do
            {
                width++;
                next_color = GetPixel({ x + width, 0 });
            } while (check_color == next_color);

            check_color = next_color;

            char_rects[index].point_2 = { x + width , height };
            char_rects[index].point_1 = { x, 1  }; // 1 mean ignore line above
            x += width;
        }
        // stbi_image_free(image_data);
        // image.~Image();
    }

    Math::irect& Font::GetCharRect(char c)
    {
        if (c >= ' ' && c <= 'z')
        {
            return char_rects[c - ' '];
        }
        else
        {
            Engine::GetLogger().LogError("Char '" + std::to_string(c) + "' not found");
            return char_rects[0];
        }
    }

    Math::ivec2 Font::MeasureText(std::string text)
    {
        Math::ivec2 text_size = GetCharRect(text[0]).Size();
        for (size_t i = 1; i < text.size(); ++i)
        {
            text_size.x += GetCharRect(text[i]).Size().x;
            if (GetCharRect(text[i]).Size().y > GetCharRect(text[i - 1]).Size().y)
            {
                text_size.y = GetCharRect(text[i]).Size().y;
            }
        }
        return text_size;
    }

    void Font::DrawChar(Math::TransformationMatrix& matrix, char c, CS200::RGBA color)
	{
		const Math::irect& display_rect	  = GetCharRect(c);
		const Math::ivec2  top_left_texel = { display_rect.Left(), display_rect.Bottom() };

		if (c != ' ')
		{
			const auto flip = Math::ScaleMatrix(Math::vec2{ 1, -1 });
			/*===================================added=====================================*/
			const auto offset_up = Math::TranslationMatrix(Math::vec2{ 0.0, static_cast<double>(display_rect.Size().y) });
			/*===================================added=====================================*/

			texture.Draw(matrix * offset_up * flip, top_left_texel, display_rect.Size(), color);
		}
		matrix *= Math::TranslationMatrix(Math::ivec2{ display_rect.Size().x, 0 });
	}

    CS200::RGBA Font::GetPixel(Math::ivec2 texel) // tl is (0,0) !!
    {
        const CS200::RGBA* image_data = image.data();
        const auto         image_size = image.GetSize();
        // if (is_image_flipped)
        //{
        //     const int   index        = (image_size.x * image_size.y - 1) - (texel.x + texel.y * image_size.x);
        //     CS200::RGBA return_color = CS200::rgba_to_abgr(CS200::argb_to_rgba(image_data[index])); // very weird..argb?

        //    return return_color; // endian!!!
        //}
        // else
        //{
        const int   index        = texel.x + texel.y * image_size.x;
        CS200::RGBA return_color = CS200::rgba_to_abgr(image_data[index]);

        return return_color; // endian!!!
        //}
    }

}    



================================================
FILE: source/Engine/Font.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include "Rect.h"
#include "Texture.h"
#include "Vec2.h"
#include <filesystem>
#include <map>
#include <memory>
#include <string>
#include <unordered_map>

namespace CS230
{
    /**
     * \brief Bitmap font system for rendering text using pre-generated font textures
     *
     * Font provides a lightweight and efficient text rendering system based on
     * bitmap font textures. Rather than using complex font rasterization at runtime,
     * this system loads pre-rendered character sets from image files and uses them
     * to compose text strings quickly and efficiently.
     *
     * Bitmap Font Advantages:
     * - Consistent visual appearance across all platforms and systems
     * - Fast rendering performance with minimal runtime computation
     * - Predictable memory usage and loading times
     * - Simple integration with existing texture and rendering systems
     * - Pixel-perfect control over character appearance and spacing
     *
     * Font File Format:
     * The system expects specially formatted font textures where characters are
     * arranged horizontally in a single row, with specific color markers to
     * indicate character boundaries. The first pixel must be white, and color
     * changes signal the separation between characters.
     *
     * Character Set:
     * Supports ASCII characters from space (' ') to lowercase 'z', covering
     * basic alphanumeric characters, punctuation, and symbols commonly used
     * in game interfaces and debugging displays.
     *
     * Text Rendering Workflow:
     * 1. Load font texture and parse character boundaries during construction
     * 2. Measure text dimensions for layout calculations
     * 3. Render text to texture or directly to screen using character sprites
     * 4. Support for colored text and transformation matrices
     *
     * This font system is particularly well-suited for game development where
     * consistent, fast text rendering is more important than dynamic font
     * sizing or complex typography features.
     */
    class Font
    {
    public:
        /**
         * \brief Load and initialize a bitmap font from an image file
         * \param file_name Path to the font texture image file
         *
         * Constructs a Font object by loading a specially formatted bitmap font
         * texture and parsing the character boundary information. The constructor
         * analyzes the font image to determine where each character begins and
         * ends, creating a lookup table for efficient character rendering.
         *
         * Font Image Requirements:
         * - Characters arranged horizontally in a single row
         * - First pixel must be white (0xFFFFFFFF) as a format marker
         * - Color changes between characters indicate boundaries
         * - Characters cover ASCII range from space (' ') to 'z'
         * - Image should contain exactly the expected number of characters
         *
         * Parsing Process:
         * The constructor scans the top row of pixels to detect color changes,
         * which indicate character boundaries. Each character's rectangular
         * region is calculated and stored for later use during text rendering.
         *
         * Error Handling:
         * If the font file is malformed (wrong format, missing characters, or
         * incorrect structure), the constructor will throw an error to indicate
         * the problem. This ensures that only valid fonts are used for rendering.
         *
         * The loaded font is immediately ready for text rendering operations
         * and will remain valid for the lifetime of the Font object.
         */
        Font(const std::filesystem::path& file_name);

        /**
         * \brief Render text string to a cached texture for efficient reuse
         * \param text String of text to render using this font
         * \param color RGBA color value for the text (default: white)
         * \return Shared pointer to texture containing the rendered text (cached if previously rendered)
         *
         * Creates or retrieves a cached texture containing the rendered text string,
         * allowing the text to be used like any other texture in the rendering system.
         * This approach enables text to be drawn with transformations, effects,
         * and blending modes just like sprite graphics.
         *
         * Advanced Caching System:
         * - Cache key: Combination of text string and color (format: "text_0xCOLOR")
         * - Frame tracking: Each cached texture records when it was last accessed
         * - Reference counting: Uses shared_ptr for automatic memory management
         * - Intelligent cleanup: Removes old textures only when they have single reference and are older than 60 frames
         * - Performance optimization: Eliminates redundant text rendering operations
         *
         * Caching Strategy:
         * 1. Check cache using generated key (text + color combination)
         * 2. If found: Update last-used frame timestamp and return cached texture
         * 3. If not found: Create new texture, cache it, and return
         * 4. Periodic cleanup: Remove textures older than 60 frames with reference count of 1
         *
         * Rendering Process (for new textures):
         * 1. Measure total text dimensions to determine optimal texture size
         * 2. Create render target texture using TextureManager
         * 3. Render each character from font atlas to the target texture
         * 4. Store in cache with current frame timestamp
         * 5. Return shared_ptr for client use
         *
         * Memory Management Benefits:
         * - Shared ownership: Multiple objects can reference the same text texture
         * - Automatic cleanup: Textures are removed when no longer referenced elsewhere
         * - Frame-based aging: Prevents immediate removal of frequently used text
         * - Cache efficiency: Only removes textures that are truly unused
         *
         * Text-to-Texture Advantages:
         * - Caching eliminates redundant text rendering for repeated strings
         * - Supports full transformation matrices (rotation, scaling, positioning)
         * - Enables text participation in sprite batching and effects systems
         * - Provides consistent rendering performance regardless of text complexity
         * - Allows text to be treated as standard texture assets
         *
         * Color and Formatting:
         * The color parameter applies a tint to the entire text string while
         * preserving original font character shapes, anti-aliasing, and spacing.
         * Different colors of the same text are cached separately for maximum
         * flexibility without color bleeding between cache entries.
         */
        std::shared_ptr<Texture> PrintToTexture(const std::string& text, CS200::RGBA color = 0xFFFFFFFF);

    private:
        void         FindCharRects();
        Math::irect& GetCharRect(char c);
        Math::ivec2  MeasureText(std::string text);
        void         DrawChar(Math::TransformationMatrix& matrix, char c, CS200::RGBA color = CS200::WHITE);
        CS200::RGBA  GetPixel(Math::ivec2 texel);


        Texture texture;

        struct TimeTexture
        {
            uint64_t                 timestamp{};
            std::shared_ptr<Texture> texture{};
        };

        std::map<const std::string, TimeTexture> textures; // <key, <time stamp, texture shared_ptr>>
        static constexpr int                     num_chars    = 'z' - ' ' + 1;
        static constexpr int                     num_channels = 4; // rgba
        Math::irect                              char_rects[num_chars];
        CS200::Image                             image;
        Math::ivec2                              dimensions;
        static constexpr bool                    is_image_flipped = false;
    };
}



================================================
FILE: source/Engine/Fonts.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Fonts.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 5, 2025
*/
#pragma once
enum Fonts {
    Simple,
    Outlined
};




================================================
FILE: source/Engine/FPS.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <cmath>

namespace util
{
    class FPS
    {
        double timeCounter = 0;
        double numFrames   = 0;
        double fps         = 0;

    public:
        constexpr void Update(double delta_time_seconds) noexcept
        {
            ++numFrames;
            timeCounter += delta_time_seconds;
            if (timeCounter > 1.0)
            {
                fps = numFrames / timeCounter;
                timeCounter -= 1.0;
                numFrames = 0;
            }
        }

        operator long long() const noexcept
        {
            return std::llround(fps);
        }

        operator int() const noexcept
        {
            return static_cast<int>(std::lround(fps));
        }
    };
}



================================================
FILE: source/Engine/GameObject.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  GameObject.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 25, 2025
*/
#include "GameObject.h"
#include "GameState.h"
#include "GameStateManager.h"
#include "ShowCollision.h"

#include <numbers>

CS230::GameObject::GameObject(Math::vec2 _position) :
    GameObject(_position, 0, { 1, 1 })
{
}

CS230::GameObject::GameObject(Math::vec2 _position, double _rotation, Math::vec2 _scale) :
    
    current_state(&state_none),
    matrix_outdated(true),
    destroy(false),
    position(_position),
    velocity(Math::vec2{ 0.0,0.0 }),
    scale(_scale),
    rotation(_rotation)    
{}

bool CS230::GameObject::IsCollidingWith(GameObject* other_object)
{
    Collision* collider = GetGOComponent<Collision>();
    return collider != nullptr && collider->IsCollidingWith(other_object);
}

bool CS230::GameObject::IsCollidingWith(Math::vec2 point)
{
    Collision* collider = GetGOComponent<Collision>();
    return collider != nullptr && collider->IsCollidingWith(point);
}



bool CS230::GameObject::CanCollideWith([[maybe_unused]]GameObjectTypes other_object_type)
{
    return false;
}

void CS230::GameObject::Update(double dt) {
    current_state->Update(this, dt);
    //sprite.Update(dt);
    if (velocity.x != 0 || velocity.y != 0) {
        UpdatePosition(velocity * dt);
    }
    UpdateGOComponents(dt);
    current_state->CheckExit(this);
}

void CS230::GameObject::change_state(State* new_state) {
    current_state = new_state;
    current_state->Enter(this);
}


void CS230::GameObject::Draw(Math::TransformationMatrix camera_matrix, unsigned int color , float depth )
{
    
    Sprite* sprite = GetGOComponent<Sprite>();
    if (sprite != nullptr) {

		float real_depth;
		if (DrawPriority() != DRAWPRIORITY)
		{
			real_depth = 1.f - (static_cast<float>(DrawPriority()) / 100.0f);
			if (0.7f < real_depth)
				real_depth = 0.7f;
			if (0.3f > real_depth)
				real_depth = 0.3f;
        }
		else
		{
			real_depth = depth;
		}
		sprite->Draw(camera_matrix * GetMatrix(), color, real_depth);
    }
    Collision* collision = GetGOComponent<Collision>();
    ShowCollision* showcollision = Engine::GetGameStateManager().GetGSComponent<ShowCollision>();
    if (showcollision != nullptr) {
        if ((collision != nullptr) && (showcollision->Enabled() == true)) {
            collision->Draw(camera_matrix,0.f);
        }
    }
    
}

const Math::TransformationMatrix& CS230::GameObject::GetMatrix() {
    if (matrix_outdated == true) {
        object_matrix = Math::TranslationMatrix(position) * Math::RotationMatrix(rotation) * Math::ScaleMatrix(scale);
        matrix_outdated = false;
    }    
    return object_matrix;
}

const Math::vec2& CS230::GameObject::GetPosition() const
{
    return position;
}

const Math::vec2& CS230::GameObject::GetVelocity() const
{
    return velocity;
}

const Math::vec2& CS230::GameObject::GetScale() const
{
    return scale;
}

double CS230::GameObject::GetRotation() const
{
    return rotation;
}

void CS230::GameObject::SetPosition(Math::vec2 new_position) {
    position = new_position;
    matrix_outdated = true;
}

void CS230::GameObject::UpdatePosition(Math::vec2 delta) {
    position += delta;
    matrix_outdated = true;
}

void CS230::GameObject::SetVelocity(Math::vec2 new_velocity){
    velocity = new_velocity;
    matrix_outdated = true;
}

void CS230::GameObject::UpdateVelocity(Math::vec2 delta)
{
    velocity += delta;
    matrix_outdated = true;
}

void CS230::GameObject::SetScale(Math::vec2 new_scale)
{
    scale = new_scale;
    matrix_outdated = true;
}

void CS230::GameObject::UpdateScale(Math::vec2 delta)
{
    scale += delta;
    matrix_outdated = true;
}

void CS230::GameObject::SetRotation(double new_rotation)
{
    rotation = new_rotation;
    matrix_outdated = true;
}

void CS230::GameObject::UpdateRotation(double delta)
{
    rotation += delta;
    matrix_outdated = true;
}





================================================
FILE: source/Engine/GameObject.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  GameObject.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 25, 2025
*/

#pragma once
#include "../Game/GameObjectTypes.h"
#include "ComponentManager.h"
#include "ShowCollision.h"
#include "Sprite.h"

namespace Math
{
    class TransformationMatrix;
}

namespace CS230
{
    class Component;

    class GameObject
    {
    public:
        friend class Sprite;
        GameObject(Math::vec2 position);
        GameObject(Math::vec2 position, double rotation, Math::vec2 scale);

        virtual ~GameObject()
        {
        }

        virtual GameObjectTypes Type()     = 0;
        virtual std::string     TypeName() = 0;

		virtual int UpdatePriority() const
		{
			return UPDATEPRIORITY;
		}

        virtual int DrawPriority() const
        {
			return DRAWPRIORITY; // higher for later, upper means low depth, 30 - 70 fix
        }

        bool         IsCollidingWith(GameObject* other_object);
        bool         IsCollidingWith(Math::vec2 point);
        virtual bool CanCollideWith(GameObjectTypes other_object_type);
        virtual void ResolveCollision([[maybe_unused]] GameObject* other_object) { };

        virtual void Update(double dt);
		virtual void Draw(Math::TransformationMatrix camera_matrix, unsigned int color = 0xFFFFFFFF, float depth = 0.5f);

        const Math::TransformationMatrix& GetMatrix();
        const Math::vec2&                 GetPosition() const;
        const Math::vec2&                 GetVelocity() const;
        const Math::vec2&                 GetScale() const;
        double                            GetRotation() const;

        template <typename T>
        T* GetGOComponent()
        {
            return componentmanager.GetComponent<T>();
        }

        void SetPosition(Math::vec2 new_position);
        void SetVelocity(Math::vec2 new_velocity);
        void UpdateVelocity(Math::vec2 delta);

        const bool& Destroyed() const
        {
            return destroy;
        }

        void Destroy()
        {
            destroy = true;
        }

		static constexpr int DRAWPRIORITY = 50;
		static constexpr int UPDATEPRIORITY = 10;

    protected:

        void UpdatePosition(Math::vec2 delta);


        void SetScale(Math::vec2 new_scale);
        void UpdateScale(Math::vec2 delta);
        void SetRotation(double new_rotation);
        void UpdateRotation(double delta);

        class State
        {
        public:
            virtual void        Enter(GameObject* object)             = 0;
            virtual void        Update(GameObject* object, double dt) = 0;
            virtual void        CheckExit(GameObject* object)         = 0;
            virtual std::string GetName()                             = 0;

            virtual ~State()
            {
            }
        };

        State* current_state;
        void   change_state(State* new_state);

        bool matrix_outdated;

        void AddGOComponent(Component* component)
        {
            componentmanager.AddComponent(component);
        }

        template <typename T>
        void RemoveGOComponent()
        {
            componentmanager.RemoveComponent<T>();
        }

        void ClearGOComponents()
        {
            componentmanager.Clear();
        }

        void UpdateGOComponents(double dt)
        {
            componentmanager.UpdateAll(dt);
        }


    private:
        bool destroy;

        class State_None : public State
        {
        public:
            void Enter(GameObject*) override
            {
            }

            void Update(GameObject*, double) override
            {
            }

            void CheckExit(GameObject*) override
            {
            }

            std::string GetName() override
            {
                return "";
            }

            ~State_None()
            {
            }
        };

        State_None state_none;

        Math::TransformationMatrix object_matrix;


        Math::vec2 position;
        Math::vec2 velocity;
        Math::vec2 scale;
        double     rotation;

        ComponentManager componentmanager;
    };
}



================================================
FILE: source/Engine/GameObjectManager.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  GameObjectManager.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 25, 2025
*/
#include "GameObjectManager.h"
#include "Logger.h"

void CS230::GameObjectManager::Add(GameObject* object){
	objects.push_back(object);
}

void CS230::GameObjectManager::Unload(){
	for (GameObject* object : objects) {
		delete object;
	}
	objects.clear();
}

void CS230::GameObjectManager::UpdateAll(double dt){
	std::vector<GameObject*> destroy_objects;
	for (GameObject* object : objects) {
		object->Update(dt);
		if (object->Destroyed() == true) {
			destroy_objects.push_back(object);
		}
	}
	for (GameObject* destroy_object : destroy_objects) {
		objects.remove(destroy_object);
		delete destroy_object;
	}
}

void CS230::GameObjectManager::SortForUpdate()
{
	objects.sort([](GameObject* a, GameObject* b) { return a->UpdatePriority() < b->UpdatePriority(); });
}

void CS230::GameObjectManager::DrawAll(Math::TransformationMatrix camera_matrix){
	for (GameObject* object : objects) {
		object->Draw(camera_matrix);		
	}
}

void CS230::GameObjectManager::CollisionTest()
{
	for (GameObject* object1 : objects) {
		for (GameObject* object2 : objects) {
			if (object1 != object2 && object1->CanCollideWith(object2->Type())) {
				if (object1->IsCollidingWith(object2)) {
					Engine::GetLogger().LogEvent("Collision Detected: " + object1->TypeName() + " and " + object2->TypeName());
					object1->ResolveCollision(object2);
				}
			}
		}
	}
}



================================================
FILE: source/Engine/GameObjectManager.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  GameObjectManager.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    April 25, 2025
*/

#pragma once
#include <list>
#include "GameObject.h"
#include "Matrix.h"
#include "Component.h"

namespace Math { class TransformationMatrix; }

namespace CS230 {
    class GameObjectManager : public CS230::Component{
    public:
        void Add(GameObject* object);
        void Unload();

        void UpdateAll(double dt);
        void SortForUpdate();
        void DrawAll(Math::TransformationMatrix camera_matrix);

        void CollisionTest();

        const std::list<GameObject*>& GetAll() const { return objects; }
    private:
        std::list<GameObject*> objects;
    };
}



================================================
FILE: source/Engine/GameState.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "ComponentManager.h"
#include <gsl/gsl>

namespace CS230
{
    class GameState
    {
    public:
        virtual void          Load()            = 0;
        virtual void          Update(double dt) = 0;
        virtual void          Unload()          = 0;
        virtual void          Draw()            = 0;
        virtual void          DrawImGui()       = 0;
        virtual gsl::czstring GetName() const   = 0;
        virtual ~GameState()                    = default;

        template <typename T>
        T* GetGSComponent()
        {
            return componentmanager.GetComponent<T>();
        }

    protected:
        void AddGSComponent(Component* component)
        {
            componentmanager.AddComponent(component);
        }

        void UpdateGSComponents(double dt)
        {
            componentmanager.UpdateAll(dt);
        }

        template <typename T>
        void RemoveGSComponent()
        {
            componentmanager.RemoveComponent<T>();
        }

        void ClearGSComponents()
        {
            componentmanager.Clear();
        }

    private:
        ComponentManager componentmanager;
    };

}



================================================
FILE: source/Engine/GameStateManager.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "GameStateManager.h"
#include "GameObjectManager.h"

namespace CS230
{
    void GameStateManager::PopState()
    {
        using namespace std::literals;
        auto* const state = mGameStateStack.back().get();
        mToClear.push_back(std::move(mGameStateStack.back()));
        mGameStateStack.erase(mGameStateStack.end() - 1);
        Engine::GetLogger().LogEvent("Exiting state "s + state->GetName());
        state->Unload();
    }

    void GameStateManager::Update(double dt)
    {
        mToClear.clear();
        mGameStateStack.back()->Update(dt);
        if (!mGameStateStack.empty())
        {
            GameObjectManager* current_gameobject_manager = mGameStateStack.back()->GetGSComponent<GameObjectManager>();
            if (current_gameobject_manager != nullptr)
            {
                current_gameobject_manager->CollisionTest();
            }
        }
    }

    void GameStateManager::Draw()
    {
        for (auto& game_state : mGameStateStack)
        {
            game_state->Draw();
        }
    }

    void GameStateManager::DrawImGui()
    {
        if (!mGameStateStack.empty())
        {
            mGameStateStack.back()->DrawImGui();
        }
    }

    void GameStateManager::Clear()
    {
        while (!mGameStateStack.empty())
            PopState();
        mToClear.clear();
    }

}



================================================
FILE: source/Engine/GameStateManager.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Engine.h"
#include "Engine/Logger.h"
#include "GameState.h"
#include <memory>
#include <vector>

namespace CS230
{
    class GameStateManager
    {
    public:
        template <typename STATE>
        void PushState();
        void PopState();
        void Update(double);
        void Draw();
        void DrawImGui();

        [[nodiscard]] bool HasGameEnded() const
        {
            return mGameStateStack.empty();
        }

        void Clear();

        template <typename T>
        T* GetGSComponent()
        {
            return mGameStateStack.back()->GetGSComponent<T>();
        }

    private:
        std::vector<std::unique_ptr<GameState>> mGameStateStack;
        std::vector<std::unique_ptr<GameState>> mToClear;
    };

    template <typename STATE>
    void GameStateManager::PushState()
    {
        using namespace std::literals;
        mGameStateStack.push_back(std::make_unique<STATE>());
        const auto& state = mGameStateStack.back();
        Engine::GetLogger().LogEvent("Entering state "s + state->GetName());
        state->Load();
    }
}



================================================
FILE: source/Engine/Input.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Input.h"
#include "Engine.h"
#include "Logger.h"
#include <SDL.h>

namespace CS230
{
    Input::Input()
    {
        Init();
    }

    void Input::Init()
    {
        previousKeys.fill(false);
        currentKeys.fill(false);
    }

    void Input::Update()
    {
        previousKeys = currentKeys;
        // via SDL get keyboard state
        // mark each keyboard that is down
        for (Keys key = Keys::A; key < Keys::Count; ++key)
        {
            const auto   sdl_key        = convert_cs230_to_sdl(static_cast<Keys>(key));
            const Uint8* keyboard_state = SDL_GetKeyboardState(nullptr);
            SetKeyDown(key, keyboard_state[sdl_key]);
            if (KeyJustPressed(key))
            {
                Engine::GetLogger().LogDebug("Key Pressed");
            }
            else if (KeyJustReleased(key))
            {
                Engine::GetLogger().LogDebug("Key Released");
            }
        }
    }

    bool Input::KeyDown(Input::Keys key) const
    {
        return currentKeys[static_cast<std::size_t>(key)];
    }

    bool Input::KeyJustReleased(Input::Keys key) const
    {
        const std::size_t index = static_cast<std::size_t>(key);
        return !currentKeys[index] && previousKeys[index];
    }

    bool Input::KeyJustPressed(Input::Keys key) const
    {
        const std::size_t index = static_cast<std::size_t>(key);
        return currentKeys[index] && !previousKeys[index];
    }

    void Input::SetKeyDown(Input::Keys key, bool is_pressed)
    {
        currentKeys[static_cast<std::size_t>(key)] = is_pressed;
    }

    SDL_Scancode convert_cs230_to_sdl(Input::Keys cs230_key)
    {
        switch (cs230_key)
        {
            case CS230::Input::Keys::A: return SDL_SCANCODE_A;
            case CS230::Input::Keys::B: return SDL_SCANCODE_B;
            case CS230::Input::Keys::C: return SDL_SCANCODE_C;
            case CS230::Input::Keys::D: return SDL_SCANCODE_D;
            case CS230::Input::Keys::E: return SDL_SCANCODE_E;
            case CS230::Input::Keys::F: return SDL_SCANCODE_F;
            case CS230::Input::Keys::G: return SDL_SCANCODE_G;
            case CS230::Input::Keys::H: return SDL_SCANCODE_H;
            case CS230::Input::Keys::I: return SDL_SCANCODE_I;
            case CS230::Input::Keys::J: return SDL_SCANCODE_J;
            case CS230::Input::Keys::K: return SDL_SCANCODE_K;
            case CS230::Input::Keys::L: return SDL_SCANCODE_L;
            case CS230::Input::Keys::M: return SDL_SCANCODE_M;
            case CS230::Input::Keys::N: return SDL_SCANCODE_N;
            case CS230::Input::Keys::O: return SDL_SCANCODE_O;
            case CS230::Input::Keys::P: return SDL_SCANCODE_P;
            case CS230::Input::Keys::Q: return SDL_SCANCODE_Q;
            case CS230::Input::Keys::R: return SDL_SCANCODE_R;
            case CS230::Input::Keys::S: return SDL_SCANCODE_S;
            case CS230::Input::Keys::T: return SDL_SCANCODE_T;
            case CS230::Input::Keys::U: return SDL_SCANCODE_U;
            case CS230::Input::Keys::V: return SDL_SCANCODE_V;
            case CS230::Input::Keys::W: return SDL_SCANCODE_W;
            case CS230::Input::Keys::X: return SDL_SCANCODE_X;
            case CS230::Input::Keys::Y: return SDL_SCANCODE_Y;
            case CS230::Input::Keys::Z: return SDL_SCANCODE_Z;
            case CS230::Input::Keys::Space: return SDL_SCANCODE_SPACE;
            case CS230::Input::Keys::Enter: return SDL_SCANCODE_RETURN;
            case CS230::Input::Keys::Left: return SDL_SCANCODE_LEFT;
            case CS230::Input::Keys::Up: return SDL_SCANCODE_UP;
            case CS230::Input::Keys::Right: return SDL_SCANCODE_RIGHT;
            case CS230::Input::Keys::Down: return SDL_SCANCODE_DOWN;
            case CS230::Input::Keys::Escape: return SDL_SCANCODE_ESCAPE;
            case CS230::Input::Keys::Tab: return SDL_SCANCODE_TAB;
			case CS230::Input::Keys::One: return SDL_SCANCODE_1;
			case CS230::Input::Keys::Two: return SDL_SCANCODE_2;
			case CS230::Input::Keys::Three: return SDL_SCANCODE_3;
			case CS230::Input::Keys::Four: return SDL_SCANCODE_4;
            default: return SDL_SCANCODE_UNKNOWN; // SDL's equivalent of an unknown key
        }
    }
}



================================================
FILE: source/Engine/Input.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include <SDL.h>
#include <gsl/gsl>
#include <vector>

namespace CS230
{
    class Input
    {
    public:
        enum class Keys
        {
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H,
            I,
            J,
            K,
            L,
            M,
            N,
            O,
            P,
            Q,
            R,
            S,
            T,
            U,
            V,
            W,
            X,
            Y,
            Z,
            Space,
            Enter,
            Left,
            Up,
            Right,
            Down,
            Escape,
            Tab,
			One,
			Two,
			Three,
			Four,
            Count
        };

        Input();
        void Init();
        void Update();

        bool KeyDown(Keys key) const;
        bool KeyJustReleased(Keys key) const;
        bool KeyJustPressed(Keys key) const;

    private:
        std::array<bool, static_cast<std::size_t>(Keys::Count)> previousKeys;
        std::array<bool, static_cast<std::size_t>(Keys::Count)> currentKeys;
        void                                                    SetKeyDown(Keys key, bool is_pressed);
    };

    constexpr Input::Keys& operator++(Input::Keys& the_key) noexcept
    {
        the_key = static_cast<Input::Keys>(static_cast<unsigned>(the_key) + 1);
        return the_key;
    }

    SDL_Scancode convert_cs230_to_sdl(Input::Keys cs230_key);

    constexpr gsl::czstring to_string(Input::Keys key) noexcept
    {
        switch (key)
        {
            case Input::Keys::A: return "A";
            case Input::Keys::B: return "B";
            case Input::Keys::C: return "C";
            case Input::Keys::D: return "D";
            case Input::Keys::E: return "E";
            case Input::Keys::F: return "F";
            case Input::Keys::G: return "G";
            case Input::Keys::H: return "H";
            case Input::Keys::I: return "I";
            case Input::Keys::J: return "J";
            case Input::Keys::K: return "K";
            case Input::Keys::L: return "L";
            case Input::Keys::M: return "M";
            case Input::Keys::N: return "N";
            case Input::Keys::O: return "O";
            case Input::Keys::P: return "P";
            case Input::Keys::Q: return "Q";
            case Input::Keys::R: return "R";
            case Input::Keys::S: return "S";
            case Input::Keys::T: return "T";
            case Input::Keys::U: return "U";
            case Input::Keys::V: return "V";
            case Input::Keys::W: return "W";
            case Input::Keys::X: return "X";
            case Input::Keys::Y: return "Y";
            case Input::Keys::Z: return "Z";
            case Input::Keys::Space: return "Space";
            case Input::Keys::Enter: return "Enter";
            case Input::Keys::Left: return "Left";
            case Input::Keys::Up: return "Up";
            case Input::Keys::Right: return "Right";
            case Input::Keys::Down: return "Down";
            case Input::Keys::Escape: return "Escape";
            case Input::Keys::Tab: return "Tab";
			case Input::Keys::One: return "One";
			case Input::Keys::Two: return "Two";
			case Input::Keys::Three: return "Three";
			case Input::Keys::Four: return "Four";
            case Input::Keys::Count: return "Count";
        }
        return "Unknown";
    }
}



================================================
FILE: source/Engine/Logger.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Logger.h"
#include <iostream>

namespace CS230
{
    Logger::Logger(Severity severity, bool use_console, std::chrono::system_clock::time_point _start_time) : min_level(severity), out_stream("Trace.log"), start_time(_start_time)
    {
        if (use_console == true)
        {
            out_stream.basic_ios<char>::rdbuf(std::cout.rdbuf());
            ;
        }
    }

    void Logger::LogError(std::string text)
    {
        log(Severity::Error, text);
    }

    void Logger::LogEvent(std::string text)
    {
        log(Severity::Event, text);
    }

    void Logger::LogDebug(std::string text)
    {
        log(Severity::Debug, text);
    }

    void Logger::LogVerbose(std::string text)
    {
        log(Severity::Verbose, text);
    }

    void Logger::log(Severity severity, std::string message)
    {
        std::map<CS230::Logger::Severity, std::string> get_error_level = {
            { CS230::Logger::Severity::Verbose, "Verbose" },
            {   CS230::Logger::Severity::Debug,   "Debug" },
            {   CS230::Logger::Severity::Event,   "Event" },
            {   CS230::Logger::Severity::Error,   "Error" }
        };
        std::string answer = get_error_level[severity] + "\t" + message;
        //===========map_version


        if (int(CS230::Logger::min_level) <= int(severity))
        {
            out_stream.precision(4);
            out_stream << '[' << std::fixed << seconds_since_start() << "]\t";
            out_stream << answer << "\n";
        }
        return;
    }

    double Logger::seconds_since_start()
    {
        return std::chrono::duration<double>(std::chrono::system_clock::now() -start_time).count();
    }

    // note the proper way to redirect the rdbuf is `stream.basic_ios<char>::rdbuf(other_stream.rdbuf());`
    // note that we don't need a destructor ~Logger() if all we are doing is closing the streams. The std stream classes impl Rule of 5 and will auto flush & close themselves
}



================================================
FILE: source/Engine/Logger.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include <chrono>
#include <fstream>
#include <map>
#include <string>

namespace CS230
{
    class Logger
    {
    public:
        enum class Severity
        {
            Verbose, // Minor messages
            Debug,   // Only used while actively debugging
            Event,   // General event, like key press or state change
            Error    // Errors, such as file load errors
        };
        Logger(Severity severity, bool use_console, std::chrono::system_clock::time_point start_time);

        void LogError(std::string text);

        void LogEvent(std::string text);

        void LogDebug(std::string text);

        void LogVerbose(std::string text);

    private:
        Severity                              min_level;
        std::ofstream                         out_stream;
        std::chrono::system_clock::time_point start_time;
        void                                  log(Severity severity, std::string message);
        double                                seconds_since_start();
    };
}



================================================
FILE: source/Engine/Matrix.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Matrix.h"
#include <cmath>

namespace Math
{
    TransformationMatrix::TransformationMatrix()
    {
        Reset();
    }

    double* TransformationMatrix::operator[](int index)
    {
        return const_cast<double*>((static_cast<TransformationMatrix const&>(*this))[index]);
    }

    const double* TransformationMatrix::operator[](int index) const
    {
        return matrix[index];
    }

    TransformationMatrix TransformationMatrix::operator*(TransformationMatrix m) const
    {
        TransformationMatrix result;

        result.matrix[0][0] = matrix[0][0] * m[0][0] + matrix[0][1] * m[1][0] + matrix[0][2] * m[2][0];
        result.matrix[0][1] = matrix[0][0] * m[0][1] + matrix[0][1] * m[1][1] + matrix[0][2] * m[2][1];
        result.matrix[0][2] = matrix[0][0] * m[0][2] + matrix[0][1] * m[1][2] + matrix[0][2] * m[2][2];
        result.matrix[1][0] = matrix[1][0] * m[0][0] + matrix[1][1] * m[1][0] + matrix[1][2] * m[2][0];
        result.matrix[1][1] = matrix[1][0] * m[0][1] + matrix[1][1] * m[1][1] + matrix[1][2] * m[2][1];
        result.matrix[1][2] = matrix[1][0] * m[0][2] + matrix[1][1] * m[1][2] + matrix[1][2] * m[2][2];
        result.matrix[2][0] = matrix[2][0] * m[0][0] + matrix[2][1] * m[1][0] + matrix[2][2] * m[2][0];
        result.matrix[2][1] = matrix[2][0] * m[0][1] + matrix[2][1] * m[1][1] + matrix[2][2] * m[2][1];
        result.matrix[2][2] = matrix[2][0] * m[0][2] + matrix[2][1] * m[1][2] + matrix[2][2] * m[2][2];

        return result;
    }

	TransformationMatrix TransformationMatrix::Inverse() const
	{
        TransformationMatrix inv;

        const double m00 = matrix[0][0]; const double m01 = matrix[0][1]; const double m02 = matrix[0][2];
        const double m10 = matrix[1][0]; const double m11 = matrix[1][1]; const double m12 = matrix[1][2];
        const double m20 = matrix[2][0]; const double m21 = matrix[2][1]; const double m22 = matrix[2][2];

        double det = m00 * (m11 * m22 - m12 * m21) 
                   - m01 * (m10 * m22 - m12 * m20) 
                   + m02 * (m10 * m21 - m11 * m20);

        if (std::abs(det) < 1e-5) 
        {
            inv.Reset(); 
            return inv;
        }

        double invDet = 1.0 / det;
		// Row 0
        inv[0][0] =  (m11 * m22 - m12 * m21) * invDet;
        inv[0][1] = -(m01 * m22 - m02 * m21) * invDet; // Transposed indices (0,1 -> cofactor of 1,0)
        inv[0][2] =  (m01 * m12 - m02 * m11) * invDet; 

        // Row 1
        inv[1][0] = -(m10 * m22 - m12 * m20) * invDet;
        inv[1][1] =  (m00 * m22 - m02 * m20) * invDet;
        inv[1][2] = -(m00 * m12 - m02 * m10) * invDet;

        // Row 2
        inv[2][0] =  (m10 * m21 - m11 * m20) * invDet;
        inv[2][1] = -(m00 * m21 - m01 * m20) * invDet;
        inv[2][2] =  (m00 * m11 - m01 * m10) * invDet;

        return inv;
	}


	TransformationMatrix& TransformationMatrix::operator*=(TransformationMatrix m)
    {
        (*this) = (*this) * m;
        return (*this);
    }

    vec2 TransformationMatrix::operator*(vec2 v) const
    {
        Math::vec2 result;
        result.x = matrix[0][0] * v.x + matrix[0][1] * v.y + matrix[0][2];
        result.y = matrix[1][0] * v.x + matrix[1][1] * v.y + matrix[1][2];
        return result;
    }

    vec3 TransformationMatrix::operator*(vec3 v) const
    {
        Math::vec3 result;
        result.x = matrix[0][0] * v.x + matrix[0][1] * v.y + matrix[0][2] * v.x;
        result.y = matrix[1][0] * v.x + matrix[1][1] * v.y + matrix[1][2] * v.z;
        return result;
    }

    void TransformationMatrix::Reset()
    {
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                matrix[i][j] = 0;
            }
        }
        matrix[0][0] = 1.0;
        matrix[1][1] = 1.0;
        matrix[2][2] = 1.0;
    }

    TranslationMatrix::TranslationMatrix(ivec2 translate)
    {
        Reset();
        matrix[0][2] = translate.x;
        matrix[1][2] = translate.y;
    }

    TranslationMatrix::TranslationMatrix(vec2 translate)
    {
        Reset();
        matrix[0][2] = translate.x;
        matrix[1][2] = translate.y;
    }

    RotationMatrix::RotationMatrix(double theta)
    {
        Reset();
        matrix[0][0] = std::cos(theta);
        matrix[0][1] = -std::sin(theta);
        matrix[1][0] = std::sin(theta);
        matrix[1][1] = std::cos(theta);
    }

    ScaleMatrix::ScaleMatrix(double scale)
    {
        Reset();
        matrix[0][0] *= scale;
        matrix[1][1] *= scale;
    }

    ScaleMatrix::ScaleMatrix(vec2 scale)
    {
        Reset();
        matrix[0][0] *= scale.x;
        matrix[1][1] *= scale.y;
    }
}



================================================
FILE: source/Engine/Matrix.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include "Vec2.h"

namespace Math
{
	class TransformationMatrix
	{
	public:
		TransformationMatrix();

		double* operator[](int index);

		const double* operator[](int index) const;

		TransformationMatrix operator*(TransformationMatrix m) const;
		TransformationMatrix Inverse() const;

		TransformationMatrix& operator*=(TransformationMatrix m);
		vec2				  operator*(vec2 v) const;
		vec3				  operator*(vec3 v) const;
		void				  Reset();


	protected:
		double matrix[3][3];
	};

	class TranslationMatrix : public TransformationMatrix
	{
	public:
		TranslationMatrix(ivec2 translate);
		TranslationMatrix(vec2 translate);
	};

	class RotationMatrix : public TransformationMatrix
	{
	public:
		RotationMatrix(double theta);
	};

	class ScaleMatrix : public TransformationMatrix
	{
	public:
		ScaleMatrix(double scale);
		ScaleMatrix(vec2 scale);
	};

	inline static bool IsIdentityMatrix(const Math::TransformationMatrix& mat)
	{
		return mat[0][0] == 1.0 && mat[0][1] == 0.0 && mat[0][2] == 0.0 && mat[1][0] == 0.0 && mat[1][1] == 1.0 && mat[1][2] == 0.0 && mat[2][0] == 0.0 && mat[2][1] == 0.0 && mat[2][2] == 1.0;
	}
}



================================================
FILE: source/Engine/Particle.cpp
================================================
#include "Particle.h"
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Particle.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    June 6, 2025
*/

namespace CS230 {
	Particle::Particle(const std::filesystem::path& sprite_file) : 
		
		GameObject({0,0}),
		life(0.0)
	{
		AddGOComponent(new Sprite(sprite_file, this));
	}


	void Particle::Start(Math::vec2 _position, Math::vec2 _velocity, double max_life, CS200::RGBA _color)
	{
		SetPosition(_position);
		SetVelocity(_velocity);
		life = max_life;
		real_color = _color;
		GetGOComponent<Sprite>()->PlayAnimation(0);
	}

	void Particle::Update(double dt) {
		if (Alive()) {
			life -= dt;
			//Engine::GetLogger().LogDebug(std::to_string(life));
			GameObject::Update(dt);
		}
	}

	void Particle::Draw(Math::TransformationMatrix camera_matrix, [[maybe_unused]]unsigned int color, float depth)
	{
		if (Alive()) {
			GameObject::Draw(camera_matrix, real_color, depth);
		}
	}
}


================================================
FILE: source/Engine/Particle.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Particle.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    June 6, 2025
*/
#pragma once
#include "../Game/GameObjectTypes.h"
#include "GameObject.h"
#include "GameObjectManager.h"
#include "GameStateManager.h"

namespace CS230
{
    class Particle : public GameObject
    {
    public:
        Particle(const std::filesystem::path& sprite_file);
        void Start(Math::vec2 _position, Math::vec2 _velocity, double max_life, CS200::RGBA _color = CS200::WHITE);
        void Update(double dt) override;
		void Draw(Math::TransformationMatrix camera_matrix, unsigned int color = 0xFFFFFFFF, float depth = 0.5f) override;

        int DrawPriority() const override
		{
			return 70;
		}
        bool Alive()
        {
            return life > 0;
        }

        GameObjectTypes Type() override
        {
            return GameObjectTypes::Particle;
        }

    private:
        double life;
		CS200::RGBA real_color;
    };

    template <typename T>
    class ParticleManager : public Component
    {
    public:
        ParticleManager();
        ~ParticleManager();
        void Emit(size_t count, Math::vec2 emitter_position, Math::vec2 emitter_velocity, Math::vec2 direction, double spread, CS200::RGBA = CS200::WHITE);

    private:
        std::vector<T*> particles;
        size_t             index;
    };

    template <typename T>
    inline ParticleManager<T>::ParticleManager() : index(0)
    {
		int max_count = T::MaxCount;
		auto game_object_mamager = Engine::GetGameStateManager().GetGSComponent<CS230::GameObjectManager>();
		for (int i = 0; i < max_count; ++i)
        {
            T* new_particle = new T();

            game_object_mamager->Add(new_particle);

            particles.push_back(new_particle);
        }
    }

    template <typename T>
    inline ParticleManager<T>::~ParticleManager()
    {
        //for (T* particle : particles)
        //{
        //    particle->Destroy();
        //}
        particles.clear();
    }

    template <typename T>
    inline void ParticleManager<T>::Emit(size_t count, Math::vec2 emitter_position, Math::vec2 emitter_velocity, Math::vec2 direction, double spread, CS200::RGBA color)
    {
        for (size_t i = 0; i < count; ++i)
        {
            if ((particles[i])&&(particles[i]->Alive()))
            {
                Engine::GetLogger().LogEvent("Particle overwritten");
            }
            double angle_variation = 0.0;
            if (spread != 0)
            {
                angle_variation = static_cast<double>((rand() % static_cast<int>(spread * 1024)) / 1024) - spread / 2;
            }
            Math::vec2 random_magnitude  = direction * static_cast<double>(static_cast<float>((rand() % 1024) / 2048) + 0.5f);
            Math::vec2 particle_velocity = Math::RotationMatrix(angle_variation) * random_magnitude + emitter_velocity;
            particles[index]->Start(emitter_position, particle_velocity, T::MaxLife,color);

            ++index;
            if (index >= particles.size())
            {
                index = 0;
            }
        }
    }

}



================================================
FILE: source/Engine/Path.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Path.h"

#include <SDL.h>
#include <optional>

namespace
{
    std::optional<std::filesystem::path> try_get_asset_path(const std::filesystem::path& starting_directory)
    {
        namespace fs                 = std::filesystem;
        fs::path       assets_parent = fs::absolute(starting_directory);
        const fs::path root          = assets_parent.root_path();

        // note that the do while loop is needed because on the web platform the starting folder is the root and that's also where the assets folder should be
        do
        {
            const fs::path assets_folder = assets_parent / "Assets";
            if (fs::is_directory(assets_folder))
            {
                return assets_parent;
            }
            // if assets not found then try looking the in parent folder
            assets_parent = assets_parent.parent_path();
        } while (assets_parent != root);

        return std::nullopt;
    }
}

namespace assets
{

    std::filesystem::path get_base_path()
    {
        namespace fs                  = std::filesystem;
        static fs::path assets_folder = []()
        {
            auto result = try_get_asset_path(fs::current_path());
            if (result)
                return result.value();
            // try from the exe path rather than the current working directory
            const auto base_path = SDL_GetBasePath();
            result               = try_get_asset_path(base_path);
            SDL_free(base_path);
            if (result)
                return result.value();
            throw std::runtime_error{ "Failed to find Assets folder in parent folders" };
        }();
        return assets_folder;
    }

    std::filesystem::path locate_asset(const std::filesystem::path& asset_path)
    {
        auto asset_filepath = asset_path;
        if (!std::filesystem::exists(asset_filepath))
        {
            // try prepending the asset directory path
            asset_filepath = get_base_path() / asset_filepath;
            if (!std::filesystem::exists(asset_filepath))
            {
                throw std::runtime_error("Failed to locate asset: " + asset_path.string());
            }
        }
        return asset_filepath;
    }
}



================================================
FILE: source/Engine/Path.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <filesystem>

namespace assets
{

    std::filesystem::path get_base_path();
    std::filesystem::path locate_asset(const std::filesystem::path& asset_path);
}



================================================
FILE: source/Engine/Random.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Random.h"

#include <cassert>
#include <chrono>
#include <random>
#include <thread>

namespace
{
    using namespace std;
    using namespace chrono;

    mt19937_64& RandomEngine()
    {
        thread_local static mt19937_64 engine{ static_cast<mt19937_64::result_type>(system_clock::now().time_since_epoch().count()) + hash<thread::id>{}(this_thread::get_id()) };
        return engine;
    }
}

namespace util
{
    double random(double min_inclusive, double max_exclusive) noexcept
    {
        assert(min_inclusive < max_exclusive);
        return std::uniform_real_distribution<double>(min_inclusive, max_exclusive)(RandomEngine());
    }

    int random(int min_inclusive, int max_exclusive) noexcept
    {
        assert(min_inclusive < max_exclusive - 1);
        return std::uniform_int_distribution<int>(min_inclusive, max_exclusive - 1)(RandomEngine());
    }

    int random(int max_exclusive) noexcept
    {
        return random(0, max_exclusive);
    }
}



================================================
FILE: source/Engine/Random.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

namespace util
{
    double random(double min_inclusive = 0.0, double max_exclusive = 1.0) noexcept;
    int    random(int min_inclusive, int max_exclusive) noexcept;
    int    random(int max_exclusive) noexcept;
}



================================================
FILE: source/Engine/Rect.h
================================================
 /**
  * \file
  * \author Rudy Castan
  * \author Jonathan Holmes
  * \author Taekyung Ho
  * \date 2025 Fall
  * \par CS200 Computer Graphics I
  * \copyright DigiPen Institute of Technology
  */

 #pragma once
 #include "Vec2.h"
 #include <algorithm>

 namespace Math
 {
     struct [[nodiscard]] rect
     {
         Math::vec2 point_1{ 0.0, 0.0 };
         Math::vec2 point_2{ 0.0, 0.0 };
         
         double Left() const noexcept
         {
             return std::min(point_1.x, point_2.x);
         }

         double Right() const noexcept
         {
             return std::max(point_1.x, point_2.x);
         }

         double Top() const noexcept
         {
             return std::max(point_1.y, point_2.y);
         }

         double Bottom() const noexcept
         {
             return std::min(point_1.y, point_2.y);
         }

         Math::vec2 Center() const noexcept{
            return {(Left() + Right()) * 0.5, (Top() + Bottom()) * 0.5};
         }
         Math::vec2 Size() const noexcept
         {
             return { Right() - Left(), Top() - Bottom() };
         }
     };

     struct [[nodiscard]] irect
     {
         Math::ivec2 point_1{ 0, 0 };
         Math::ivec2 point_2{ 0, 0 };

         int Left() const noexcept
         {
             return std::min(point_1.x, point_2.x);
         }

         int Right() const noexcept
         {
             return std::max(point_1.x, point_2.x);
         }

         int Top() const noexcept
         {
             return std::max(point_1.y, point_2.y);
         }

         int Bottom() const noexcept
         {
             return std::min(point_1.y, point_2.y);
         }

         Math::ivec2 Size() const noexcept
         {
             return { Right() - Left(), Top() - Bottom() };
         }
     };
 }



================================================
FILE: source/Engine/ShowCollision.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  ShowCollision.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 17, 2025
*/
#include "ShowCollision.h"
#include "Input.h"

CS230::ShowCollision::ShowCollision() : enabled(true) {}

void CS230::ShowCollision::Update([[maybe_unused]]double dt) {
    if (Engine::GetInput().KeyJustReleased(CS230::Input::Keys::Tab) == true) {
        enabled = !enabled;
    }
}

bool CS230::ShowCollision::Enabled() {
    return enabled;
}



================================================
FILE: source/Engine/ShowCollision.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  ShowCollision.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 17, 2025
*/
#pragma once
#include "Component.h"
#include "Engine.h"
namespace CS230 {
    class ShowCollision : public CS230::Component {
    public:
        ShowCollision();
        void Update(double dt) override;
        bool Enabled();
    private:
        bool enabled;
    };
}



================================================
FILE: source/Engine/Sprite.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Sprite.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 19, 2025
*/

#include "GameObject.h"
#include "Sprite.h"
#include "TextureManager.h"
#include "Logger.h"
#include "Path.h"
#include <fstream>

CS230::Sprite::Sprite(const std::filesystem::path& sprite_file, GameObject* _given_object) {
    Load(sprite_file, _given_object);
}

CS230::Sprite::~Sprite()
{
    for (Animation* animation : animations) {
        delete animation;
    }
    animations.clear();
}

CS230::Sprite::Sprite(Sprite&& temporary) noexcept :
    texture(std::move(temporary.texture)),
    hotspots(std::move(temporary.hotspots)),
    current_animation(temporary.current_animation),
    frame_size(temporary.frame_size),
    frame_texels(std::move(temporary.frame_texels)),
    animations(std::move(temporary.animations))
{}

CS230::Sprite& CS230::Sprite::operator=(Sprite && temporary) noexcept
{
    std::swap(texture, temporary.texture);
    std::swap(hotspots, temporary.hotspots);
    std::swap(current_animation, temporary.current_animation);
    std::swap(frame_size, temporary.frame_size);
    std::swap(frame_texels, frame_texels);
    std::swap(animations, temporary.animations);
    return *this;
}

void CS230::Sprite::Update(double dt)
{
    animations[current_animation]->Update(dt);
}

void CS230::Sprite::Load(const std::filesystem::path& sprite_file, GameObject* _given_object)
{
    const std::filesystem::path sprite_path = assets::locate_asset(sprite_file);
    given_object = _given_object;
    animations.clear();
    if (sprite_path.extension() != ".spt")
    {
        throw std::runtime_error(sprite_path.generic_string() + " is not a .spt file");
    }
    
    std::ifstream               in_file(sprite_path);

    if (in_file.is_open() == false) {
        throw std::runtime_error("Failed to load " + sprite_path.generic_string());
    }

    hotspots.clear();
    frame_texels.clear();

    std::string text;
    in_file >> text;
    texture = Engine::GetTextureManager().Load(text);
    frame_size = Engine::GetTextureManager().Load(text)->GetSize();

    in_file >> text;
    while (in_file.eof() == false) {
        if (text == "FrameSize") {
            in_file >> frame_size.x;
            in_file >> frame_size.y;
        }
        
        else if (text == "NumFrames") {
            int frame_count;
            in_file >> frame_count;
            for (int i = 0; i < frame_count; i++) {
                frame_texels.push_back({ frame_size.x * i, 0 });
            }
        }
        else if (text == "Frame") {
            int frame_location_x, frame_location_y;
            in_file >> frame_location_x;
            in_file >> frame_location_y;
            frame_texels.push_back({ frame_location_x, frame_location_y });
        }
        else if (text == "HotSpot") {
            int hotspot_x, hotspot_y;
            in_file >> hotspot_x;
            in_file >> hotspot_y;
            hotspots.push_back({ hotspot_x, hotspot_y });
        }
        else if (text == "Anim") {
            in_file >> text;
            animations.push_back(new Animation(text));
        }
        else if (text == "RectCollision") {
            Math::irect boundary;
            in_file >> boundary.point_1.x >> boundary.point_1.y >> boundary.point_2.x >> boundary.point_2.y;
            if (given_object == nullptr) {
                Engine::GetLogger().LogError("Cannot add collision to a null object");
            }
            else {
                given_object->AddGOComponent(new RectCollision(boundary, given_object));
            }
        }
        else if (text == "CircleCollision") {
            double radius;
            in_file >> radius;
            if (given_object == nullptr) {
                Engine::GetLogger().LogError("Cannot add collision to a null object");
            }
            else {
                given_object->AddGOComponent(new CircleCollision(radius, given_object));
            }
        }
        else {
            Engine::GetLogger().LogError("Unknown command: " + text);
        }
        in_file >> text;
    }
    if (frame_texels.empty() == true) {
        frame_texels.push_back({ 0,0 });
    }

    if (animations.empty() == true) {
        animations.push_back(new Animation());
        PlayAnimation(0);
    }
    

}

void CS230::Sprite::Draw(Math::TransformationMatrix display_matrix, unsigned int color, float depth)
{
	texture->Draw(display_matrix * Math::TranslationMatrix(-GetHotSpot(0)), GetFrameTexel(animations[current_animation]->CurrentFrame()), GetFrameSize(), color,depth);
}

Math::ivec2 CS230::Sprite::GetHotSpot(size_t index)
{
	if ( index > hotspots.size()) {
		Engine::GetLogger().LogDebug("Invalid index in hospot!");
		return Math::ivec2{ 0,0 };
	}
	return hotspots[index];
}

Math::ivec2 CS230::Sprite::GetFrameSize()
{
    return frame_size;
}

void CS230::Sprite::PlayAnimation(size_t animation)
{
    if (animation >= animations.size()) {
        Engine::GetLogger().LogDebug("Invalid index in animation!");
        current_animation = 0;
        return;
    }
    current_animation = animation;
    animations[current_animation]->Reset();
}

bool CS230::Sprite::AnimationEnded()
{
    return animations[current_animation]->Ended();
}

Math::ivec2 CS230::Sprite::GetFrameTexel(size_t index) const
{
    if ( index >= frame_texels.size()) {
        Engine::GetLogger().LogDebug("Invalid index in frametexles!");
        return Math::ivec2{ 0,0 };
    }
    return frame_texels[index];
}



================================================
FILE: source/Engine/Sprite.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Sprite.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 19, 2025
*/

#pragma once
#include <string>
#include "Vec2.h"
#include "Texture.h"
#include "Matrix.h"
#include "Engine.h"
#include "Animation.h"
#include "Component.h"
#include "Collision.h"


namespace CS230 {
    class GameObject;
    class Sprite : public Component {
    public:
        Sprite(const std::filesystem::path& sprite_file,GameObject* given_object);
        ~Sprite();

        Sprite(const Sprite&) = delete;
        Sprite& operator=(const Sprite&) = delete;

        Sprite(Sprite&& temporary) noexcept;
        Sprite& operator=(Sprite&& temporary) noexcept;
        void Update(double dt) override;
        void Load(const std::filesystem::path& sprite_file, GameObject* _given_object);
		void		Draw(Math::TransformationMatrix display_matrix, unsigned int color = 0xFFFFFFFF, float depth = 0.5f);
        Math::ivec2 GetHotSpot(size_t index);
        Math::ivec2 GetFrameSize();

        void PlayAnimation(size_t animation);
        bool AnimationEnded();

        const size_t& CurrentAnimation() const { return current_animation; }
    private:
        Math::ivec2 GetFrameTexel(size_t index) const;
        // Texture* texture;
        std::shared_ptr<CS230::Texture> texture;
        std::vector<Math::ivec2> hotspots;

        size_t current_animation;
        Math::ivec2 frame_size;
        std::vector<Math::ivec2> frame_texels;
        std::vector<Animation*> animations;

        GameObject* given_object;
    };
}



================================================
FILE: source/Engine/TextManager.cpp
================================================
#include "TextManager.h"


void TextManager::DrawText(const std::string& text, const Math::vec2& position, Fonts font, const Math::vec2& scale, CS200::RGBA color) const
{
    if (auto text_texture = fonts[font]->PrintToTexture(text, color); text_texture)
    {
        const auto transform = Math::TranslationMatrix(position) * Math::ScaleMatrix(scale);
        text_texture->Draw(transform, color);
    }
}



void TextManager::Init()
{
    add_font("Assets/fonts/Font_Simple.png");
    add_font("Assets/fonts/Font_Outlined.png");
}

void TextManager::add_font(const std::filesystem::path& file_name)
{
    fonts.push_back(std::make_unique<CS230::Font>(file_name));
}



================================================
FILE: source/Engine/TextManager.h
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par GAM200 Engine Porting
 * \copyright DigiPen Institute of Technology
 */
#include "Font.h"
#include "Fonts.h"
#include <memory>
#include <vector>

class TextManager
{
public:
    TextManager() = default;
    void Init();
    void DrawText(const std::string& text, const Math::vec2& position, Fonts font, const Math::vec2& scale = { 1.0, 1.0 }, CS200::RGBA color = CS200::WHITE) const;

private:
    // static CS230::Font* get_font(size_t);

    void add_font(const std::filesystem::path& file_name);

    std::vector<std::unique_ptr<CS230::Font>> fonts{};
};


================================================
FILE: source/Engine/Texture.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Texture.h"

#include "CS200/IRenderer2D.h"
#include "CS200/Image.h"
#include "Engine.h"
#include "Matrix.h"
#include "OpenGL/GL.h"
#include "TextureManager.h"
#include "Window.h"

namespace CS230
{

	void Texture::Draw([[maybe_unused]] const Math::TransformationMatrix& display_matrix, unsigned int color, float depth)
	{
		Draw(display_matrix, { 0, 0 }, image_size, color, depth);
	}

	void Texture::Draw(const Math::TransformationMatrix& display_matrix, Math::ivec2 texel_position, Math::ivec2 frame_size, unsigned int color, float depth)
	{
		CS200::IRenderer2D* renderer = Engine::GetTextureManager().GetRenderer2D();


		// OpenGL Texture: (0,0) Bottom-Left
		// Image Pixel: (0,0) Top-Left
		const double u_left	  = static_cast<double>(texel_position.x) / image_size.x;
		const double u_right  = static_cast<double>(texel_position.x + frame_size.x) / image_size.x;
		// V_top  = 1.0 - (y / height)
		// V_bottom  = 1.0 - ((y + h) / height)
		const double v_top	  = 1.0 - (static_cast<double>(texel_position.y) / image_size.y);
		const double v_bottom = 1.0 - (static_cast<double>(texel_position.y + frame_size.y) / image_size.y);

		const Math::vec2 texel_coord_bl = { u_left, v_bottom };
		const Math::vec2 texel_coord_tr = { u_right, v_top };

		Math::vec2 set_bottom_left{ frame_size.x * 0.5, frame_size.y * 0.5 };
		const auto world_transformation = display_matrix * Math::TranslationMatrix(set_bottom_left) * Math::ScaleMatrix(frame_size);

		renderer->DrawQuad(world_transformation, textureHandle, texel_coord_bl, texel_coord_tr, color, depth);
	}

	Math::ivec2 Texture::GetSize() const
	{
		return image_size;
	}

	Texture::~Texture()
	{
		GL::DeleteTextures(1, &textureHandle), textureHandle = 0;
	}

	Texture::Texture(Texture&& temporary) noexcept : image_size{ std::move(temporary.image_size) }, textureHandle{ std::move(temporary.textureHandle) }
	{
		temporary.textureHandle = 0;
		temporary.image_size	= { 0, 0 };
	}

	Texture& Texture::operator=(Texture&& temporary) noexcept
	{
		std::swap(image_size, (temporary.image_size));
		std::swap(textureHandle, temporary.textureHandle);
		return *this;
	}

	Texture::Texture(const std::filesystem::path& file_name)
	{
		const auto image = CS200::Image{ file_name, true };
		image_size		 = image.GetSize();
		textureHandle	 = OpenGL::CreateTextureFromImage(image, OpenGL::Filtering::NearestPixel, OpenGL::Wrapping::ClampToEdge);
	}

	Texture::Texture([[maybe_unused]] OpenGL::TextureHandle given_texture, [[maybe_unused]] Math::ivec2 the_size) : image_size{ the_size }, textureHandle{ given_texture }
	{
	}
}



================================================
FILE: source/Engine/Texture.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once

#include "CS200/Image.h"
#include "Matrix.h"
#include "OpenGL/Texture.h"
#include <filesystem>
#include <memory>

#include "Vec2.h"

namespace CS230
{
	class Font;

	/**
	 * \brief High-level texture wrapper for 2D graphics rendering and resource management
	 *
	 * Texture provides a convenient, RAII-compliant wrapper around OpenGL texture objects
	 * that simplifies texture loading, rendering, and resource management. The class handles
	 * the complex details of OpenGL texture creation, coordinate system transformations,
	 * and automatic memory cleanup while providing an intuitive interface for 2D graphics.
	 *
	 * Key Features:
	 * - Automatic texture loading from image files with proper format conversion
	 * - RAII resource management ensuring textures are properly cleaned up
	 * - High-level drawing interface with transformation matrix support
	 * - Sprite sheet support for animation and texture atlases
	 * - Integration with the 2D renderer for efficient batched rendering
	 * - Move semantics for efficient texture transfers and storage
	 *
	 * Resource Management:
	 * The texture automatically handles OpenGL texture creation and deletion through
	 * RAII principles. Move-only semantics prevent accidental texture duplication
	 * while allowing efficient transfer of texture ownership between objects.
	 *
	 * Coordinate Systems:
	 * The class handles the conversion between different coordinate systems:
	 * - Image coordinates (pixel-based, top-left origin)
	 * - Texture coordinates (normalized 0-1 range, bottom-left origin)
	 * - World coordinates (transformation matrix-based positioning)
	 *
	 * Common Use Cases:
	 * - Sprite rendering for games and interactive applications
	 * - UI element graphics and interface components
	 * - Texture atlas rendering for efficient sprite animation
	 * - Background and environment art rendering
	 * - Font glyph rendering (through Font class integration)
	 *
	 * The texture integrates seamlessly with the engine's transformation system,
	 * allowing for easy scaling, rotation, and positioning of graphics elements.
	 */
	class Texture
	{
	public:
		

		friend class TextureManager;
		friend class Font;

		/**
		 * \brief Draw the entire texture with transformation and color tinting
		 * \param display_matrix Transformation matrix for positioning, scaling, and rotation
		 * \param color RGBA color value for tinting the texture (default: white/no tint)
		 *
		 * Renders the complete texture to the screen using the provided transformation
		 * matrix to control positioning, scaling, and rotation. This is the primary
		 * method for drawing sprites, UI elements, and other texture-based graphics.
		 *
		 * Transformation Handling:
		 * The method automatically handles the necessary coordinate system conversions
		 * and applies appropriate scaling and translation to ensure the texture appears
		 * correctly positioned according to the transformation matrix. The texture is
		 * drawn with its center as the transformation origin.
		 *
		 * Color Tinting:
		 * The color parameter allows for real-time tinting of the texture without
		 * modifying the original image data. This enables effects like:
		 * - Color-based visual feedback (damage flashing, selection highlighting)
		 * - Transparency and fade effects through alpha channel modification
		 * - Uniform lighting or environmental color effects
		 * - UI state visualization (disabled buttons, hover states)
		 *
		 * Rendering Integration:
		 * The method integrates with the engine's 2D renderer for efficient batched
		 * rendering, automatically managing texture binding and shader state for
		 * optimal performance when drawing multiple textures.
		 */
		void Draw(const Math::TransformationMatrix& display_matrix, unsigned int color = 0xFFFFFFFF, float depth = 0.6f);

		/**
		 * \brief Draw a rectangular region of the texture (sprite sheet support)
		 * \param display_matrix Transformation matrix for positioning, scaling, and rotation
		 * \param texel_position Top-left corner position in pixel coordinates within the texture
		 * \param frame_size Size of the region to draw in pixels
		 * \param color RGBA color value for tinting the texture (default: white/no tint)
		 *
		 * Renders a specific rectangular region of the texture, enabling sprite sheet
		 * functionality, texture atlases, and animation frame rendering. This method
		 * is essential for efficient graphics where multiple sprites or animation
		 * frames are packed into a single texture file.
		 *
		 * Sprite Sheet Applications:
		 * - Character animation frames stored in a grid layout
		 * - UI element collections (buttons, icons, decorative elements)
		 * - Tile sets for 2D game environments
		 * - Font glyph rendering from character atlases
		 * - Particle effect textures with multiple variations
		 *
		 * Coordinate System:
		 * The texel_position uses pixel coordinates with (0,0) at the top-left
		 * of the texture, following standard image coordinate conventions. The
		 * method automatically converts these to the appropriate OpenGL texture
		 * coordinates for rendering.
		 *
		 * Performance Benefits:
		 * Using sprite sheets reduces texture binding overhead and improves
		 * rendering performance by allowing multiple related graphics to be
		 * stored in a single texture object, enabling more efficient batching.
		 *
		 * The transformation matrix affects the final rendered size and position,
		 * while frame_size determines which portion of the texture is sampled.
		 */
		void Draw(const Math::TransformationMatrix& display_matrix, Math::ivec2 texel_position, Math::ivec2 frame_size, unsigned int color = 0xFFFFFFFF, float depth = 0.f);

		/**
		 * \brief Get the dimensions of the texture in pixels
		 * \return Vector containing width and height of the texture
		 *
		 * Returns the original size of the texture as loaded from the image file,
		 * providing essential information for layout calculations, collision detection,
		 * and coordinate system conversions. This size information is particularly
		 * useful when working with sprite sheets or when precise positioning is required.
		 *
		 * Common uses:
		 * - Calculating sprite sheet frame positions and sizes
		 * - Determining collision boundaries for texture-based objects
		 * - Computing appropriate scaling factors for different screen resolutions
		 * - Layout calculations for UI elements and text rendering
		 * - Animation frame calculations and sprite positioning
		 *
		 * The returned size reflects the texture's native resolution and remains
		 * constant regardless of how the texture is drawn or transformed during rendering.
		 */
		Math::ivec2 GetSize() const;

		/**
		 * \brief Destructor ensuring proper OpenGL resource cleanup
		 *
		 * Automatically releases the underlying OpenGL texture object when the
		 * Texture instance is destroyed, preventing GPU memory leaks and ensuring
		 * proper resource management. This follows RAII principles to guarantee
		 * cleanup even in the presence of exceptions or early returns.
		 */
		~Texture();

		/**
		 * \brief Get the underlying OpenGL texture handle for advanced operations
		 * \return OpenGL texture handle for direct OpenGL operations
		 *
		 * Provides access to the raw OpenGL texture handle for advanced rendering
		 * operations that require direct OpenGL texture binding or integration
		 * with custom rendering systems. This method should be used sparingly
		 * and only when the high-level interface is insufficient.
		 *
		 * Advanced use cases:
		 * - Integration with custom shader programs
		 * - Direct OpenGL texture operations
		 * - Interfacing with third-party graphics libraries
		 * - Performance-critical rendering paths that bypass the 2D renderer
		 *
		 * Handle Ownership:
		 * The returned handle remains owned by the Texture object and should not
		 * be manually deleted or modified. The handle becomes invalid when the
		 * Texture object is destroyed.
		 */
		[[nodiscard]] OpenGL::TextureHandle GetHandle() const
		{
			return textureHandle;
		}


	private:
		// Private constructors - textures can only be created through TextureManager or Font
		// This ensures proper resource management and prevents accidental texture duplication
		explicit Texture(const std::filesystem::path& file_name);
		// for new texture!! check texturemanager!!
		Texture(OpenGL::TextureHandle given_texture, Math::ivec2 the_size);


	public:
		/**
		 * \brief Deleted copy constructor and assignment operator
		 *
		 * Textures use move-only semantics to prevent accidental duplication of
		 * OpenGL resources. Copying textures would require expensive GPU operations
		 * and could lead to resource management complications, so copy operations
		 * are explicitly disabled to encourage efficient resource usage patterns.
		 */
		Texture(const Texture&)			   = delete;
		Texture& operator=(const Texture&) = delete;

		/**
		 * \brief Move constructor for efficient texture transfer
		 * \param temporary Texture object to move from (will be left in valid but empty state)
		 *
		 * Efficiently transfers ownership of the OpenGL texture resource from one
		 * Texture object to another without copying GPU data. The source texture
		 * is left in a safe, destructible state with no valid texture handle.
		 *
		 * Move semantics enable:
		 * - Efficient storage of textures in containers (std::vector, std::map)
		 * - Return of textures from factory functions without copying
		 * - Transfer of texture ownership between different systems
		 * - Optimal performance when reorganizing texture collections
		 */
		Texture(Texture&& temporary) noexcept;

		/**
		 * \brief Move assignment operator for efficient texture replacement
		 * \param temporary Texture object to move from (will be left in valid but empty state)
		 * \return Reference to this texture after the move operation
		 *
		 * Replaces the current texture with another texture's resources using
		 * efficient move semantics. The previous texture resource is properly
		 * cleaned up, and the new resource is transferred without GPU data copying.
		 *
		 * The operation uses swap semantics to ensure exception safety and
		 * guarantee that both the old and new textures are handled correctly
		 * even if unexpected conditions occur during the transfer.
		 */
		Texture& operator=(Texture&& temporary) noexcept;


	private:


		// CS200::Image image; // use initialize member list -> or it will be initialized with default ctor -> but it doesn't exist!!
		Math::ivec2			  image_size;
		OpenGL::TextureHandle textureHandle;
	};
}



================================================
FILE: source/Engine/TextureManager.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */


#include "TextureManager.h"
#include "CS200/IRenderer2D.h"
#include "CS200/NDC.h"
#include "Engine.h"
#include "Logger.h"
#include "OpenGL/GL.h"
#include "Path.h"
#include "Texture.h"
#include "Window.h"

namespace CS230
{
	std::shared_ptr<Texture> TextureManager::Load(const std::filesystem::path& file_name)
	{
		const std::filesystem::path file_path = assets::locate_asset(file_name);
		if (textures.find(file_path) == textures.end())
		{
			// textures[file_name] = new Texture(file_name);
			textures[file_path] = std::shared_ptr<Texture>(new Texture(file_path));

			Engine::GetLogger().LogEvent("Loading Texture: " + file_path.string());
		}
		return textures[file_path];
	}

	void TextureManager::Init()
	{
        current_renderer_type = RendererType::Immediate;
		// Create and initialize new renderer
		switch (current_renderer_type)
		{
			case RendererType::Immediate: renderer2D = std::make_unique<CS200::ImmediateRenderer2D>(); break;
			case RendererType::Batch: renderer2D = std::make_unique<CS200::BatchRenderer2D>(); break;
			case RendererType::Instanced: renderer2D = std::make_unique<CS200::InstancedRenderer2D>(); break;
			default: renderer2D = std::make_unique<CS200::ImmediateRenderer2D>(); break;
		}

		if (renderer2D)
		{
			renderer2D->Init();
		}
		else
		{
			throw std::runtime_error("renderer initialize failed!");
		}
	}

	void TextureManager::Unload()
	{
		for (std::pair<std::filesystem::path, std::shared_ptr<Texture>> texture : textures)
		{
			// delete texture.second;
			Engine::GetLogger().LogEvent("Unload Texture: " + texture.first.string());
		}
		textures.clear();
	}

	void TextureManager::StartRenderTextureMode([[maybe_unused]] int width, [[maybe_unused]] int height)
	{
		// auto& renderer_2d = Engine::GetRenderer2D();
		auto& render_info = get_render_info();
		//  * - Ends current 2D renderer scene to ensure clean state transition
        CS200::IRenderer2D* renderer_2d = GetRenderer2D();
		renderer_2d->EndScene();

		//  * - Creates OpenGL framebuffer with color attachment of specified dimensions
		render_info.Size   = { width, height };
		render_info.Target = OpenGL::CreateFramebufferWithColor(Math::ivec2{ width, height });

		//  * - Saves current viewport, clear color, and rendering state for restoration
		GL::GetFloatv(GL_COLOR_CLEAR_VALUE, render_info.ClearColor.data());
		GL::GetIntegerv(GL_VIEWPORT, render_info.Viewport.data());

		//  * - Sets up Y-flipped coordinate system for proper texture orientation
		const auto ndc_matrix = Math::ScaleMatrix({ 1.0, -1.0 }) * CS200::build_ndc_matrix(render_info.Size);
		renderer_2d->BeginScene(ndc_matrix);

		//  * - Binds framebuffer as render target, replacing screen rendering
		GL::BindFramebuffer(GL_FRAMEBUFFER, render_info.Target.Framebuffer);
		GL::Viewport(0, 0, render_info.Size.x, render_info.Size.y);

		//  * - Clears render target with transparent black (0,0,0,0) for clean start
		GL::ClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		GL::Clear(GL_COLOR_BUFFER_BIT);
	}

	std::shared_ptr<Texture> TextureManager::EndRenderTextureMode()
	{
		CS200::IRenderer2D* renderer_2d = GetRenderer2D();
		auto& render_info = get_render_info();
		// * Cleanup and Restoration Process:
		//  * - Ends current 2D renderer scene to flush any pending draw operations
		renderer_2d->EndScene();
		//  * - Unbinds framebuffer (returns to default screen framebuffer 0)
		GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
		//  * - Restores original viewport dimensions from saved state
		GL::Viewport(render_info.Viewport[0], render_info.Viewport[1], render_info.Viewport[2], render_info.Viewport[3]);
		//  * - Restores original clear color values from saved state
		GL::ClearColor(render_info.ClearColor[0], render_info.ClearColor[1], render_info.ClearColor[2], render_info.ClearColor[3]);
		//  * - Begins new 2D renderer scene with screen-appropriate coordinate system
		renderer_2d->BeginScene(CS200::build_ndc_matrix(Engine::GetWindow().GetSize()));
		//  * - Deletes temporary framebuffer to free GPU resources
		auto framebuffer_to_delete = render_info.Target.Framebuffer;
		GL::DeleteFramebuffers(1, &framebuffer_to_delete);


		//          * Texture Creation:
		//  * Creates a new Texture object by wrapping the framebuffer's color attachment:
		auto scene_texture				   = new Texture(render_info.Target.ColorAttachment, render_info.Size);
		//  * - Transfers ownership of OpenGL texture ID from framebuffer to Texture object
		render_info.Target.ColorAttachment = 0; // old one
		//  * - Preserves original dimensions specified in StartRenderTextureMode()
		//  * - Maintains RGBA format with alpha channel for transparency support
		//  * - Content includes all drawing operations performed during render-to-texture mode
		return std::shared_ptr<Texture>(scene_texture);
	}

	void TextureManager::SwitchRenderer(RendererType type)
	{
		if (current_renderer_type == type)
			return; // Already using this renderer

		// Shutdown current renderer
		if (renderer2D)
		{
			renderer2D->Shutdown();
			renderer2D.reset();
		}

		// Create and initialize new renderer
		current_renderer_type = type;
		switch (type)
		{
			case RendererType::Immediate: renderer2D = std::make_unique<CS200::ImmediateRenderer2D>(); break;
			case RendererType::Batch: renderer2D = std::make_unique<CS200::BatchRenderer2D>(); break;
			case RendererType::Instanced: renderer2D = std::make_unique<CS200::InstancedRenderer2D>(); break;
			default: renderer2D = std::make_unique<CS200::ImmediateRenderer2D>(); break;
		}

		if (renderer2D)
		{
			renderer2D->Init();
		}
	}

	TextureManager::RendererType TextureManager::GetCurrentRendererType() const
	{
		return current_renderer_type;
	}

	CS200::IRenderer2D* TextureManager::GetRenderer2D()
	{
		return renderer2D.get();
	}

	void TextureManager::Shutdown()
	{
        renderer2D->Shutdown();
		renderer2D.reset();
	}
}



================================================
FILE: source/Engine/TextureManager.h
================================================


#pragma once
#include "CS200/BatchRenderer2D.h"
#include "CS200/InstancedRenderer2D.h"
#include "CS200/IRenderer2D.h"
#include "CS200/ImmediateRenderer2D.h"
#include "OpenGL/Framebuffer.h"
#include <filesystem>
#include <map>
#include <memory>
#include <unordered_map>
#include <vector>

namespace CS230
{
	class Texture;

	class TextureManager
	{
	public:
		enum class RendererType
		{
			Immediate,
			Batch,
			Instanced
		};

		std::shared_ptr<Texture> Load(const std::filesystem::path& file_name);

		void							Init();
		void							Unload();
		static void						StartRenderTextureMode(int width, int height);
		static std::shared_ptr<Texture> EndRenderTextureMode();
		void							SwitchRenderer(RendererType type);
		RendererType					GetCurrentRendererType() const;
		static CS200::IRenderer2D*		GetRenderer2D();
		void							Shutdown();


	private:
		RendererType									  current_renderer_type = RendererType::Batch;
		inline static std::unique_ptr<CS200::IRenderer2D> renderer2D{};

		std::map<std::filesystem::path, std::shared_ptr<Texture>> textures;

		struct RenderInfo
		{
			// RenderInfo() = default;
			OpenGL::FramebufferWithColor Target{};
			Math::ivec2					 Size{};
			std::array<GLfloat, 4>		 ClearColor{};
			std::array<GLint, 4>		 Viewport{};
		};

		// inline static RenderInfo render_info{};

		static RenderInfo& get_render_info()
		{
			static RenderInfo instance;
			return instance;
		}
	};
}



================================================
FILE: source/Engine/Timer.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <chrono>
#include "Component.h"
namespace util
{
    class [[nodiscard]] Timer : public CS230::Component{
    private:
        using clock_t  = std::chrono::steady_clock;
        using second_t = std::chrono::duration<double, std::ratio<1>>;

        std::chrono::time_point<clock_t> timeStamp;

    public:
        Timer() noexcept : timeStamp(clock_t::now())
        {
        }

        void ResetTimeStamp() noexcept
        {
            timeStamp = clock_t::now();
        }

        double GetElapsedSeconds() const noexcept
        {
            return std::chrono::duration_cast<second_t>(clock_t::now() - timeStamp).count();
        }
    };
}



================================================
FILE: source/Engine/Vec2.cpp
================================================
/**
 * \file
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Vec2.h"
#include <cmath>

namespace Math
{
    ivec2::ivec2(const vec2& v) noexcept : x(static_cast<int>(v.x)), y(static_cast<int>(v.y))
    {
    }

     ivec2& ivec2::operator+=(const ivec2& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }

     ivec2& ivec2::operator-=(const ivec2& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }

     ivec2& ivec2::operator*=(int scalar) noexcept
    {
        x *= scalar;
        y *= scalar;
        return *this;
    }

     ivec2& ivec2::operator/=(int scalar) noexcept
    {
        x /= scalar;
        y /= scalar;
        return *this;
    }

     ivec2 ivec2::operator+() const noexcept
    {
        ivec2 new_vec{ this->x, this->y };
        return new_vec;
    }

     ivec2 ivec2::operator-() const noexcept
    {
        ivec2 new_vec{ -this->x, -this->y };
        return new_vec;
    }

    double ivec2::Length()
    {
        return std::sqrt(x* x + y*y);
    }

     ivec2 operator+(const ivec2& lhs, const ivec2& rhs) noexcept
    {
        ivec2 new_vec{ lhs.x + rhs.x, lhs.y + rhs.y };
        return new_vec;
    }

     ivec2 operator-(const ivec2& lhs, const ivec2& rhs) noexcept
    {
        ivec2 new_vec{ lhs.x - rhs.x, lhs.y - rhs.y };
        return new_vec;
    }

     ivec2 operator*(const ivec2& v, int scalar) noexcept
    {
        ivec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     ivec2 operator*(int scalar, const ivec2& v) noexcept
    {
        ivec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }
    

     ivec2 operator/(const ivec2& v, int scalar) noexcept
    {
        ivec2 new_vec{ v.x / scalar, v.y / scalar };
        return new_vec;
    }

     bool operator==(const ivec2& lhs, const ivec2& rhs) noexcept
    {
        return (lhs.x == rhs.x) && (lhs.y == rhs.y);
    }

     bool operator!=(const ivec2& lhs, const ivec2& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    std::ostream& operator<<(std::ostream& os, const ivec2& v)
    {
        os << v.x << ", " << v.y << "\n";
        return os;
    }

    std::istream& operator>>(std::istream& is, ivec2& v)
    {
        is >> v.x >> v.y;
        return is;
    }

    /*===============================ivec3==================================*/

    ivec3::ivec3(const vec3& v) noexcept : x(static_cast<int>(v.x)), y(static_cast<int>(v.y)), z(static_cast<int>(v.z))
    {
    }

     ivec3& ivec3::operator+=(const ivec3& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

     ivec3& ivec3::operator-=(const ivec3& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

     ivec3& ivec3::operator*=(int scalar) noexcept
    {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

     ivec3& ivec3::operator/=(int scalar) noexcept
    {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }

     ivec3 ivec3::operator+() const noexcept
    {
        ivec3 new_vec{ this->x, this->y, this->z };
        return new_vec;
    }

     ivec3 ivec3::operator-() const noexcept
    {
        ivec3 new_vec{ -this->x, -this->y, -this->z };
        return new_vec;
    }

    double ivec3::Length()
    {
        return std::sqrt(x*x + y*y + z*z);
    }

     ivec3 operator+(const ivec3& lhs, const ivec3& rhs) noexcept
    {
        ivec3 new_vec{ lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z };
        return new_vec;
    }

     ivec3 operator-(const ivec3& lhs, const ivec3& rhs) noexcept
    {
        ivec3 new_vec{ lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z };
        return new_vec;
    }

     ivec3 operator*(const ivec3& v, int scalar) noexcept
    {
        ivec3 new_vec{ v.x * scalar, v.y * scalar, v.z * scalar };
        return new_vec;
    }

     ivec3 operator*(int scalar, const ivec3& v) noexcept
    {
        ivec3 new_vec{ v.x * scalar, v.y * scalar, v.z * scalar };
        return new_vec;
    }

     ivec3 operator/(const ivec3& v, int scalar) noexcept
    {
        ivec3 new_vec{ v.x / scalar, v.y / scalar, v.z / scalar };
        return new_vec;
    }

     bool operator==(const ivec3& lhs, const ivec3& rhs) noexcept
    {
        return (lhs.x == rhs.x) && (lhs.y == rhs.y) && (lhs.z == rhs.z);
    }

     bool operator!=(const ivec3& lhs, const ivec3& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    std::ostream& operator<<(std::ostream& os, const ivec3& v)
    {
        os << v.x << ", " << v.y << v.z << "\n";
        return os;
    }

    std::istream& operator>>(std::istream& is, ivec3& v)
    {
        is >> v.x >> v.y >> v.z;
        return is;
    }

    /*===========================vec2=================================================*/
     vec2& vec2::operator+=(const vec2& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }

     vec2& vec2::operator-=(const vec2& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }

     vec2& vec2::operator*=(int scalar) noexcept
    {
        x *= scalar;
        y *= scalar;
        return *this;
    }

     vec2& vec2::operator/=(int scalar) noexcept
    {
        x /= scalar;
        y /= scalar;
        return *this;
    }

     vec2 vec2::operator+() const noexcept
    {
        vec2 new_vec{ this->x, this->y };
        return new_vec;
    }

     vec2 vec2::operator-() const noexcept
    {
        vec2 new_vec{ -this->x, -this->y };
        return new_vec;
    }

     double vec2::Length() const noexcept
    {
        return std::sqrt(x*x + y*y);
    }

    vec2 vec2::Normalize()
    {
        vec2 normalized = {x/Length(),y/Length()};
        return normalized;
    }

     vec2 operator+(const vec2& lhs, const vec2& rhs) noexcept
    {
        vec2 new_vec{ lhs.x + rhs.x, lhs.y + rhs.y };
        return new_vec;
    }

     vec2 operator-(const vec2& lhs, const vec2& rhs) noexcept
    {
        vec2 new_vec{ lhs.x - rhs.x, lhs.y - rhs.y };
        return new_vec;
    }

     vec2 operator*(const vec2& v, int scalar) noexcept
    {
        vec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     vec2 operator*(int scalar, const vec2& v) noexcept
    {
        vec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     vec2 operator*(const vec2& v, double scalar) noexcept
    {
        vec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     vec2 operator*(double scalar, const vec2& v) noexcept
    {
        vec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     vec2 operator/(const vec2& v, int scalar) noexcept
    {
        vec2 new_vec{ v.x / scalar, v.y / scalar };
        return new_vec;
    }

     bool operator==(const vec2& lhs, const vec2& rhs) noexcept
    {
        return (lhs.x == rhs.x) && (lhs.y == rhs.y);
    }

     bool operator!=(const vec2& lhs, const vec2& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    std::ostream& operator<<(std::ostream& os, const vec2& v)
    {
        os << v.x << ", " << v.y << "\n";
        return os;
    }

    std::istream& operator>>(std::istream& is, vec2& v)
    {
        is >> v.x >> v.y;
        return is;
    }

    /*===========================fvec2=================================================*/
     fvec2& fvec2::operator+=(const fvec2& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }

     fvec2& fvec2::operator-=(const fvec2& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }

     fvec2& fvec2::operator*=(int scalar) noexcept
    {
        x *= static_cast<float>(scalar);
        y *= static_cast<float>(scalar);
        return *this;
    }

     fvec2& fvec2::operator/=(int scalar) noexcept
    {
        x /= static_cast<float>(scalar);
        y /= static_cast<float>(scalar);
        return *this;
    }

     fvec2 fvec2::operator+() const noexcept
    {
        fvec2 new_vec{ this->x, this->y };
        return new_vec;
    }

     fvec2 fvec2::operator-() const noexcept
    {
        fvec2 new_vec{ -this->x, -this->y };
        return new_vec;
    }

     float fvec2::Length() const noexcept
    {
        return std::sqrt(x*x + y*y);
    }

    fvec2 fvec2::Normalize()
    {
        fvec2 normalized = {x/Length(),y/Length()};
        return normalized;
    }

     fvec2 operator+(const fvec2& lhs, const fvec2& rhs) noexcept
    {
        fvec2 new_vec{ lhs.x + rhs.x, lhs.y + rhs.y };
        return new_vec;
    }

     fvec2 operator-(const fvec2& lhs, const fvec2& rhs) noexcept
    {
        fvec2 new_vec{ lhs.x - rhs.x, lhs.y - rhs.y };
        return new_vec;
    }

     fvec2 operator*(const fvec2& v, int scalar) noexcept
    {
        fvec2 new_vec{ v.x * static_cast<float>(scalar), v.y * static_cast<float>(scalar) };
        return new_vec;
    }

     fvec2 operator*(int scalar, const fvec2& v) noexcept
    {
        fvec2 new_vec{ v.x * static_cast<float>(scalar), v.y * static_cast<float>(scalar) };
        return new_vec;
    }

     fvec2 operator*(const fvec2& v, float scalar) noexcept
    {
        fvec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     fvec2 operator*(float scalar, const fvec2& v) noexcept
    {
        fvec2 new_vec{ v.x * scalar, v.y * scalar };
        return new_vec;
    }

     fvec2 operator/(const fvec2& v, int scalar) noexcept
    {
        fvec2 new_vec{ v.x / static_cast<float>(scalar), v.y / static_cast<float>(scalar) };
        return new_vec;
    }

     bool operator==(const fvec2& lhs, const fvec2& rhs) noexcept
    {
        return (lhs.x == rhs.x) && (lhs.y == rhs.y);
    }

     bool operator!=(const fvec2& lhs, const fvec2& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    std::ostream& operator<<(std::ostream& os, const fvec2& v)
    {
        os << v.x << ", " << v.y << "\n";
        return os;
    }

    std::istream& operator>>(std::istream& is, fvec2& v)
    {
        is >> v.x >> v.y;
        return is;
    }

	vec2 to_vec2(const fvec2& rhs)
	{
        return {static_cast<double>(rhs.x), static_cast<double>(rhs.y)};
    }

	vec2 to_vec2(const ivec2& rhs)
	{
		return {static_cast<double>(rhs.x), static_cast<double>(rhs.y)};
	}

	fvec2 to_fvec2(const vec2& rhs)
	{
        return {static_cast<float>(rhs.x), static_cast<float>(rhs.y)};
    }

	fvec2 to_fvec2(const ivec2& rhs)
	{
		return {static_cast<float>(rhs.x), static_cast<float>(rhs.y)};
	}

	ivec2 to_ivec2(const fvec2& rhs)
	{
		return {static_cast<int>(rhs.x), static_cast<int>(rhs.y)};
	}

	ivec2 to_ivec2(const vec2& rhs)
	{
		return {static_cast<int>(rhs.x), static_cast<int>(rhs.y)};
	}

	/*===============================vec3==================================*/
     vec3& vec3::operator+=(const vec3& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

     vec3& vec3::operator-=(const vec3& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

     vec3& vec3::operator*=(int scalar) noexcept
    {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

     vec3& vec3::operator/=(int scalar) noexcept
    {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }

     vec3 vec3::operator+() const noexcept
    {
        vec3 new_vec{ this->x, this->y, this->z };
        return new_vec;
    }

     vec3 vec3::operator-() const noexcept
    {
        vec3 new_vec{ -this->x, -this->y, -this->z };
        return new_vec;
    }

    double vec3::Length()
    {
        return std::sqrt(x*x + y*y + z*z);
    }

     vec3 operator+(const vec3& lhs, const vec3& rhs) noexcept
    {
        vec3 new_vec{ lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z };
        return new_vec;
    }

     vec3 operator-(const vec3& lhs, const vec3& rhs) noexcept
    {
        vec3 new_vec{ lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z };
        return new_vec;
    }

     vec3 operator*(const vec3& v, int scalar) noexcept
    {
        vec3 new_vec{ v.x * scalar, v.y * scalar, v.z * scalar };
        return new_vec;
    }

     vec3 operator*(int scalar, const vec3& v) noexcept
    {
        vec3 new_vec{ v.x * scalar, v.y * scalar, v.z * scalar };
        return new_vec;
    }

     vec3 operator/(const vec3& v, int scalar) noexcept
    {
        vec3 new_vec{ v.x / scalar, v.y / scalar, v.z / scalar };
        return new_vec;
    }

     bool operator==(const vec3& lhs, const vec3& rhs) noexcept
    {
        return (lhs.x == rhs.x) && (lhs.y == rhs.y) && (lhs.z == rhs.z);
    }

     bool operator!=(const vec3& lhs, const vec3& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    std::ostream& operator<<(std::ostream& os, const vec3& v)
    {
        os << v.x << ", " << v.y << v.z << "\n";
        return os;
    }

    std::istream& operator>>(std::istream& is, vec3& v)
    {
        is >> v.x >> v.y >> v.z;
        return is;
    }
}



================================================
FILE: source/Engine/Vec2.h
================================================
/**
 * \file
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include <cmath>
#include <iostream>
#include <limits>

namespace Math
{


    struct vec2;
    struct vec3;

    struct [[nodiscard]] ivec2
    {
        int x{ 0 };
        int y{ 0 };

        // Constructors
        ivec2() noexcept = default;
        // ivec2(int _x, int _y) noexcept : x(_x), y(_y) { };
        constexpr ivec2(int _x, int _y) noexcept : x(_x), y(_y) { };
        // ivec2(const ivec2& rhs) = default;
        //  ivec2(int xy) noexcept;

        // Conversion
        ivec2(const vec2& v) noexcept;

        // Arithmetic operators
        ivec2& operator+=(const ivec2& rhs) noexcept;
        ivec2& operator-=(const ivec2& rhs) noexcept;
        ivec2& operator*=(int scalar) noexcept;
        ivec2& operator/=(int scalar) noexcept;

        // Unary operators
        ivec2 operator+() const noexcept;
        ivec2 operator-() const noexcept;

        // length
        double Length();
    };

    // Non-member operators
    ivec2 operator+(const ivec2& lhs, const ivec2& rhs) noexcept;
    ivec2 operator-(const ivec2& lhs, const ivec2& rhs) noexcept;
    ivec2 operator*(const ivec2& v, int scalar) noexcept;
    ivec2 operator*(int scalar, const ivec2& v) noexcept;
    ivec2 operator/(const ivec2& v, int scalar) noexcept;

    // Comparison operators
    bool operator==(const ivec2& lhs, const ivec2& rhs) noexcept;
    bool operator!=(const ivec2& lhs, const ivec2& rhs) noexcept;

    // Stream operators
    std::ostream& operator<<(std::ostream& os, const ivec2& v);
    std::istream& operator>>(std::istream& is, ivec2& v);

    struct ivec3
    {
        int x{ 0 };
        int y{ 0 };
        int z{ 0 };

        // Constructors
        ivec3() noexcept = default;
        ivec3(int _x, int _y, int _z) noexcept : x(_x), y(_y), z(_z) { };
        // ivec3(const ivec3& rhs) = default;
        //  ivec3(int xy) noexcept;

        // Conversion
        ivec3(const vec3& v) noexcept;

        // Arithmetic operators
        ivec3& operator+=(const ivec3& rhs) noexcept;
        ivec3& operator-=(const ivec3& rhs) noexcept;
        ivec3& operator*=(int scalar) noexcept;
        ivec3& operator/=(int scalar) noexcept;

        // Unary operators
        ivec3 operator+() const noexcept;
        ivec3 operator-() const noexcept;

        // length
        double Length();
    };

    // Non-member operators
    ivec3 operator+(const ivec3& lhs, const ivec3& rhs) noexcept;
    ivec3 operator-(const ivec3& lhs, const ivec3& rhs) noexcept;
    ivec3 operator*(const ivec3& v, int scalar) noexcept;
    ivec3 operator*(int scalar, const ivec3& v) noexcept;
    ivec3 operator/(const ivec3& v, int scalar) noexcept;

    // Comparison operators
    bool operator==(const ivec3& lhs, const ivec3& rhs) noexcept;
    bool operator!=(const ivec3& lhs, const ivec3& rhs) noexcept;

    // Stream operators
    std::ostream& operator<<(std::ostream& os, const ivec3& v);
    std::istream& operator>>(std::istream& is, ivec3& v);

    struct vec2
    {
        double x{ 0 };
        double y{ 0 };

        // Constructors
        vec2() noexcept = default;
        constexpr vec2(double _x, double _y) noexcept : x(_x), y(_y) { };
        //  vec2(const vec2& v) noexcept = default;
        // vec2(const vec2& rhs) = default;
        //  vec2(int xy) noexcept;

        // Conversion
        vec2(const ivec2& v) noexcept : x(static_cast<double>(v.x)), y(static_cast<double>(v.y)) { };

        // Arithmetic operators
        vec2& operator+=(const vec2& rhs) noexcept;
        vec2& operator-=(const vec2& rhs) noexcept;
        vec2& operator*=(int scalar) noexcept;
        vec2& operator/=(int scalar) noexcept;

        // Unary operators
        vec2 operator+() const noexcept;
        vec2 operator-() const noexcept;

        // length
        double Length() const noexcept;

        bool operator<(const vec2& other) const
        {
            return (x < other.x) || (x == other.x && y < other.y);
        }

        // normalize
        vec2 Normalize();
    };

    // Non-member operators
    vec2 operator+(const vec2& lhs, const vec2& rhs) noexcept;
    vec2 operator-(const vec2& lhs, const vec2& rhs) noexcept;
    vec2 operator*(const vec2& v, int scalar) noexcept;
    vec2 operator*(int scalar, const vec2& v) noexcept;
    vec2 operator*(const vec2& v, double scalar) noexcept;
    vec2 operator*(double scalar, const vec2& v) noexcept;
    vec2 operator/(const vec2& v, int scalar) noexcept;

    // Comparison operators
    bool operator==(const vec2& lhs, const vec2& rhs) noexcept;
    bool operator!=(const vec2& lhs, const vec2& rhs) noexcept;

    // Stream operators
    std::ostream& operator<<(std::ostream& os, const vec2& v);
    std::istream& operator>>(std::istream& is, vec2& v);

    struct fvec2
    {
        float x{ 0 };
        float y{ 0 };

        // Constructors
        fvec2() noexcept = default;
        constexpr fvec2(float _x, float _y) noexcept : x(_x), y(_y) { };
        //  vec2(const vec2& v) noexcept = default;
        // vec2(const vec2& rhs) = default;
        //  vec2(int xy) noexcept;

        // Conversion
        fvec2(const ivec2& v) noexcept : x(static_cast<float>(v.x)), y(static_cast<float>(v.y)) { };

        // Arithmetic operators
        fvec2& operator+=(const fvec2& rhs) noexcept;
        fvec2& operator-=(const fvec2& rhs) noexcept;
        fvec2& operator*=(int scalar) noexcept;
        fvec2& operator/=(int scalar) noexcept;

        // Unary operators
        fvec2 operator+() const noexcept;
        fvec2 operator-() const noexcept;

        // length
        float Length() const noexcept;

        bool operator<(const fvec2& other) const
        {
            return (x < other.x) || (x == other.x && y < other.y);
        }

        // normalize
        fvec2 Normalize();
    };

    // Non-member operators
    fvec2 operator+(const fvec2& lhs, const fvec2& rhs) noexcept;
    fvec2 operator-(const fvec2& lhs, const fvec2& rhs) noexcept;
    fvec2 operator*(const fvec2& v, int scalar) noexcept;
    fvec2 operator*(int scalar, const fvec2& v) noexcept;
    fvec2 operator*(const fvec2& v, float scalar) noexcept;
    fvec2 operator*(float scalar, const fvec2& v) noexcept;
    fvec2 operator/(const fvec2& v, int scalar) noexcept;

    // Comparison operators
    bool operator==(const fvec2& lhs, const fvec2& rhs) noexcept;
    bool operator!=(const fvec2& lhs, const fvec2& rhs) noexcept;

    // Stream operators
    std::ostream& operator<<(std::ostream& os, const fvec2& v);
    std::istream& operator>>(std::istream& is, fvec2& v);

    vec2 to_vec2(const fvec2& rhs);
    vec2 to_vec2(const ivec2& rhs);
    
    fvec2 to_fvec2(const vec2& rhs);
    fvec2 to_fvec2(const ivec2& rhs);

    ivec2 to_ivec2(const fvec2& rhs);
    ivec2 to_ivec2(const vec2& rhs);
    

    struct vec3
    {
        double x{ 0 };
        double y{ 0 };
        double z{ 0 };

        // Constructors
        vec3() noexcept = default;
        vec3(double _x, double _y, double _z) noexcept : x(_x), y(_y), z(_z) { };
        // vec3(const vec3& rhs) = default;
        //  vec3(int xy) noexcept;

        // Conversion
        vec3(const ivec3& v) noexcept : x(static_cast<double>(v.x)), y(static_cast<double>(v.y)), z(static_cast<double>(v.z)) { };

        // Arithmetic operators
        vec3& operator+=(const vec3& rhs) noexcept;
        vec3& operator-=(const vec3& rhs) noexcept;
        vec3& operator*=(int scalar) noexcept;
        vec3& operator/=(int scalar) noexcept;

        // Unary operators
        vec3 operator+() const noexcept;
        vec3 operator-() const noexcept;

        // length
        double Length();
    };

    // Non-member operators
    vec3 operator+(const vec3& lhs, const vec3& rhs) noexcept;
    vec3 operator-(const vec3& lhs, const vec3& rhs) noexcept;
    vec3 operator*(const vec3& v, int scalar) noexcept;
    vec3 operator*(int scalar, const vec3& v) noexcept;
    vec3 operator/(const vec3& v, int scalar) noexcept;

    // Comparison operators
    bool operator==(const vec3& lhs, const vec3& rhs) noexcept;
    bool operator!=(const vec3& lhs, const vec3& rhs) noexcept;

    // Stream operators
    std::ostream& operator<<(std::ostream& os, const vec3& v);
    std::istream& operator>>(std::istream& is, vec3& v);
}



================================================
FILE: source/Engine/Window.cpp
================================================
/**
 * \file Window.cpp
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#include "Window.h"
#include "../OpenGL/GL.h"
#include "CS200/RenderingAPI.h"
#include "Engine.h"
#include "Error.h"
#include "Logger.h"
#include <GL/glew.h>
#include <SDL.h>
#include <functional>
#include <sstream>

namespace
{
    void hint_gl(SDL_GLattr attr, int value)
    {
        // // https://wiki.libsdl.org/SDL2/SDL_GL_SetAttribute
        if (const auto success = SDL_GL_SetAttribute(attr, value); success != 0)
        {
            Engine::GetLogger().LogError(std::string{ "Failed to Set GL Attribute: " } + SDL_GetError());
        }
    }
}

namespace CS230
{

    /*Basic setup*/
    void Window::setupSDLWindow(std::string_view title)
    {
        // Part 1 - Initialize SDL for visual use
        if (SDL_Init(SDL_INIT_VIDEO) < 0)
        {
            throw_error_message("Failed to init SDK error: ", SDL_GetError());
        }

// Part 2 - Configure OpenGL context attributes (before window creation)
#if defined(IS_WEBGL2)
        hint_gl(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
        hint_gl(SDL_GL_CONTEXT_MINOR_VERSION, 0);
        hint_gl(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
#else
        hint_gl(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
#endif
        hint_gl(SDL_GL_DOUBLEBUFFER, true);
        hint_gl(SDL_GL_STENCIL_SIZE, 8);
        hint_gl(SDL_GL_DEPTH_SIZE, 24);
        hint_gl(SDL_GL_RED_SIZE, 8);
        hint_gl(SDL_GL_GREEN_SIZE, 8);
        hint_gl(SDL_GL_BLUE_SIZE, 8);
        hint_gl(SDL_GL_ALPHA_SIZE, 8);
        hint_gl(SDL_GL_MULTISAMPLEBUFFERS, 1);
        hint_gl(SDL_GL_MULTISAMPLESAMPLES, 4);

        // Part 3 - Create the SDL window
        sdl_window = SDL_CreateWindow(title.data(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, default_width, default_height, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
        if (sdl_window == nullptr)
        {
            throw_error_message("Failed to create window: ", SDL_GetError());
        }
    }

    /*Setup GL*/
    void Window::setupOpenGL()
    {
        // Create OpenGL context
        if (gl_context = SDL_GL_CreateContext(sdl_window); gl_context == nullptr)
        {
            throw_error_message("Failed to create opengl context: ", SDL_GetError());
        }

        // Make context current
        SDL_GL_MakeCurrent(sdl_window, gl_context);

        // Initialize GLEW for extension loading
        if (const auto result = glewInit(); GLEW_OK != result)
        {
            throw_error_message("Unable to initialize GLEW - error: ", glewGetErrorString(result));
        }

        // Configure VSync
        constexpr int ADAPTIVE_VSYNC = -1;
        constexpr int VSYNC          = 1;
        if (const auto result = SDL_GL_SetSwapInterval(ADAPTIVE_VSYNC); result != 0)
        {
            SDL_GL_SetSwapInterval(VSYNC);
        }

        // Initialize our rendering abstraction layer
        CS200::RenderingAPI::Init();
    }

    void Window::Start(std::string_view title)
    {
        setupSDLWindow(title);
        setupOpenGL();
        window_size.x = default_width;
        window_size.y = default_height;

        // Get actual drawable size for high-DPI displays
        SDL_GL_GetDrawableSize(sdl_window, &window_size.x, &window_size.y);


        GL::Viewport(0, 0, window_size.x, window_size.y);

        // Set initial clear color through our rendering abstraction
        CS200::RenderingAPI::SetClearColor(default_background);
    }

    void Window::Update()
    {
        SDL_GL_SwapWindow(sdl_window);


        SDL_Event event{ 0 };
        while (SDL_PollEvent(&event) != 0)
        {
            eventCallback(event);

            switch (event.window.event)
            {
                case SDL_WINDOWEVENT_CLOSE: closed = true; break;
                case SDL_WINDOWEVENT_RESIZED: window_size = { event.window.data1, event.window.data2 }; break;
                case SDL_WINDOWEVENT_SIZE_CHANGED:
                    SDL_GL_GetDrawableSize(sdl_window, &window_size.x, &window_size.y);
                    GL::Viewport(0, 0, window_size.x, window_size.y);
                    break;
                    break;
                default: break;
            }
        }
    }

    bool Window::IsClosed() const
    {
        return closed;
    }

    void Window::Clear(CS200::RGBA color)
    {
        auto c = CS200::unpack_color(color);
        GL::ClearColor(c[0], c[1], c[2], c[3]);
        GL::Clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    void Window::ForceResize(int desired_width, int desired_height)
    {
        SDL_SetWindowSize(sdl_window, desired_width, desired_height);
        window_size.x = desired_width;
        window_size.y = desired_height;
    }

    void Window::SetWindowPosition(int x, int y)
    {
        SDL_SetWindowPosition(sdl_window,x,y);
    }

    SDL_Window* Window::GetSDLWindow() const
    {
        return sdl_window;
    }

    SDL_GLContext Window::GetGLContext() const
    {
        return gl_context;
    }

    void Window::SetEventCallback(WindowEventCallback callback)
    {
        eventCallback = std::move(callback);
    }

    float Window::background_r = 0.0f;
    float Window::background_g = 0.0f;
    float Window::background_b = 0.0f;

    void Window::SetBackgroundColor(float r, float g, float b) noexcept
    {
        background_r = r;
        background_g = g;
        background_b = b;
    }

    //Math::ivec2 Window::GetWindowSize() const
    //{
    //    return window_size;
    //}

    Window::~Window()
    {
        if (gl_context)
        {
            SDL_GL_DeleteContext(gl_context);
        }
        if (sdl_window)
        {
            SDL_DestroyWindow(sdl_window);
        }

        SDL_Quit();
    }
}



================================================
FILE: source/Engine/Window.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Jonathan Holmes
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include "CS200/RGBA.h"
#include "Vec2.h"
#include <functional>
#include <gsl/gsl>
#include <string_view>

struct SDL_Window;
typedef void*           SDL_GLContext;
typedef union SDL_Event SDL_Event;

namespace CS230
{
    class Window
    {
    public:
        Window() noexcept = default;
        ~Window();

        Window(const Window&)                = delete;
        Window& operator=(const Window&)     = delete;
        Window(Window&&) noexcept            = delete;
        Window& operator=(Window&&) noexcept = delete;

    public:
        void Start(std::string_view title);
        void Update();
        bool IsClosed() const;

        [[nodiscard]] Math::ivec2 GetSize() const noexcept
        {
            return { window_size.x, window_size.y };
        }

        double GetAspectRatio() const noexcept
        {
            return static_cast<double>(window_size.x) / static_cast<double>(window_size.y);
		}

        void          Clear(CS200::RGBA color);
        void          ForceResize(int w, int h);
        void          SetWindowPosition(int x, int y);
        SDL_Window*   GetSDLWindow() const;
        SDL_GLContext GetGLContext() const;

        using WindowEventCallback = std::function<void(const SDL_Event&)>;
        void SetEventCallback(WindowEventCallback callback);

        static void SetBackgroundColor(float r, float g, float b) noexcept;

        // Math::ivec2 GetWindowSize() const;

    private:

        void setupSDLWindow(std::string_view title);
        void setupOpenGL();


        const int                     default_width      = 800;
        const int                     default_height     = 600;
        Math::ivec2                   window_size        = { default_width, default_height };
        static constexpr unsigned int default_background = UINT_MAX;
        static constexpr CS200::RGBA  default_background1{ CS200::WHITE };

        gsl::owner<SDL_Window*>   sdl_window = nullptr;
        gsl::owner<SDL_GLContext> gl_context = nullptr;
        bool                      closed     = false;
        // Math::ivec2               size       = { 800, 600 };

        WindowEventCallback eventCallback;

        std::function<void(SDL_Event)> func_event_callback;
        static float                   background_r;
        static float                   background_g;
        static float                   background_b;
    };
}



================================================
FILE: source/Game/Background.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Background.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 29, 2025
*/

#include "Background.h"
#include "../Engine/TextureManager.h"

void Background::Add(const std::filesystem::path& texture_path, double speed){
	backgrounds.push_back(ParallaxLayer{Engine::GetTextureManager().Load(texture_path),speed});
}

void Background::Unload(){
	backgrounds.clear();
}

void Background::Draw(const CS230::Camera& camera) {
    for (ParallaxLayer& background : backgrounds) {
        Math::vec2 inverted_position = -Math::vec2{ camera.GetPosition().x * background.speed, camera.GetPosition().y };
        Math::TranslationMatrix new_matrix = Math::TranslationMatrix(inverted_position);
        background.texture->Draw(new_matrix);
    }
}

Math::ivec2 Background::GetSize()
{
	return backgrounds.back().texture->GetSize();
}



================================================
FILE: source/Game/Background.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Background.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 29, 2025
*/

#pragma once
#include "../Engine/Engine.h"
#include "../Engine/Texture.h"
#include "../Engine/Camera.h"
#include "../Engine/Component.h"

class Background : public CS230::Component{
public:
    void Add(const std::filesystem::path& texture_path, double speed);
    void Unload();
    void Draw(const CS230::Camera& camera);
    Math::ivec2 GetSize();
private:
    struct ParallaxLayer {
        std::shared_ptr<CS230::Texture> texture;
        double speed = 1;
    };

    std::vector<ParallaxLayer> backgrounds;
};




================================================
FILE: source/Game/GameObjectTypes.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  GameObjectTypes.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 20, 2025
*/
#pragma once
enum class GameObjectTypes {
    //Score,
    Bus,
    Player,
    Food,
    Passenger,
    Obstacle,
    Particle,
    Character,
    Samurai,
    Triangle,
    Stars,
    Moon,
    Road,
    Count
};



================================================
FILE: source/Game/MainMenu.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  MainMenu.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 6, 2025
*/
#include "MainMenu.h"
#include "CS200/IRenderer2D.h"
#include "CS200/NDC.h"
#include "CS200/RenderingAPI.h"
#include "Demo/DemoDepthPost.h"
#include "Engine/Engine.h"
#include "Engine/GameStateManager.h"
#include "Engine/Input.h"
#include "Engine/TextManager.h"
#include "Engine/TextureManager.h"
#include "Engine/Window.h"

#include "OpenGL/Environment.h"

#include "States.h"
#include <imgui.h>

// (0.0 = 0%, 1.0 = 100%)
namespace
{
	// --- Menu UI Ratio ---
	const double TITLE_X_RATIO			   = 0.15;
	const double TITLE_Y_RATIO_FROM_BOTTOM = 0.8;
	const double TITLE_SCALE_VAL		   = 1.5;

	const double MENU_CENTER_X_RATIO	 = 0.5;
	const double MENU_WIDTH_RATIO		 = 0.4;
	const double MENU_ITEM_HEIGHT_RATIO	 = 0.05;
	const double MENU_ITEM_SPACING_RATIO = 0.03;
	const double MENU_START_Y_RATIO		 = 0.4;
}

MainMenu::MainMenu() : current_option(Option::DemoDepthPost)
{
}

void MainMenu::DrawImGui()
{
	
}

void MainMenu::select_option()
{
	switch (current_option)
	{
		case MainMenu::Option::DemoDepthPost:
			Engine::GetGameStateManager().PopState();
			Engine::GetGameStateManager().PushState<DemoDepthPost>();
			break;

		case MainMenu::Option::Exit: Engine::GetGameStateManager().PopState(); break;
		case MainMenu::Option::COUNT: break;
	}
}

void MainMenu::Load()
{
	CS200::RenderingAPI::SetClearColor(0x000000FF);
	if (!OpenGL::IsWebGL)
	{
		Engine::GetWindow().ForceResize(default_window_size.x, default_window_size.y);
		Engine::GetWindow().SetWindowPosition(SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
	}
	Option temp_option = current_option;
	while (temp_option != Option::COUNT)
	{
		colors[temp_option] = non_seleted_color;
		temp_option			= static_cast<Option>(static_cast<int>(temp_option) + 1);
	}
	update_colors();

	const auto window_size = default_window_size;

	title_pos.x = window_size.x * TITLE_X_RATIO;
	title_pos.y = window_size.y * TITLE_Y_RATIO_FROM_BOTTOM;
	title_scale = Math::vec2{ TITLE_SCALE_VAL, TITLE_SCALE_VAL };

	const double text_width		  = window_size.x * MENU_WIDTH_RATIO;
	const double text_x			  = (window_size.x * MENU_CENTER_X_RATIO) - (text_width / 2.0);
	const double text_height	  = window_size.y * MENU_ITEM_HEIGHT_RATIO;
	const double start_y_from_top = window_size.y * MENU_START_Y_RATIO;

	const double item_bottom_y_from_top	   = start_y_from_top + text_height;
	const double item_bottom_y_from_bottom = window_size.y - item_bottom_y_from_top;

	menu_start_pos_bl	   = Math::vec2{ text_x, item_bottom_y_from_bottom };
	menu_item_size		   = Math::vec2{ text_width, text_height };
	menu_item_total_height = text_height + (window_size.y * MENU_ITEM_SPACING_RATIO);
}

void MainMenu::Update([[maybe_unused]] double dt)
{
	CS230::Input& input		  = Engine::GetInput();
	// Math::vec2	  mouse_pos	  = input.GetMousePos();
	// auto		  window_size = Engine::GetWindow().GetSize();
	
	update_colors();
	if (input.KeyJustReleased(CS230::Input::Keys::Up))
	{
		int current_index = static_cast<int>(current_option);
		int total_options = static_cast<int>(Option::COUNT);
		current_index	  = (current_index - 1 + total_options) % total_options;
		current_option	  = static_cast<Option>(current_index);
	}
	else if (input.KeyJustReleased(CS230::Input::Keys::Down))
	{
		int current_index = static_cast<int>(current_option);
		int total_options = static_cast<int>(Option::COUNT);
		current_index	  = (current_index + 1) % total_options;
		current_option	  = static_cast<Option>(current_index);
	}
	else if (input.KeyJustReleased(CS230::Input::Keys::Enter))
	{
		select_option();
	}


	// bool mouse_is_hovering = false;
	// int	 total_options	   = static_cast<int>(Option::COUNT);
	// for (int i = 0; i < total_options; ++i)
	// {
	// 	double item_bottom_y = menu_start_pos_bl.y - (i * menu_item_total_height);

	// 	Math::vec2 rect_pos{ menu_start_pos_bl.x, item_bottom_y };
	// 	Math::vec2 rect_size = menu_item_size;

	// 	if (IsPointInRect(mouse_pos, rect_pos, rect_size))
	// 	{
	// 		current_option	  = static_cast<Option>(i);
	// 		mouse_is_hovering = true;
	// 		break;
	// 	}
	// }

	// if (input.MouseJustPressed(0) && mouse_is_hovering)
	// {
	// 	select_option();
	// }

}

void MainMenu::Unload()
{
}

void MainMenu::Draw()
{
	CS200::RenderingAPI::Clear();
	auto renderer_2d = Engine::GetTextureManager().GetRenderer2D();
	renderer_2d->BeginScene(CS200::build_ndc_matrix(Engine::GetWindow().GetSize()));

	auto& text_manager = Engine::GetTextManager();

	text_manager.DrawText("CS200 HW8", title_pos, Fonts::Outlined, title_scale, title_color);

	double current_item_y = 0;
	int	   i			  = 0;

	// Option: demo depth post
	i			   = static_cast<int>(Option::DemoDepthPost);
	current_item_y = menu_start_pos_bl.y - (i * menu_item_total_height);
	text_manager.DrawText("Demo Depth Post", Math::vec2{ menu_start_pos_bl.x, current_item_y }, Fonts::Outlined, { 1.0, 1.0 }, colors[Option::DemoDepthPost]);

	// Option: exit
	i			   = static_cast<int>(Option::Exit);
	current_item_y = menu_start_pos_bl.y - (i * menu_item_total_height);
	text_manager.DrawText("Exit", Math::vec2{ menu_start_pos_bl.x, current_item_y }, Fonts::Outlined, { 1.0, 1.0 }, colors[Option::Exit]);

	renderer_2d->EndScene();
}

gsl::czstring MainMenu::GetName() const
{
	return "MainMenu";
}

void MainMenu::update_colors()
{
	for (auto& color : colors)
	{
		if (color.first == current_option)
		{
			color.second = seleted_color;		
		}
		else
		{
			color.second = non_seleted_color;
		}
	}
}



================================================
FILE: source/Game/MainMenu.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  MainMenu.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 6, 2025
*/

#pragma once

#include "../Engine/Engine.h"
#include "../Engine/Font.h"
#include "../Engine/GameState.h"
#include "../Engine/Texture.h"

#include "../Engine/Fonts.h"

class MainMenu : public CS230::GameState
{
public:
	MainMenu();
	void						 Load() override;
	void						 Update(double dt) override;
	void						 Unload() override;
	void						 Draw() override;
	void						 DrawImGui() override;
	gsl::czstring				 GetName() const override;
	static constexpr CS200::RGBA title_color	   = 0x9A2EFEFF;
	static constexpr CS200::RGBA non_seleted_color = 0xFFFFFFFF;
	static constexpr CS200::RGBA seleted_color	   = 0x3ADF00FF;

private:
	enum class Option
	{
		DemoDepthPost,
		Exit,
		COUNT
	};
	Option current_option;

	std::map<Option, CS200::RGBA> colors;


	Math::vec2 title_pos;
	Math::vec2 title_scale;

	Math::vec2 menu_start_pos_bl;
	Math::vec2 menu_item_size;
	double	   menu_item_total_height;

	void select_option();
	void update_colors();

	static constexpr Math::ivec2 default_window_size = { 800, 600 };
};



================================================
FILE: source/Game/Particles.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Particles.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 29, 2025
*/
#pragma once
#include "../Engine/Particle.h"

namespace Particles
{
    class Smoke : public CS230::Particle
    {
    public:
        Smoke() : Particle("Assets/Smoke.spt") { };

        std::string TypeName() override
        {
            return "Smoke Particle";
        }

        static constexpr int    MaxCount = 3;
        static constexpr double MaxLife  = 5.0;
    };

    class Hit : public CS230::Particle
    {
    public:
        Hit() : Particle("Assets/Hit.spt") { };

        std::string TypeName() override
        {
            return "Hit Particle";
        }

        static constexpr int    MaxCount = 10;
        static constexpr double MaxLife  = 1.0;
    };

    class MeteorBit : public CS230::Particle
    {
    public:
    
        MeteorBit() : Particle("Assets/sprites/DemoSceneShowcase/Meteor.spt") { };

        std::string TypeName() override
        {
            return "MeteorBit Particle";
        }

        static constexpr int    MaxCount = 150;
        static constexpr double MaxLife  = 1.25;
    };

    class Tears : public CS230::Particle
    {
    public:
        Tears() : Particle("Assets/sprites/CS230_Final/Tears.spt") { };

        std::string TypeName() override
        {
            return "Tears Particle";
        }

        static constexpr int	MaxCount = 30;
        static constexpr double MaxLife  = 3.0;
    };

    class Shining : public CS230::Particle
    {
    public:
        Shining() : Particle("Assets/sprites/CS230_Final/Shining.spt") { };

        std::string TypeName() override
        {
            return "Shining Particle";
        }

        static constexpr int    MaxCount = 50;
        static constexpr double MaxLife  = 3.0;
    };

    class Flame : public CS230::Particle
	{
	public:
		Flame() : Particle("Assets/sprites/DemoSceneShowcase/Flame.spt") { };

		std::string TypeName() override
		{
			return "Flame Particle";
		}

		static constexpr int	MaxCount = 5;
		static constexpr double MaxLife	 = 1.25;
	};
}



================================================
FILE: source/Game/Score.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Score.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 29, 2025
*/
#include "Score.h"


Score::Score( int _value) 
	:  value(_value){}

void Score::Add(int dv)
{
	value += dv;
}

void Score::Sub(int dv)
{
    value -= dv;
}



================================================
FILE: source/Game/Score.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Score.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    May 29, 2025
*/
#pragma once

#include "../Engine/GameObject.h"
#include "../Engine/Vec2.h"
class Score : public CS230::Component {
public:
	Score(int value);
	void Add(int dv = 1);
    void Sub(int dv = 1);
	const int& Value() const { return value; }
private:
	int value;
};



================================================
FILE: source/Game/Splash.cpp
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Splash.cpp
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 12, 2025
*/
#include "../Engine/Engine.h"
#include "../Engine/TextureManager.h"
#include "../Engine/Logger.h"
#include "../Engine/GameStateManager.h"
#include "../Engine/Window.h"
#include "../CS200/RenderingAPI.h"
#include "../CS200/IRenderer2D.h"
#include "../CS200/NDC.h"
#include "MainMenu.h"
#include "Splash.h"


void Splash::Load() {
    counter = 0.0;
    texture = Engine::GetTextureManager().Load("Assets/images/Splash/DigiPen.png");
}

void Splash::Update([[maybe_unused]] double dt) {
    Engine::GetLogger().LogDebug(std::to_string(counter));
    if (counter >= 0.7) {
        Engine::GetGameStateManager().PopState();
        Engine::GetGameStateManager().PushState<MainMenu>();
    }
    counter+=dt;
}

void Splash::Unload()
{
}


void Splash::Draw()  {

    CS200::RenderingAPI::Clear();
	auto renderer_2d = Engine::GetTextureManager().GetRenderer2D();
    renderer_2d->BeginScene(CS200::build_ndc_matrix(Engine::GetWindow().GetSize()));
    texture->Draw(Math::TranslationMatrix({ (Engine::GetWindow().GetSize() - texture->GetSize()) / 2 }));

    renderer_2d->EndScene();
}

void Splash::DrawImGui()
{
}

gsl::czstring Splash::GetName() const
{
    return "Splash";
}



================================================
FILE: source/Game/Splash.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  Splash.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 12, 2025
*/

#pragma once
#include "../Engine/GameState.h"
#include "../Engine/Texture.h"

class Splash : public CS230::GameState
{
public:
    // Splash();
    void          Load() override;
    void          Update(double dt) override;
    void          Unload() override;
    void          Draw() override;
    void          DrawImGui() override;
    gsl::czstring GetName() const override;


private:
    double                          counter = 0;
    std::shared_ptr<CS230::Texture> texture;
};



================================================
FILE: source/Game/States.h
================================================
/*
Copyright (C) 2023 DigiPen Institute of Technology
Reproduction or distribution of this file or its contents without
prior written consent is prohibited
File Name:  States.h
Project:    CS230 Engine
Author:     Taekyung Ho
Created:    March 12, 2025
*/
#pragma once
enum class States {
    Splash,
    MainMenu,
    Final
};



================================================
FILE: source/OpenGL/Buffer.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Buffer.h"

#include "GL.h"

namespace OpenGL
{
    BufferHandle CreateBuffer(BufferType type, GLsizeiptr size_in_bytes) noexcept
    {
        BufferHandle new_buffer{};
        GL::GenBuffers(1, &new_buffer);
        GL::BindBuffer(static_cast<GLenum>(type), new_buffer);
        GL::BufferData(static_cast<GLenum>(type), size_in_bytes, nullptr, GL_DYNAMIC_DRAW);
        GL::BindBuffer(static_cast<GLenum>(type), 0);
        // https://docs.gl/es3/glGenBuffers
        // https://docs.gl/es3/glBindBuffer
        // https://docs.gl/es3/glBufferData
        return new_buffer;
    }

    BufferHandle CreateBuffer(BufferType type, std::span<const std::byte> static_buffer_data) noexcept
    {
        BufferHandle new_buffer{};
        GL::GenBuffers(1, &new_buffer);
        GL::BindBuffer(static_cast<GLenum>(type), new_buffer);
        GL::BufferData(static_cast<GLenum>(type), static_cast<GLsizeiptr>(static_buffer_data.size() * sizeof(static_buffer_data[0])), static_buffer_data.data(), GL_STATIC_DRAW);
        GL::BindBuffer(static_cast<GLenum>(type), 0);
        // https://docs.gl/es3/glGenBuffers
        // https://docs.gl/es3/glBindBuffer
        // https://docs.gl/es3/glBufferData
        return new_buffer;
    }

    void UpdateBufferData(BufferType type, BufferHandle buffer, std::span<const std::byte> data_to_copy, GLsizei starting_offset) noexcept
    {
        // https://docs.gl/es3/glBindBuffer
        // https://docs.gl/es3/glBufferSubData
        GL::BindBuffer(static_cast<GLenum>(type), buffer);
        GL::BufferSubData(static_cast<GLenum>(type), starting_offset, static_cast<GLsizeiptr>(data_to_copy.size() * sizeof(data_to_copy[0])), data_to_copy.data());
        GL::BindBuffer(static_cast<GLenum>(type), 0);
    }
}



================================================
FILE: source/OpenGL/Buffer.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "GLConstants.h"
#include "Handle.h"
#include <span>

namespace OpenGL
{
    /**
     * \brief Descriptive alias for OpenGL buffer object handles
     *
     * BufferHandle provides a more specific and readable name for the generic
     * OpenGL handle type. While it doesn't add type safety (it's still the same
     * underlying type as other OpenGL handles), it makes the code's intent clearer
     * by indicating that this handle specifically refers to buffer objects.
     *
     * This alias helps with:
     * - Code readability: immediately clear this refers to a buffer
     * - Documentation: function signatures clearly indicate buffer parameters
     * - Consistency: uniform naming convention across the OpenGL wrapper
     *
     * Note: This is purely a naming convenience - the compiler treats BufferHandle
     * identically to the generic Handle type, so mixing them won't cause errors.
     * The real type safety comes from the BufferType enum and API design.
     */
    using BufferHandle = Handle;

    /**
     * \brief Enumeration of OpenGL buffer types for different rendering purposes
     *
     * BufferType categorizes buffers based on their intended use in the graphics
     * pipeline. Each type corresponds to a specific OpenGL buffer target that
     * determines how the GPU will access and use the buffer data.
     *
     * The enum values map directly to OpenGL constants but provide a more
     * type-safe and readable interface. This helps prevent binding buffers
     * to incorrect targets and makes the code's intent clearer.
     *
     * Buffer Types:
     * - Vertices: Stores vertex attribute data (positions, colors, texture coordinates)
     * - Indices: Stores element indices for indexed drawing operations
     * - UniformBlocks: Stores uniform data shared across multiple shader invocations
     */
    enum class BufferType : GLenum
    {
        Vertices      = GL_ARRAY_BUFFER,         ///< Vertex attribute data buffer
        Indices       = GL_ELEMENT_ARRAY_BUFFER, ///< Element index buffer for indexed drawing
        UniformBlocks = GL_UNIFORM_BUFFER        ///< Uniform block data buffer
    };
    /**
     * \brief Create an empty buffer with specified size for dynamic data
     * \param type The type of buffer to create (Vertices, Indices, or UniformBlocks)
     * \param size_in_bytes Size of the buffer in bytes
     * \return Handle to the newly created buffer object
     *
     * Creates an OpenGL buffer object with allocated storage but no initial data.
     * This is optimal for buffers that will be updated frequently during runtime,
     * such as dynamic vertex data, animated geometry, or per-frame uniform data.
     *
     * The buffer is configured for dynamic usage patterns, making it suitable for:
     * - Vertex data that changes every frame (particle systems, UI elements)
     * - Temporary geometry that gets rebuilt frequently
     * - Buffers that will be updated with new data using UpdateBufferData()
     *
     * Memory allocation happens on the GPU, but no data transfer occurs during
     * creation. The buffer contents are undefined until data is uploaded.
     *
     * The implementation uses GL_DYNAMIC_DRAW usage hint, indicating that the
     * buffer contents will be modified repeatedly and used for drawing operations.
     */
    [[nodiscard]] BufferHandle CreateBuffer(BufferType type, GLsizeiptr size_in_bytes) noexcept;

    /**
     * \brief Create a buffer initialized with static data
     * \param type The type of buffer to create (Vertices, Indices, or UniformBlocks)
     * \param static_buffer_data Span containing the initial data to upload
     * \return Handle to the newly created buffer object
     *
     * Creates an OpenGL buffer object and immediately uploads the provided data.
     * This is optimal for buffers containing static data that won't change during
     * the application's lifetime, such as fixed mesh geometry, constant lookup
     * tables, or unchanging uniform block data.
     *
     * The buffer is configured for static usage patterns, making it suitable for:
     * - Static mesh geometry (terrain, buildings, fixed models)
     * - Constant index arrays for standard shapes (quads, cubes)
     * - Lookup tables and constant uniform data
     * - Any data that remains unchanged after initial upload
     *
     * Memory allocation and data transfer happen atomically during creation,
     * ensuring the buffer is immediately ready for use in rendering operations.
     *
     * The implementation uses GL_STATIC_DRAW usage hint, indicating that the
     * buffer contents will be set once and used repeatedly for drawing.
     */
    [[nodiscard]] BufferHandle CreateBuffer(BufferType type, std::span<const std::byte> static_buffer_data) noexcept;

    /**
     * \brief Update existing buffer with new data
     * \param type The type of buffer being updated
     * \param buffer Handle to the buffer object to update
     * \param data_to_copy Span containing the new data to upload
     * \param starting_offset Byte offset within the buffer where copying begins (default: 0)
     *
     * Uploads new data to an existing buffer object, either replacing all contents
     * or updating a specific region. This is essential for dynamic buffers that
     * need frequent updates, such as animated vertex data, changing uniform values,
     * or streaming geometry data.
     *
     * The function provides flexibility for partial updates:
     * - Full buffer replacement: starting_offset = 0, data spans entire buffer
     * - Partial updates: starting_offset > 0, data spans subset of buffer
     * - Streaming updates: sequential calls with different offsets
     *
     * Common usage patterns:
     * - Updating vertex positions for animated objects
     * - Streaming new geometry data for dynamic scenes
     * - Modifying uniform block data for per-object parameters
     * - Updating index buffers for dynamic mesh topology
     *
     * The buffer must have sufficient capacity to hold the new data starting
     * from the specified offset. The function performs efficient GPU memory
     * transfers using OpenGL's buffer sub-data operations.
     */
    void UpdateBufferData(BufferType type, BufferHandle buffer, std::span<const std::byte> data_to_copy, GLsizei starting_offset = 0) noexcept;
}



================================================
FILE: source/OpenGL/Environment.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

namespace OpenGL
{
    inline int MajorVersion         = 0;
    inline int MinorVersion         = 0;
    inline int MaxTextureImageUnits = 2;
    inline int MaxTextureSize       = 64;

    constexpr int version(int major, int minor) noexcept
    {
        return major * 100 + minor * 10;
    }

    inline int current_version() noexcept
    {
        return version(MajorVersion, MinorVersion);
    }

#if defined(IS_WEBGL2)
    constexpr bool IsWebGL                     = true;
    // WEBGL2 is expressed as 3.0 ES
    constexpr int  MinimumRequiredMajorVersion = 3;
    constexpr int  MinimumRequiredMinorVersion = 0;
#else
    constexpr bool IsWebGL                     = false;
    constexpr int  MinimumRequiredMajorVersion = 3;
    constexpr int  MinimumRequiredMinorVersion = 3;
#endif
}



================================================
FILE: source/OpenGL/Framebuffer.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Framebuffer.h"
#include "Engine/Engine.h"
#include "Engine/Logger.h"
#include "GL.h"
#include "Texture.h"

namespace
{
    void verify_framebuffer_complete(OpenGL::FramebufferHandle framebuffer);
}

namespace OpenGL
{
    FramebufferWithColor CreateFramebufferWithColor(Math::ivec2 size)
    {
        FramebufferWithColor fb{};
        //  * - A color texture attachment in RGBA format for storing rendered pixels
        fb.ColorAttachment = CreateRGBATexture(size);
        GL::GenFramebuffers(1,&(fb.Framebuffer));
        GL::BindFramebuffer(GL_FRAMEBUFFER, fb.Framebuffer);
        GL::FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,fb.ColorAttachment, 0);
        //  * - Proper draw buffer configuration for color output
        constexpr GLenum draw_buffers[] = { GL_COLOR_ATTACHMENT0 };
        GL::DrawBuffers(1, draw_buffers);
        //  * - Complete framebuffer validation to ensure it's ready for use
        verify_framebuffer_complete(fb.Framebuffer);
        return fb;
    }

    void DestroyFramebufferWithColor(FramebufferWithColor& framebuffer_with_color) noexcept
    {
        GL::DeleteTextures(1, &framebuffer_with_color.ColorAttachment), framebuffer_with_color.ColorAttachment = 0;
		GL::DeleteFramebuffers(1, &framebuffer_with_color.Framebuffer), framebuffer_with_color.Framebuffer	   = 0;
    }
}

namespace
{
    void verify_framebuffer_complete(OpenGL::FramebufferHandle framebuffer)
    {
        GL::BindFramebuffer(GL_FRAMEBUFFER,framebuffer);
        const auto status_result = GL::CheckFramebufferStatus(GL_FRAMEBUFFER);
        if (status_result == GL_FRAMEBUFFER_COMPLETE)
        {
            GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
            return; // Framebuffer is complete and ready to use
        }

        std::ostringstream message;
        message << "Framebuffer creation failed: status = 0x" << std::hex << status_result << std::dec << "\n";

        switch (status_result)
        {
            case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                message << "\t[Attachment Error] One or more framebuffer attachments (e.g. textures or renderbuffers) are incomplete or incompatible.\n"
                        << "\t-> Double-check format consistency and ensure all attached resources are properly initialized.\n";
                break;

            case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                message << "\t[Missing Attachment] No color, depth, or stencil attachment was provided.\n"
                        << "\t-> Make sure at least one valid image is attached using glFramebufferTexture or glFramebufferRenderbuffer.\n";
                break;

            case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
                message << "\t[Draw Buffer Error] Draw buffers are referencing attachments that don't exist or are incomplete.\n"
                        << "\t-> Confirm that GL_COLOR_ATTACHMENTx exists for each buffer in GL::DrawBuffers().\n";
                break;

            case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
                message << "\t[Read Buffer Error] Read buffer (glReadBuffer) is referencing an incomplete or missing attachment.\n"
                        << "\t-> Check if glReadBuffer is targeting an attachment that's properly set up.\n";
                break;

            case GL_FRAMEBUFFER_UNSUPPORTED:
                message << "\t[Unsupported Configuration] This framebuffer configuration is not supported by the OpenGL implementation.\n"
                        << "\t-> Try simplifying formats, avoid non-standard combinations, and confirm hardware support.\n";
                break;

            default:
                message << "\t[Unknown Error] Framebuffer status not recognized. Raw code: " << status_result << "\n"
                        << "\t-> Investigate texture formats and attachment completeness. Enable OpenGL debug output for deeper insights.\n";
                break;
        }

        Engine::GetLogger().LogError(message.str());
        GL::BindFramebuffer(GL_FRAMEBUFFER, 0);
        throw std::runtime_error{ message.str() };
    }
}



================================================
FILE: source/OpenGL/Framebuffer.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Vec2.h"
#include "Handle.h"
#include "Texture.h"

namespace OpenGL
{
    /**
     * \brief Descriptive alias for OpenGL framebuffer object handles
     *
     * FramebufferHandle provides a more specific and readable name for the generic
     * OpenGL handle type when referring to framebuffer objects. Like other handle
     * aliases, this improves code clarity without adding compile-time type safety.
     */
    using FramebufferHandle = Handle;

    /**
     * \brief Complete framebuffer setup with color attachment for render-to-texture operations
     *
     * FramebufferWithColor represents a fully configured OpenGL framebuffer that can
     * be used as a render target. This struct bundles together the framebuffer object
     * and its associated color texture, providing everything needed for off-screen
     * rendering or render-to-texture effects.
     *
     * Purpose and Use Cases:
     * - Render-to-texture operations (post-processing effects, shadows, reflections)
     * - Off-screen rendering for UI elements or HUD components
     * - Multi-pass rendering techniques (deferred rendering, G-buffers)
     * - Creating texture atlases or procedural textures at runtime
     * - Screen capture and screenshot functionality
     *
     * The framebuffer acts as a rendering target that redirects all drawing operations
     * to the attached texture instead of the screen. This enables sophisticated
     * graphics techniques where the rendered result becomes input for subsequent
     * rendering passes or post-processing effects.
     *
     * Resource Management:
     * Both the framebuffer and its color texture must be properly destroyed when
     * no longer needed to prevent OpenGL resource leaks. The struct design makes
     * it easy to manage these related resources as a single unit.
     */
    struct [[nodiscard]] FramebufferWithColor
    {
        /** \brief Handle to the OpenGL framebuffer object */
        FramebufferHandle Framebuffer = 0;

        /** \brief Handle to the color texture attached to this framebuffer */
        TextureHandle ColorAttachment = 0;
    };

    /**
     * \brief Create a complete framebuffer with color texture attachment
     * \param size Dimensions of the framebuffer and its color texture in pixels
     * \return Fully configured framebuffer ready for rendering operations
     *
     * Creates a complete framebuffer setup suitable for render-to-texture operations.
     * This function handles all the complex OpenGL setup required for off-screen
     * rendering, including texture creation, framebuffer configuration, and
     * attachment binding.
     *
     * The created framebuffer includes:
     * - A color texture attachment in RGBA format for storing rendered pixels
     * - Proper draw buffer configuration for color output
     * - Complete framebuffer validation to ensure it's ready for use
     *
     * Common usage patterns:
     * - Post-processing pipelines: render scene to texture, then apply effects
     * - Shadow mapping: render depth information from light's perspective
     * - Reflection/refraction: capture environment from different viewpoints
     * - UI rendering: create interface elements as textures
     *
     * The implementation creates an RGBA texture matching the specified dimensions
     * and attaches it as GL_COLOR_ATTACHMENT0. The framebuffer is validated for
     * completeness before being returned, throwing an exception if setup fails.
     *
     * Memory considerations:
     * The texture size directly affects GPU memory usage (width 횞 height 횞 4 bytes
     * for RGBA). Large framebuffers can impact performance and memory consumption.
     */
    FramebufferWithColor CreateFramebufferWithColor(Math::ivec2 size);

    /**
     * \brief Safely destroy framebuffer and release all associated resources
     * \param framebuffer_with_color Framebuffer structure to destroy (will be reset to zero)
     *
     * Properly cleans up both the framebuffer object and its associated color texture,
     * preventing OpenGL resource leaks. This function ensures that all GPU resources
     * are returned to the system and the structure is reset to a safe state.
     *
     * Resource cleanup includes:
     * - Deleting the OpenGL framebuffer object
     * - Deleting the associated color texture
     * - Resetting both handles to zero for safety
     *
     * The function is designed to be safe to call multiple times on the same
     * structure, as it resets handles to zero after deletion. This prevents
     * double-deletion errors that could occur with manual resource management.
     *
     * Usage patterns:
     * - Call when framebuffer is no longer needed
     * - Include in cleanup/shutdown code
     * - Use in RAII wrapper destructors for automatic cleanup
     * - Call before reassigning framebuffer variables
     *
     * After calling this function, the framebuffer structure should not be used
     * for rendering operations until a new framebuffer is created.
     */
    void DestroyFramebufferWithColor(FramebufferWithColor& framebuffer_with_color) noexcept;
}



================================================
FILE: source/OpenGL/GL.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
// Include GLEW first to define OpenGL functions and constants
#include <GL/glew.h>

#include "Engine/Engine.h"
#include "Engine/Logger.h"
#include "GL.h"

#include <cassert>
#include <iostream>
#include <sstream>
#include <string>


#if defined(DEVELOPER_VERSION)
#    include <source_location>
#    define VOID_SOURCE_LOCATION const std::source_location caller_location
#    define SOURCE_LOCATION      , VOID_SOURCE_LOCATION
#    define glCheck(expression)                                                                                                                                                                        \
        expression;                                                                                                                                                                                    \
        glCheckError(caller_location.file_name(), caller_location.line(), caller_location.function_name(), #expression)

namespace
{
    inline void glCheckError(const char* file, unsigned line, const char* function_name, const char* opengl_function)
    {
        GLenum errorCode = glGetError();

        if (errorCode == GL_NO_ERROR)
            return;

        const std::string  fileString  = file;
        std::string        error       = "Unknown error";
        std::string        description = "No description";
        std::ostringstream serr;

        serr << "OpenGL call " << opengl_function << " failed in " << fileString.substr(fileString.find_last_of("\\/") + 1) << "(" << line << ")."
             << "\nwithin Function:\n   " << function_name << "\nError description:\n   ";
        int loop_limit = 0;
        while (errorCode != GL_NO_ERROR && loop_limit < 3)
        {
            ++loop_limit;
            switch (errorCode)
            {
                case GL_INVALID_ENUM:
                    {
                        error       = "GL_INVALID_ENUM";
                        description = "An unacceptable value has been specified for an enumerated argument.";
                        break;
                    }

                case GL_INVALID_VALUE:
                    {
                        error       = "GL_INVALID_VALUE";
                        description = "A numeric argument is out of range.";
                        break;
                    }

                case GL_INVALID_OPERATION:
                    {
                        error       = "GL_INVALID_OPERATION";
                        description = "The specified operation is not allowed in the current state.";
                        break;
                    }

                case GL_STACK_OVERFLOW:
                    {
                        error       = "GL_STACK_OVERFLOW";
                        description = "This command would cause a stack overflow.";
                        break;
                    }

                case GL_STACK_UNDERFLOW:
                    {
                        error       = "GL_STACK_UNDERFLOW";
                        description = "This command would cause a stack underflow.";
                        break;
                    }

                case GL_OUT_OF_MEMORY:
                    {
                        error       = "GL_OUT_OF_MEMORY";
                        description = "There is not enough memory left to execute the command.";
                        break;
                    }

                default:
                    {
                        error += " " + std::to_string(errorCode);
                        break;
                    }
            }

            serr << error << "\n   " << description << "\n\n";
            errorCode = glGetError();
        }
        Engine::GetLogger().LogError(serr.str());
        assert(false);
    }
}
#else
#    define SOURCE_LOCATION
#    define VOID_SOURCE_LOCATION void
#    define glCheck(expression)  expression
#endif


namespace GL
{
    const GLubyte* GetString(GLenum name SOURCE_LOCATION)
    {
        glCheck(const auto the_string = glGetString(name));
        return the_string;
    }

    GLboolean IsBuffer(GLuint buffer SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsBuffer(buffer));
        return result;
    }

    GLboolean IsEnabled(GLenum cap SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsEnabled(cap));
        return result;
    }

    GLboolean IsProgram(GLuint program SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsProgram(program));
        return result;
    }

    GLboolean IsShader(GLuint shader SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsShader(shader));
        return result;
    }

    GLboolean IsTexture(GLuint texture SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsTexture(texture));
        return result;
    }

    GLenum GetError(void)
    {
        // Note: We don't use glCheck here since this function IS the error checker
        return glGetError();
    }

    GLint GetAttribLocation(GLuint program, const GLchar* name SOURCE_LOCATION)
    {
        glCheck(const auto location = glGetAttribLocation(program, name));
        return location;
    }

    GLint GetUniformLocation(GLuint program, const GLchar* name SOURCE_LOCATION)
    {
        glCheck(const auto location = glGetUniformLocation(program, name));
        return location;
    }

    GLuint CreateProgram(VOID_SOURCE_LOCATION)
    {
        glCheck(const auto program = glCreateProgram());
        return program;
    }

    GLuint CreateShader(GLenum shaderType SOURCE_LOCATION)
    {
        glCheck(const auto shader = glCreateShader(shaderType));
        return shader;
    }

    void ActiveTexture(GLenum texture SOURCE_LOCATION)
    {
        glCheck(glActiveTexture(texture));
    }

    void AttachShader(GLuint program, GLuint shader SOURCE_LOCATION)
    {
        glCheck(glAttachShader(program, shader));
    }

    void BindBuffer(GLenum target, GLuint buffer SOURCE_LOCATION)
    {
        glCheck(glBindBuffer(target, buffer));
    }

    void BindBufferBase(GLenum target, GLuint index, GLuint buffer SOURCE_LOCATION)
    {
        glCheck(glBindBufferBase(target, index, buffer));
    }

    void BindTexture(GLenum target, GLuint texture SOURCE_LOCATION)
    {
        glCheck(glBindTexture(target, texture));
    }

    void BlendEquation(GLenum mode SOURCE_LOCATION)
    {
        glCheck(glBlendEquation(mode));
    }

    void BlendFunc(GLenum sfactor, GLenum dfactor SOURCE_LOCATION)
    {
        glCheck(glBlendFunc(sfactor, dfactor));
	}

	void BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter SOURCE_LOCATION)
	{
        glCheck(glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter));
	}

	void BufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage SOURCE_LOCATION)
	{
        glCheck(glBufferData(target, size, data, usage));
    }

    void BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glBufferSubData(target, offset, size, data));
    }

    void Clear(GLbitfield mask SOURCE_LOCATION)
    {
        glCheck(glClear(mask));
    }

    void ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha SOURCE_LOCATION)
    {
        glCheck(glClearColor(red, green, blue, alpha));
    }

    void CompileShader(GLuint shader SOURCE_LOCATION)
    {
        glCheck(glCompileShader(shader));
    }

    void CullFace(GLenum mode SOURCE_LOCATION)
    {
        glCheck(glCullFace(mode));
    }

    void DeleteBuffers(GLsizei n, const GLuint* buffers SOURCE_LOCATION)
    {
        glCheck(glDeleteBuffers(n, buffers));
    }

    void DeleteProgram(GLuint program SOURCE_LOCATION)
    {
        glCheck(glDeleteProgram(program));
    }

    void DeleteShader(GLuint shader SOURCE_LOCATION)
    {
        glCheck(glDeleteShader(shader));
    }

    void DeleteTextures(GLsizei n, const GLuint* textures SOURCE_LOCATION)
    {
        glCheck(glDeleteTextures(n, textures));
    }

    void DepthMask(GLboolean flag SOURCE_LOCATION)
    {
        glCheck(glDepthMask(flag));
    }

    void Disable(GLenum cap SOURCE_LOCATION)
    {
        glCheck(glDisable(cap));
    }

    void DrawArrays(GLenum mode, GLint first, GLsizei count SOURCE_LOCATION)
    {
        glCheck(glDrawArrays(mode, first, count));
    }

    void DrawBuffers(GLsizei n, const GLenum* bufs SOURCE_LOCATION)
    {
        glCheck(glDrawBuffers(n, bufs));
    }

    void DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices SOURCE_LOCATION)
    {
        glCheck(glDrawElements(mode, count, type, indices));
    }

    void Enable(GLenum cap SOURCE_LOCATION)
    {
        glCheck(glEnable(cap));
    }

    void EnableVertexAttribArray(GLuint index SOURCE_LOCATION)
    {
        glCheck(glEnableVertexAttribArray(index));
    }

    void FrontFace(GLenum mode SOURCE_LOCATION)
    {
        glCheck(glFrontFace(mode));
    }

    void GenBuffers(GLsizei n, GLuint* buffers SOURCE_LOCATION)
    {
        glCheck(glGenBuffers(n, buffers));
    }

    void GenTextures(GLsizei n, GLuint* textures SOURCE_LOCATION)
    {
        glCheck(glGenTextures(n, textures));
    }

    void GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name SOURCE_LOCATION)
    {
        glCheck(glGetActiveAttrib(program, index, bufSize, length, size, type, name));
    }

    void GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name SOURCE_LOCATION)
    {
        glCheck(glGetActiveUniform(program, index, bufSize, length, size, type, name));
    }

    void GetBooleanv(GLenum pname, GLboolean* data SOURCE_LOCATION)
    {
        glCheck(glGetBooleanv(pname, data));
    }

    void GetIntegerv(GLenum pname, GLint* data SOURCE_LOCATION)
    {
        glCheck(glGetIntegerv(pname, data));
    }

    void GetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog SOURCE_LOCATION)
    {
        glCheck(glGetProgramInfoLog(program, maxLength, length, infoLog));
    }

    void GetProgramiv(GLuint program, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetProgramiv(program, pname, params));
    }

    void GetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog SOURCE_LOCATION)
    {
        glCheck(glGetShaderInfoLog(shader, maxLength, length, infoLog));
    }

    void GetShaderiv(GLuint shader, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetShaderiv(shader, pname, params));
    }

    void GetUniformfv(GLuint program, GLint location, GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glGetUniformfv(program, location, params));
    }

    void GetUniformiv(GLuint program, GLint location, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetUniformiv(program, location, params));
    }

    void GetUniformuiv(GLuint program, GLint location, GLuint* params SOURCE_LOCATION)
    {
        glCheck(glGetUniformuiv(program, location, params));
    }

    void Hint(GLenum target, GLenum mode SOURCE_LOCATION)
    {
        glCheck(glHint(target, mode));
    }

    void LinkProgram(GLuint program SOURCE_LOCATION)
    {
        glCheck(glLinkProgram(program));
    }

    void PolygonOffset(GLfloat factor, GLfloat units SOURCE_LOCATION)
    {
        glCheck(glPolygonOffset(factor, units));
    }

    void ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels SOURCE_LOCATION)
    {
        glCheck(glReadPixels(x, y, width, height, format, type, pixels));
    }

    void ShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint* length SOURCE_LOCATION)
    {
        glCheck(glShaderSource(shader, count, string, length));
    }

    void TexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glTexImage2D(target, level, internalFormat, width, height, border, format, type, data));
    }

    void TexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations SOURCE_LOCATION)
    {
        glCheck(glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations));
    }

    void TexParameterfv(GLenum target, GLenum pname, const GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glTexParameterfv(target, pname, params));
    }

    void TexParameteri(GLenum target, GLenum pname, GLint param SOURCE_LOCATION)
    {
        glCheck(glTexParameteri(target, pname, param));
    }

    void TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels SOURCE_LOCATION)
    {
        glCheck(glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels));
    }

    void Uniform1f(GLint location, GLfloat v0 SOURCE_LOCATION)
    {
        glCheck(glUniform1f(location, v0));
    }

    void Uniform1i(GLint location, GLint v0 SOURCE_LOCATION)
    {
        glCheck(glUniform1i(location, v0));
    }

    void Uniform1iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION)
    {
        glCheck(glUniform1iv(location, count, value));
    }

    void Uniform1ui(GLint location, GLuint v0 SOURCE_LOCATION)
    {
        glCheck(glUniform1ui(location, v0));
    }

    void Uniform2f(GLint location, GLfloat v0, GLfloat v1 SOURCE_LOCATION)
    {
        glCheck(glUniform2f(location, v0, v1));
    }

    void Uniform2fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniform2fv(location, count, value));
    }

    void Uniform2i(GLint location, GLint v0, GLint v1 SOURCE_LOCATION)
    {
        glCheck(glUniform2i(location, v0, v1));
    }

    void Uniform2ui(GLint location, GLuint v0, GLuint v1 SOURCE_LOCATION)
    {
        glCheck(glUniform2ui(location, v0, v1));
    }

    void Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2 SOURCE_LOCATION)
    {
        glCheck(glUniform3f(location, v0, v1, v2));
    }

    void Uniform3fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniform3fv(location, count, value));
    }

    void Uniform3i(GLint location, GLint v0, GLint v1, GLint v2 SOURCE_LOCATION)
    {
        glCheck(glUniform3i(location, v0, v1, v2));
    }

    void Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2 SOURCE_LOCATION)
    {
        glCheck(glUniform3ui(location, v0, v1, v2));
    }

    void Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 SOURCE_LOCATION)
    {
        glCheck(glUniform4f(location, v0, v1, v2, v3));
    }

    void Uniform4fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniform4fv(location, count, value));
    }

    void Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3 SOURCE_LOCATION)
    {
        glCheck(glUniform4i(location, v0, v1, v2, v3));
    }

    void Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 SOURCE_LOCATION)
    {
        glCheck(glUniform4ui(location, v0, v1, v2, v3));
    }

    void UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix2fv(location, count, transpose, value));
    }

    void UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix2x3fv(location, count, transpose, value));
    }

    void UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix2x4fv(location, count, transpose, value));
    }

    void UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix3fv(location, count, transpose, value));
    }

    void UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix3x2fv(location, count, transpose, value));
    }

    void UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix3x4fv(location, count, transpose, value));
    }

    void UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix4fv(location, count, transpose, value));
    }

    void UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix4x2fv(location, count, transpose, value));
    }

    void UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniformMatrix4x3fv(location, count, transpose, value));
    }

    void UseProgram(GLuint program SOURCE_LOCATION)
    {
        glCheck(glUseProgram(program));
    }

    void ClearDepth(GLdouble depth SOURCE_LOCATION)
    {
        glCheck(glClearDepth(depth));
    }

    void ClearStencil(GLint s SOURCE_LOCATION)
    {
        glCheck(glClearStencil(s));
    }

    void ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha SOURCE_LOCATION)
    {
        glCheck(glColorMask(red, green, blue, alpha));
    }

    void CopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border SOURCE_LOCATION)
    {
        glCheck(glCopyTexImage2D(target, level, internalformat, x, y, width, height, border));
    }

    void CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height));
    }

    void DepthRange(GLdouble nearVal, GLdouble farVal SOURCE_LOCATION)
    {
        glCheck(glDepthRange(nearVal, farVal));
    }

    void DetachShader(GLuint program, GLuint shader SOURCE_LOCATION)
    {
        glCheck(glDetachShader(program, shader));
    }

    void DisableVertexAttribArray(GLuint index SOURCE_LOCATION)
    {
        glCheck(glDisableVertexAttribArray(index));
    }

    void DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices SOURCE_LOCATION)
    {
        glCheck(glDrawRangeElements(mode, start, end, count, type, indices));
    }

    void GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders SOURCE_LOCATION)
    {
        glCheck(glGetAttachedShaders(program, maxCount, count, shaders));
    }

    void GetFloatv(GLenum pname, GLfloat* data SOURCE_LOCATION)
    {
        glCheck(glGetFloatv(pname, data));
    }

    void GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source SOURCE_LOCATION)
    {
        glCheck(glGetShaderSource(shader, bufSize, length, source));
    }

    void GetTexParameterfv(GLenum target, GLenum pname, GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glGetTexParameterfv(target, pname, params));
    }

    void GetTexParameteriv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetTexParameteriv(target, pname, params));
    }

    void GetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glGetVertexAttribfv(index, pname, params));
    }

    void GetVertexAttribiv(GLuint index, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetVertexAttribiv(index, pname, params));
    }

    void GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer SOURCE_LOCATION)
    {
        glCheck(glGetVertexAttribPointerv(index, pname, pointer));
    }

    void LineWidth(GLfloat width SOURCE_LOCATION)
    {
        glCheck(glLineWidth(width));
    }

    void PixelStorei(GLenum pname, GLint param SOURCE_LOCATION)
    {
        glCheck(glPixelStorei(pname, param));
    }

    void Scissor(GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glScissor(x, y, width, height));
    }

    void StencilMask(GLuint mask SOURCE_LOCATION)
    {
        glCheck(glStencilMask(mask));
    }

    void StencilMaskSeparate(GLenum face, GLuint mask SOURCE_LOCATION)
    {
        glCheck(glStencilMaskSeparate(face, mask));
    }

    void TexParameterf(GLenum target, GLenum pname, GLfloat param SOURCE_LOCATION)
    {
        glCheck(glTexParameterf(target, pname, param));
    }

    void TexParameteriv(GLenum target, GLenum pname, const GLint* params SOURCE_LOCATION)
    {
        glCheck(glTexParameteriv(target, pname, params));
    }

    void Uniform1fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glUniform1fv(location, count, value));
    }

    void Uniform1uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION)
    {
        glCheck(glUniform1uiv(location, count, value));
    }

    void Uniform2iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION)
    {
        glCheck(glUniform2iv(location, count, value));
    }

    void Uniform2uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION)
    {
        glCheck(glUniform2uiv(location, count, value));
    }

    void Uniform3iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION)
    {
        glCheck(glUniform3iv(location, count, value));
    }

    void Uniform3uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION)
    {
        glCheck(glUniform3uiv(location, count, value));
    }

    void Uniform4iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION)
    {
        glCheck(glUniform4iv(location, count, value));
    }

    void Uniform4uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION)
    {
        glCheck(glUniform4uiv(location, count, value));
    }

    void VertexAttrib1f(GLuint index, GLfloat v0 SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib1f(index, v0));
    }

    void VertexAttrib1fv(GLuint index, const GLfloat* v SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib1fv(index, v));
    }

    void VertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1 SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib2f(index, v0, v1));
    }

    void VertexAttrib2fv(GLuint index, const GLfloat* v SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib2fv(index, v));
    }

    void VertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2 SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib3f(index, v0, v1, v2));
    }

    void VertexAttrib3fv(GLuint index, const GLfloat* v SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib3fv(index, v));
    }

    void VertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib4f(index, v0, v1, v2, v3));
    }

    void VertexAttrib4fv(GLuint index, const GLfloat* v SOURCE_LOCATION)
    {
        glCheck(glVertexAttrib4fv(index, v));
    }

    void ValidateProgram(GLuint program SOURCE_LOCATION)
    {
        glCheck(glValidateProgram(program));
    }

    void VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer SOURCE_LOCATION)
    {
        glCheck(glVertexAttribPointer(index, size, type, normalized, stride, pointer));
    }

    void Viewport(GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glViewport(x, y, width, height));
    }

    GLenum CheckFramebufferStatus(GLenum target SOURCE_LOCATION)
    {
        glCheck(const GLenum status = glCheckFramebufferStatus(target));
        return status;
    }

    void BindFramebuffer(GLenum target, GLuint framebuffer SOURCE_LOCATION)
    {
        glCheck(glBindFramebuffer(target, framebuffer));
    }

    void BindRenderbuffer(GLenum target, GLuint renderbuffer SOURCE_LOCATION)
    {
        glCheck(glBindRenderbuffer(target, renderbuffer));
    }

    void BindVertexArray(GLuint array SOURCE_LOCATION)
    {
        glCheck(glBindVertexArray(array));
    }

    void DeleteFramebuffers(GLsizei n, GLuint* framebuffers SOURCE_LOCATION)
    {
        glCheck(glDeleteFramebuffers(n, framebuffers));
    }

    void DeleteVertexArrays(GLsizei n, const GLuint* arrays SOURCE_LOCATION)
    {
        glCheck(glDeleteVertexArrays(n, arrays));
    }

    void FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level SOURCE_LOCATION)
    {
        glCheck(glFramebufferTexture2D(target, attachment, textarget, texture, level));
    }

    void GenFramebuffers(GLsizei n, GLuint* framebuffers SOURCE_LOCATION)
    {
        glCheck(glGenFramebuffers(n, framebuffers));
    }

    void GenVertexArrays(GLsizei n, GLuint* arrays SOURCE_LOCATION)
    {
        glCheck(glGenVertexArrays(n, arrays));
    }

    GLboolean IsFramebuffer(GLuint framebuffer SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsFramebuffer(framebuffer));
        return result;
    }

    GLboolean IsRenderbuffer(GLuint renderbuffer SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsRenderbuffer(renderbuffer));
        return result;
    }

    GLboolean IsQuery(GLuint id SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsQuery(id));
        return result;
    }

    GLboolean IsSampler(GLuint id SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsSampler(id));
        return result;
    }

    GLboolean IsSync(GLsync sync SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsSync(sync));
        return result;
    }

    GLboolean IsTransformFeedback(GLuint id SOURCE_LOCATION)
    {
        glCheck(const auto result = glIsTransformFeedback(id));
        return result;
    }

    GLenum ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout SOURCE_LOCATION)
    {
        glCheck(const auto result = glClientWaitSync(sync, flags, timeout));
        return result;
    }

    GLint GetFragDataLocation(GLuint program, const char* name SOURCE_LOCATION)
    {
        glCheck(const auto location = glGetFragDataLocation(program, name));
        return location;
    }

    GLsync FenceSync(GLenum condition, GLbitfield flags SOURCE_LOCATION)
    {
        glCheck(const auto sync = glFenceSync(condition, flags));
        return sync;
    }

    GLuint GetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName SOURCE_LOCATION)
    {
        glCheck(const auto index = glGetUniformBlockIndex(program, uniformBlockName));
        return index;
    }

    void BeginQuery(GLenum target, GLuint id SOURCE_LOCATION)
    {
        glCheck(glBeginQuery(target, id));
    }

    void BeginTransformFeedback(GLenum primitiveMode SOURCE_LOCATION)
    {
        glCheck(glBeginTransformFeedback(primitiveMode));
    }

    void ClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil SOURCE_LOCATION)
    {
        glCheck(glClearBufferfi(buffer, drawBuffer, depth, stencil));
    }

    void ClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value SOURCE_LOCATION)
    {
        glCheck(glClearBufferfv(buffer, drawBuffer, value));
    }

    void ClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value SOURCE_LOCATION)
    {
        glCheck(glClearBufferiv(buffer, drawBuffer, value));
    }

    void ClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value SOURCE_LOCATION)
    {
        glCheck(glClearBufferuiv(buffer, drawBuffer, value));
    }

    void ClearDepthf(GLfloat depth SOURCE_LOCATION)
    {
        glCheck(glClearDepthf(depth));
    }

    void CompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data));
    }

    void CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data));
    }

    void CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data));
    }

    void CompressedTexSubImage3D(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data));
    }

    void CopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size SOURCE_LOCATION)
    {
        glCheck(glCopyBufferSubData(readtarget, writetarget, readoffset, writeoffset, size));
    }

    void CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height));
    }

    void CreateRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION)
    {
        glCheck(glCreateRenderbuffers(n, renderbuffers));
    }

    void CreateSamplers(GLsizei n, GLuint* samplers SOURCE_LOCATION)
    {
        glCheck(glCreateSamplers(n, samplers));
    }

    void CreateTransformFeedbacks(GLsizei n, GLuint* ids SOURCE_LOCATION)
    {
        glCheck(glCreateTransformFeedbacks(n, ids));
    }

    void DeleteQueries(GLsizei n, const GLuint* ids SOURCE_LOCATION)
    {
        glCheck(glDeleteQueries(n, ids));
    }

    void DeleteRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION)
    {
        glCheck(glDeleteRenderbuffers(n, renderbuffers));
    }

    void DeleteSamplers(GLsizei n, const GLuint* samplers SOURCE_LOCATION)
    {
        glCheck(glDeleteSamplers(n, samplers));
    }

    void DeleteSync(GLsync sync SOURCE_LOCATION)
    {
        glCheck(glDeleteSync(sync));
    }

    void DeleteTransformFeedbacks(GLsizei n, const GLuint* ids SOURCE_LOCATION)
    {
        glCheck(glDeleteTransformFeedbacks(n, ids));
    }

    void DepthRangef(GLfloat n, GLfloat f SOURCE_LOCATION)
    {
        glCheck(glDepthRangef(n, f));
    }

	void DepthFunc(GLenum func SOURCE_LOCATION)
	{
        glCheck(glDepthFunc(func));
	}

	void DrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount SOURCE_LOCATION)
    {
        glCheck(glDrawArraysInstanced(mode, first, count, primcount));
    }

    void DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount SOURCE_LOCATION)
    {
        glCheck(glDrawElementsInstanced(mode, count, type, indices, primcount));
    }

    void EndQuery(GLenum target SOURCE_LOCATION)
    {
        glCheck(glEndQuery(target));
    }

    void EndTransformFeedback(VOID_SOURCE_LOCATION)
    {
        glCheck(glEndTransformFeedback());
    }

    void FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer SOURCE_LOCATION)
    {
        glCheck(glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer));
    }

    void FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer SOURCE_LOCATION)
    {
        glCheck(glFramebufferTextureLayer(target, attachment, texture, level, layer));
    }

    void GenerateMipmap(GLenum target SOURCE_LOCATION)
    {
        glCheck(glGenerateMipmap(target));
    }

    void GenQueries(GLsizei n, GLuint* ids SOURCE_LOCATION)
    {
        glCheck(glGenQueries(n, ids));
    }

    void GenRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION)
    {
        glCheck(glGenRenderbuffers(n, renderbuffers));
    }

    void GenSamplers(GLsizei n, GLuint* samplers SOURCE_LOCATION)
    {
        glCheck(glGenSamplers(n, samplers));
    }

    void GenTransformFeedbacks(GLsizei n, GLuint* ids SOURCE_LOCATION)
    {
        glCheck(glGenTransformFeedbacks(n, ids));
    }

    void GetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params));
    }

    void GetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName SOURCE_LOCATION)
    {
        glCheck(glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName));
    }

    void GetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params));
    }

    void GetBooleani_v(GLenum target, GLuint index, GLboolean* data SOURCE_LOCATION)
    {
        glCheck(glGetBooleani_v(target, index, data));
    }

    void GetBufferParameteri64v(GLenum target, GLenum value, GLint64* data SOURCE_LOCATION)
    {
        glCheck(glGetBufferParameteri64v(target, value, data));
    }

    void GetBufferParameteriv(GLenum target, GLenum value, GLint* data SOURCE_LOCATION)
    {
        glCheck(glGetBufferParameteriv(target, value, data));
    }

    void GetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glGetBufferSubData(target, offset, size, data));
    }

    void GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetFramebufferAttachmentParameteriv(target, attachment, pname, params));
    }

    void GetInteger64i_v(GLenum target, GLuint index, GLint64* data SOURCE_LOCATION)
    {
        glCheck(glGetInteger64i_v(target, index, data));
    }

    void GetInteger64v(GLenum pname, GLint64* data SOURCE_LOCATION)
    {
        glCheck(glGetInteger64v(pname, data));
    }

    void GetIntegeri_v(GLenum target, GLuint index, GLint* data SOURCE_LOCATION)
    {
        glCheck(glGetIntegeri_v(target, index, data));
    }

    void GetQueryiv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetQueryiv(target, pname, params));
    }

    void GetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params SOURCE_LOCATION)
    {
        glCheck(glGetQueryObjectuiv(id, pname, params));
    }

    void GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetRenderbufferParameteriv(target, pname, params));
    }

    void GetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glGetSamplerParameterfv(sampler, pname, params));
    }

    void GetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetSamplerParameteriv(sampler, pname, params));
    }

    void GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values SOURCE_LOCATION)
    {
        glCheck(glGetSynciv(sync, pname, bufSize, length, values));
    }

    void GetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name SOURCE_LOCATION)
    {
        glCheck(glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name));
    }

    void GetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices SOURCE_LOCATION)
    {
        glCheck(glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices));
    }

    void GetVertexAttribIiv(GLuint index, GLenum pname, GLint* params SOURCE_LOCATION)
    {
        glCheck(glGetVertexAttribIiv(index, pname, params));
    }

    void GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params SOURCE_LOCATION)
    {
        glCheck(glGetVertexAttribIuiv(index, pname, params));
    }

    void PauseTransformFeedback(VOID_SOURCE_LOCATION)
    {
        glCheck(glPauseTransformFeedback());
    }

    void ReadBuffer(GLenum mode SOURCE_LOCATION)
    {
        glCheck(glReadBuffer(mode));
    }

    void RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glRenderbufferStorage(target, internalformat, width, height));
    }

    void RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glRenderbufferStorageMultisample(target, samples, internalformat, width, height));
    }

    void ResumeTransformFeedback(VOID_SOURCE_LOCATION)
    {
        glCheck(glResumeTransformFeedback());
    }

    void SamplerParameterf(GLuint sampler, GLenum pname, GLfloat param SOURCE_LOCATION)
    {
        glCheck(glSamplerParameterf(sampler, pname, param));
    }

    void SamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params SOURCE_LOCATION)
    {
        glCheck(glSamplerParameterfv(sampler, pname, params));
    }

    void SamplerParameteri(GLuint sampler, GLenum pname, GLint param SOURCE_LOCATION)
    {
        glCheck(glSamplerParameteri(sampler, pname, param));
    }

    void SamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params SOURCE_LOCATION)
    {
        glCheck(glSamplerParameteriv(sampler, pname, params));
    }

    void TexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, data));
    }

    void TexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth SOURCE_LOCATION)
    {
        glCheck(glTexStorage3D(target, levels, internalformat, width, height, depth));
    }

    void TexSubImage3D(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION)
    {
        glCheck(glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data));
    }

    void TransformFeedbackVaryings(GLuint program, GLsizei count, const char** varyings, GLenum bufferMode SOURCE_LOCATION)
    {
        glCheck(glTransformFeedbackVaryings(program, count, varyings, bufferMode));
    }

    void UniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding SOURCE_LOCATION)
    {
        glCheck(glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding));
    }

    void VertexAttribDivisor(GLuint index, GLuint divisor SOURCE_LOCATION)
    {
        glCheck(glVertexAttribDivisor(index, divisor));
    }

    void VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer SOURCE_LOCATION)
    {
        glCheck(glVertexAttribIPointer(index, size, type, stride, pointer));
    }

    void WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout SOURCE_LOCATION)
    {
        glCheck(glWaitSync(sync, flags, timeout));
    }

    void TexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION)
    {
        glCheck(glTexStorage2D(target, levels, internalformat, width, height));
    }

#if !defined(IS_WEBGL2)

    // OpenGL 4.3+ Debug functions
    void DebugMessageCallback(DEBUGPROC callback, const void* userParam SOURCE_LOCATION)
    {
        glCheck(glDebugMessageCallback(callback, userParam));
    }

    void DebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled SOURCE_LOCATION)
    {
        glCheck(glDebugMessageControl(source, type, severity, count, ids, enabled));
    }

#endif

}



================================================
FILE: source/OpenGL/GL.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include "GLConstants.h"
#include "GLTypes.h"


#if defined(DEVELOPER_VERSION)
#    include <source_location>
#    define VOID_SOURCE_LOCATION const std::source_location caller_location = std::source_location::current()
#    define SOURCE_LOCATION      , VOID_SOURCE_LOCATION
#else
#    define SOURCE_LOCATION
#    define VOID_SOURCE_LOCATION void
#endif


namespace GL
{
    // Opengl Version 2.0
    const GLubyte* GetString(GLenum name SOURCE_LOCATION);
    GLboolean      IsBuffer(GLuint buffer SOURCE_LOCATION);
    GLboolean      IsEnabled(GLenum cap SOURCE_LOCATION);
    GLboolean      IsProgram(GLuint program SOURCE_LOCATION);
    GLboolean      IsShader(GLuint shader SOURCE_LOCATION);
    GLboolean      IsTexture(GLuint texture SOURCE_LOCATION);
    GLenum         GetError(void);
    GLint          GetAttribLocation(GLuint program, const GLchar* name SOURCE_LOCATION);
    GLint          GetUniformLocation(GLuint program, const GLchar* name SOURCE_LOCATION);
    GLuint         CreateProgram(VOID_SOURCE_LOCATION);
    GLuint         CreateShader(GLenum shaderType SOURCE_LOCATION);
    void           ActiveTexture(GLenum texture SOURCE_LOCATION);
    void           AttachShader(GLuint program, GLuint shader SOURCE_LOCATION);
    void           BindBuffer(GLenum target, GLuint buffer SOURCE_LOCATION);
    void           BindBufferBase(GLenum target, GLuint index, GLuint buffer SOURCE_LOCATION);
    void           BindTexture(GLenum target, GLuint texture SOURCE_LOCATION);
    void           BlendEquation(GLenum mode SOURCE_LOCATION);
    void           BlendFunc(GLenum sfactor, GLenum dfactor SOURCE_LOCATION);
    //added
    void BlitFramebuffer(
        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
        GLbitfield mask, GLenum filter SOURCE_LOCATION);
    void           BufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage SOURCE_LOCATION);
    void           BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data SOURCE_LOCATION);
    void           Clear(GLbitfield mask SOURCE_LOCATION);
    void           ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha SOURCE_LOCATION);
    void           ClearDepth(GLdouble depth SOURCE_LOCATION);
    void           ClearStencil(GLint s SOURCE_LOCATION);
    void           ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha SOURCE_LOCATION);
    void           CompileShader(GLuint shader SOURCE_LOCATION);
    void           CopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border SOURCE_LOCATION);
    void           CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION);
    void           CullFace(GLenum mode SOURCE_LOCATION);
    void           DeleteBuffers(GLsizei n, const GLuint* buffers SOURCE_LOCATION);
    void           DeleteProgram(GLuint program SOURCE_LOCATION);
    void           DeleteShader(GLuint shader SOURCE_LOCATION);
    void           DeleteTextures(GLsizei n, const GLuint* textures SOURCE_LOCATION);
    void           DepthMask(GLboolean flag SOURCE_LOCATION);
    void           DepthRange(GLdouble nearVal, GLdouble farVal SOURCE_LOCATION);
    void           DetachShader(GLuint program, GLuint shader SOURCE_LOCATION);
    void           Disable(GLenum cap SOURCE_LOCATION);
    void           DisableVertexAttribArray(GLuint index SOURCE_LOCATION);
    void           DrawArrays(GLenum mode, GLint first, GLsizei count SOURCE_LOCATION);
    void           DrawBuffers(GLsizei n, const GLenum* bufs SOURCE_LOCATION);
    void           DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices SOURCE_LOCATION);
    void           DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices SOURCE_LOCATION);
    void           Enable(GLenum cap SOURCE_LOCATION);
    void           EnableVertexAttribArray(GLuint index SOURCE_LOCATION);
    void           FrontFace(GLenum mode SOURCE_LOCATION);
    void           GenBuffers(GLsizei n, GLuint* buffers SOURCE_LOCATION);
    void           GenTextures(GLsizei n, GLuint* textures SOURCE_LOCATION);
    void           GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name SOURCE_LOCATION);
    void           GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name SOURCE_LOCATION);
    void           GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders SOURCE_LOCATION);
    void           GetBooleanv(GLenum pname, GLboolean* data SOURCE_LOCATION);
    void           GetFloatv(GLenum pname, GLfloat* data SOURCE_LOCATION);
    void           GetIntegerv(GLenum pname, GLint* data SOURCE_LOCATION);
    void           GetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog SOURCE_LOCATION);
    void           GetProgramiv(GLuint program, GLenum pname, GLint* params SOURCE_LOCATION);
    void           GetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog SOURCE_LOCATION);
    void           GetShaderiv(GLuint shader, GLenum pname, GLint* params SOURCE_LOCATION);
    void           GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source SOURCE_LOCATION);
    void           GetTexParameterfv(GLenum target, GLenum pname, GLfloat* params SOURCE_LOCATION);
    void           GetTexParameteriv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION);
    void           GetUniformfv(GLuint program, GLint location, GLfloat* params SOURCE_LOCATION);
    void           GetUniformiv(GLuint program, GLint location, GLint* params SOURCE_LOCATION);
    void           GetUniformuiv(GLuint program, GLint location, GLuint* params SOURCE_LOCATION);
    void           GetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params SOURCE_LOCATION);
    void           GetVertexAttribiv(GLuint index, GLenum pname, GLint* params SOURCE_LOCATION);
    void           GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer SOURCE_LOCATION);
    void           Hint(GLenum target, GLenum mode SOURCE_LOCATION);
    void           LineWidth(GLfloat width SOURCE_LOCATION);
    void           LinkProgram(GLuint program SOURCE_LOCATION);
    void           PixelStorei(GLenum pname, GLint param SOURCE_LOCATION);
    void           PolygonOffset(GLfloat factor, GLfloat units SOURCE_LOCATION);
    void           ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels SOURCE_LOCATION);
    void           Scissor(GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION);
    void           ShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint* length SOURCE_LOCATION);
    void           StencilMask(GLuint mask SOURCE_LOCATION);
    void           StencilMaskSeparate(GLenum face, GLuint mask SOURCE_LOCATION);
    void           TexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION);
    void           TexParameterf(GLenum target, GLenum pname, GLfloat param SOURCE_LOCATION);
    void           TexParameterfv(GLenum target, GLenum pname, const GLfloat* params SOURCE_LOCATION);
    void           TexParameteri(GLenum target, GLenum pname, GLint param SOURCE_LOCATION);
    void           TexParameteriv(GLenum target, GLenum pname, const GLint* params SOURCE_LOCATION);
    void           TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels SOURCE_LOCATION);
    void           Uniform1f(GLint location, GLfloat v0 SOURCE_LOCATION);
    void           Uniform1fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION);
    void           Uniform1i(GLint location, GLint v0 SOURCE_LOCATION);
    void           Uniform1iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION);
    void           Uniform1ui(GLint location, GLuint v0 SOURCE_LOCATION);
    void           Uniform1uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION);
    void           Uniform2f(GLint location, GLfloat v0, GLfloat v1 SOURCE_LOCATION);
    void           Uniform2fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION);
    void           Uniform2i(GLint location, GLint v0, GLint v1 SOURCE_LOCATION);
    void           Uniform2iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION);
    void           Uniform2ui(GLint location, GLuint v0, GLuint v1 SOURCE_LOCATION);
    void           Uniform2uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION);
    void           Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2 SOURCE_LOCATION);
    void           Uniform3fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION);
    void           Uniform3i(GLint location, GLint v0, GLint v1, GLint v2 SOURCE_LOCATION);
    void           Uniform3iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION);
    void           Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2 SOURCE_LOCATION);
    void           Uniform3uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION);
    void           Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 SOURCE_LOCATION);
    void           Uniform4fv(GLint location, GLsizei count, const GLfloat* value SOURCE_LOCATION);
    void           Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3 SOURCE_LOCATION);
    void           Uniform4iv(GLint location, GLsizei count, const GLint* value SOURCE_LOCATION);
    void           Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 SOURCE_LOCATION);
    void           Uniform4uiv(GLint location, GLsizei count, const GLuint* value SOURCE_LOCATION);
    void           UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value SOURCE_LOCATION);
    void           UseProgram(GLuint program SOURCE_LOCATION);
    void           ValidateProgram(GLuint program SOURCE_LOCATION);
    void           VertexAttrib1f(GLuint index, GLfloat v0 SOURCE_LOCATION);
    void           VertexAttrib1fv(GLuint index, const GLfloat* v SOURCE_LOCATION);
    void           VertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1 SOURCE_LOCATION);
    void           VertexAttrib2fv(GLuint index, const GLfloat* v SOURCE_LOCATION);
    void           VertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2 SOURCE_LOCATION);
    void           VertexAttrib3fv(GLuint index, const GLfloat* v SOURCE_LOCATION);
    void           VertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 SOURCE_LOCATION);
    void           VertexAttrib4fv(GLuint index, const GLfloat* v SOURCE_LOCATION);
    void           VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer SOURCE_LOCATION);
    void           Viewport(GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION);


    // Opengl Version 3.0
    GLboolean IsFramebuffer(GLuint framebuffer SOURCE_LOCATION);
    GLboolean IsQuery(GLuint id SOURCE_LOCATION);
    GLboolean IsRenderbuffer(GLuint renderbuffer SOURCE_LOCATION);
    GLboolean IsSampler(GLuint id SOURCE_LOCATION);
    GLboolean IsSync(GLsync sync SOURCE_LOCATION);
    GLboolean IsTransformFeedback(GLuint id SOURCE_LOCATION);
    GLenum    CheckFramebufferStatus(GLenum target SOURCE_LOCATION);
    GLenum    ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout SOURCE_LOCATION);
    GLint     GetFragDataLocation(GLuint program, const char* name SOURCE_LOCATION);
    GLsync    FenceSync(GLenum condition, GLbitfield flags SOURCE_LOCATION);
    GLuint    GetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName SOURCE_LOCATION);
    void      BeginQuery(GLenum target, GLuint id SOURCE_LOCATION);
    void      BeginTransformFeedback(GLenum primitiveMode SOURCE_LOCATION);
    void      BindFramebuffer(GLenum target, GLuint framebuffer SOURCE_LOCATION);
    void      BindRenderbuffer(GLenum target, GLuint renderbuffer SOURCE_LOCATION);
    void      BindVertexArray(GLuint array SOURCE_LOCATION);
    void      ClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil SOURCE_LOCATION);
    void      ClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value SOURCE_LOCATION);
    void      ClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value SOURCE_LOCATION);
    void      ClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value SOURCE_LOCATION);
    void      ClearDepthf(GLfloat depth SOURCE_LOCATION);
    void      CompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION);
    void CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION);
    void CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION);
    void CompressedTexSubImage3D(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data SOURCE_LOCATION);
    void CopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size SOURCE_LOCATION);
    void CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height SOURCE_LOCATION);
    void CreateRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION);
    void CreateSamplers(GLsizei n, GLuint* samplers SOURCE_LOCATION);
    void CreateTransformFeedbacks(GLsizei n, GLuint* ids SOURCE_LOCATION);
    void DeleteFramebuffers(GLsizei n, GLuint* framebuffers SOURCE_LOCATION);
    void DeleteQueries(GLsizei n, const GLuint* ids SOURCE_LOCATION);
    void DeleteRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION);
    void DeleteSamplers(GLsizei n, const GLuint* samplers SOURCE_LOCATION);
    void DeleteSync(GLsync sync SOURCE_LOCATION);
    void DeleteTransformFeedbacks(GLsizei n, const GLuint* ids SOURCE_LOCATION);
    void DeleteVertexArrays(GLsizei n, const GLuint* arrays SOURCE_LOCATION);
    void DepthRangef(GLfloat n, GLfloat f SOURCE_LOCATION);
    //added
    void DepthFunc(GLenum func SOURCE_LOCATION);
    //end added
    void DrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount SOURCE_LOCATION);
    void DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount SOURCE_LOCATION);
    void EndQuery(GLenum target SOURCE_LOCATION);
    void EndTransformFeedback(VOID_SOURCE_LOCATION);
    void FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer SOURCE_LOCATION);
    void FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level SOURCE_LOCATION);
    void FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer SOURCE_LOCATION);
    void GenerateMipmap(GLenum target SOURCE_LOCATION);
    void GenFramebuffers(GLsizei n, GLuint* framebuffers SOURCE_LOCATION);
    void GenQueries(GLsizei n, GLuint* ids SOURCE_LOCATION);
    void GenRenderbuffers(GLsizei n, GLuint* renderbuffers SOURCE_LOCATION);
    void GenSamplers(GLsizei n, GLuint* samplers SOURCE_LOCATION);
    void GenTransformFeedbacks(GLsizei n, GLuint* ids SOURCE_LOCATION);
    void GenVertexArrays(GLsizei n, GLuint* arrays SOURCE_LOCATION);
    void GetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName SOURCE_LOCATION);
    void GetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetBooleani_v(GLenum target, GLuint index, GLboolean* data SOURCE_LOCATION);
    void GetBufferParameteri64v(GLenum target, GLenum value, GLint64* data SOURCE_LOCATION);
    void GetBufferParameteriv(GLenum target, GLenum value, GLint* data SOURCE_LOCATION);
    void GetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data SOURCE_LOCATION);
    void GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetInteger64i_v(GLenum target, GLuint index, GLint64* data SOURCE_LOCATION);
    void GetInteger64v(GLenum pname, GLint64* data SOURCE_LOCATION);
    void GetIntegeri_v(GLenum target, GLuint index, GLint* data SOURCE_LOCATION);
    void GetQueryiv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params SOURCE_LOCATION);
    void GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params SOURCE_LOCATION);
    void GetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values SOURCE_LOCATION);
    void GetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name SOURCE_LOCATION);
    void GetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices SOURCE_LOCATION);
    void GetVertexAttribIiv(GLuint index, GLenum pname, GLint* params SOURCE_LOCATION);
    void GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params SOURCE_LOCATION);
    void PauseTransformFeedback(VOID_SOURCE_LOCATION);
    void ReadBuffer(GLenum mode SOURCE_LOCATION);
    void RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION);
    void RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION);
    void ResumeTransformFeedback(VOID_SOURCE_LOCATION);
    void SamplerParameterf(GLuint sampler, GLenum pname, GLfloat param SOURCE_LOCATION);
    void SamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params SOURCE_LOCATION);
    void SamplerParameteri(GLuint sampler, GLenum pname, GLint param SOURCE_LOCATION);
    void SamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params SOURCE_LOCATION);
    void TexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION);
    void TexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth SOURCE_LOCATION);
    void TexSubImage3D(
        GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data SOURCE_LOCATION);
    void TransformFeedbackVaryings(GLuint program, GLsizei count, const char** varyings, GLenum bufferMode SOURCE_LOCATION);
    void UniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding SOURCE_LOCATION);
    void VertexAttribDivisor(GLuint index, GLuint divisor SOURCE_LOCATION);
    void VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer SOURCE_LOCATION);
    void WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout SOURCE_LOCATION);

    // Opengl Version 3.2
    void TexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations SOURCE_LOCATION);

    // Opengl ES 3.0 or Opengl Version 4.2
    void TexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height SOURCE_LOCATION);


    // Opengl 4.3
    void DebugMessageCallback(DEBUGPROC callback, const void* userParam SOURCE_LOCATION);
    void DebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled SOURCE_LOCATION);


}

#undef SOURCE_LOCATION
#undef VOID_SOURCE_LOCATION



================================================
FILE: source/OpenGL/GLConstants.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

// Only define constants if they haven't been defined by GLEW or other OpenGL headers
#ifndef GL_DEPTH_BUFFER_BIT

// OpenGL Version 1.0
#    define GL_DEPTH_BUFFER_BIT        0x00000100
#    define GL_STENCIL_BUFFER_BIT      0x00000400
#    define GL_COLOR_BUFFER_BIT        0x00004000
#    define GL_FALSE                   0
#    define GL_TRUE                    1
#    define GL_POINTS                  0x0000
#    define GL_LINES                   0x0001
#    define GL_LINE_LOOP               0x0002
#    define GL_LINE_STRIP              0x0003
#    define GL_TRIANGLES               0x0004
#    define GL_TRIANGLE_STRIP          0x0005
#    define GL_TRIANGLE_FAN            0x0006
#    define GL_QUADS                   0x0007
#    define GL_NEVER                   0x0200
#    define GL_LESS                    0x0201
#    define GL_EQUAL                   0x0202
#    define GL_LEQUAL                  0x0203
#    define GL_GREATER                 0x0204
#    define GL_NOTEQUAL                0x0205
#    define GL_GEQUAL                  0x0206
#    define GL_ALWAYS                  0x0207
#    define GL_ZERO                    0
#    define GL_ONE                     1
#    define GL_SRC_COLOR               0x0300
#    define GL_ONE_MINUS_SRC_COLOR     0x0301
#    define GL_SRC_ALPHA               0x0302
#    define GL_ONE_MINUS_SRC_ALPHA     0x0303
#    define GL_DST_ALPHA               0x0304
#    define GL_ONE_MINUS_DST_ALPHA     0x0305
#    define GL_DST_COLOR               0x0306
#    define GL_ONE_MINUS_DST_COLOR     0x0307
#    define GL_SRC_ALPHA_SATURATE      0x0308
#    define GL_NONE                    0
#    define GL_FRONT_LEFT              0x0400
#    define GL_FRONT_RIGHT             0x0401
#    define GL_BACK_LEFT               0x0402
#    define GL_BACK_RIGHT              0x0403
#    define GL_FRONT                   0x0404
#    define GL_BACK                    0x0405
#    define GL_LEFT                    0x0406
#    define GL_RIGHT                   0x0407
#    define GL_FRONT_AND_BACK          0x0408
#    define GL_NO_ERROR                0
#    define GL_INVALID_ENUM            0x0500
#    define GL_INVALID_VALUE           0x0501
#    define GL_INVALID_OPERATION       0x0502
#    define GL_OUT_OF_MEMORY           0x0505
#    define GL_CW                      0x0900
#    define GL_CCW                     0x0901
#    define GL_POINT_SIZE              0x0B11
#    define GL_POINT_SIZE_RANGE        0x0B12
#    define GL_POINT_SIZE_GRANULARITY  0x0B13
#    define GL_LINE_SMOOTH             0x0B20
#    define GL_LINE_WIDTH              0x0B21
#    define GL_LINE_WIDTH_RANGE        0x0B22
#    define GL_LINE_WIDTH_GRANULARITY  0x0B23
#    define GL_POLYGON_MODE            0x0B40
#    define GL_POLYGON_SMOOTH          0x0B41
#    define GL_CULL_FACE               0x0B44
#    define GL_CULL_FACE_MODE          0x0B45
#    define GL_FRONT_FACE              0x0B46
#    define GL_DEPTH_RANGE             0x0B70
#    define GL_DEPTH_TEST              0x0B71
#    define GL_DEPTH_WRITEMASK         0x0B72
#    define GL_DEPTH_CLEAR_VALUE       0x0B73
#    define GL_DEPTH_FUNC              0x0B74
#    define GL_STENCIL_TEST            0x0B90
#    define GL_STENCIL_CLEAR_VALUE     0x0B91
#    define GL_STENCIL_FUNC            0x0B92
#    define GL_STENCIL_VALUE_MASK      0x0B93
#    define GL_STENCIL_FAIL            0x0B94
#    define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#    define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#    define GL_STENCIL_REF             0x0B97
#    define GL_STENCIL_WRITEMASK       0x0B98
#    define GL_VIEWPORT                0x0BA2
#    define GL_DITHER                  0x0BD0
#    define GL_BLEND_DST               0x0BE0
#    define GL_BLEND_SRC               0x0BE1
#    define GL_BLEND                   0x0BE2
#    define GL_LOGIC_OP_MODE           0x0BF0
#    define GL_DRAW_BUFFER             0x0C01
#    define GL_READ_BUFFER             0x0C02
#    define GL_SCISSOR_BOX             0x0C10
#    define GL_SCISSOR_TEST            0x0C11
#    define GL_COLOR_CLEAR_VALUE       0x0C22
#    define GL_COLOR_WRITEMASK         0x0C23
#    define GL_DOUBLEBUFFER            0x0C32
#    define GL_STEREO                  0x0C33
#    define GL_LINE_SMOOTH_HINT        0x0C52
#    define GL_POLYGON_SMOOTH_HINT     0x0C53
#    define GL_UNPACK_SWAP_BYTES       0x0CF0
#    define GL_UNPACK_LSB_FIRST        0x0CF1
#    define GL_UNPACK_ROW_LENGTH       0x0CF2
#    define GL_UNPACK_SKIP_ROWS        0x0CF3
#    define GL_UNPACK_SKIP_PIXELS      0x0CF4
#    define GL_UNPACK_ALIGNMENT        0x0CF5
#    define GL_PACK_SWAP_BYTES         0x0D00
#    define GL_PACK_LSB_FIRST          0x0D01
#    define GL_PACK_ROW_LENGTH         0x0D02
#    define GL_PACK_SKIP_ROWS          0x0D03
#    define GL_PACK_SKIP_PIXELS        0x0D04
#    define GL_PACK_ALIGNMENT          0x0D05
#    define GL_MAX_TEXTURE_SIZE        0x0D33
#    define GL_MAX_VIEWPORT_DIMS       0x0D3A
#    define GL_SUBPIXEL_BITS           0x0D50
#    define GL_TEXTURE_1D              0x0DE0
#    define GL_TEXTURE_2D              0x0DE1
#    define GL_TEXTURE_WIDTH           0x1000
#    define GL_TEXTURE_HEIGHT          0x1001
#    define GL_TEXTURE_BORDER_COLOR    0x1004
#    define GL_DONT_CARE               0x1100
#    define GL_FASTEST                 0x1101
#    define GL_NICEST                  0x1102
#    define GL_BYTE                    0x1400
#    define GL_UNSIGNED_BYTE           0x1401
#    define GL_SHORT                   0x1402
#    define GL_UNSIGNED_SHORT          0x1403
#    define GL_INT                     0x1404
#    define GL_UNSIGNED_INT            0x1405
#    define GL_FLOAT                   0x1406
#    define GL_STACK_OVERFLOW          0x0503
#    define GL_STACK_UNDERFLOW         0x0504
#    define GL_CLEAR                   0x1500
#    define GL_AND                     0x1501
#    define GL_AND_REVERSE             0x1502
#    define GL_COPY                    0x1503
#    define GL_AND_INVERTED            0x1504
#    define GL_NOOP                    0x1505
#    define GL_XOR                     0x1506
#    define GL_OR                      0x1507
#    define GL_NOR                     0x1508
#    define GL_EQUIV                   0x1509
#    define GL_INVERT                  0x150A
#    define GL_OR_REVERSE              0x150B
#    define GL_COPY_INVERTED           0x150C
#    define GL_OR_INVERTED             0x150D
#    define GL_NAND                    0x150E
#    define GL_SET                     0x150F
#    define GL_TEXTURE                 0x1702
#    define GL_COLOR                   0x1800
#    define GL_DEPTH                   0x1801
#    define GL_STENCIL                 0x1802
#    define GL_STENCIL_INDEX           0x1901
#    define GL_DEPTH_COMPONENT         0x1902
#    define GL_RED                     0x1903
#    define GL_GREEN                   0x1904
#    define GL_BLUE                    0x1905
#    define GL_ALPHA                   0x1906
#    define GL_RGB                     0x1907
#    define GL_RGBA                    0x1908
#    define GL_POINT                   0x1B00
#    define GL_LINE                    0x1B01
#    define GL_FILL                    0x1B02
#    define GL_KEEP                    0x1E00
#    define GL_REPLACE                 0x1E01
#    define GL_INCR                    0x1E02
#    define GL_DECR                    0x1E03
#    define GL_VENDOR                  0x1F00
#    define GL_RENDERER                0x1F01
#    define GL_VERSION                 0x1F02
#    define GL_EXTENSIONS              0x1F03
#    define GL_NEAREST                 0x2600
#    define GL_LINEAR                  0x2601
#    define GL_NEAREST_MIPMAP_NEAREST  0x2700
#    define GL_LINEAR_MIPMAP_NEAREST   0x2701
#    define GL_NEAREST_MIPMAP_LINEAR   0x2702
#    define GL_LINEAR_MIPMAP_LINEAR    0x2703
#    define GL_TEXTURE_MAG_FILTER      0x2800
#    define GL_TEXTURE_MIN_FILTER      0x2801
#    define GL_TEXTURE_WRAP_S          0x2802
#    define GL_TEXTURE_WRAP_T          0x2803
#    define GL_REPEAT                  0x2901

// OpenGL Version 1.1
#    define GL_COLOR_LOGIC_OP          0x0BF2
#    define GL_POLYGON_OFFSET_UNITS    0x2A00
#    define GL_POLYGON_OFFSET_POINT    0x2A01
#    define GL_POLYGON_OFFSET_LINE     0x2A02
#    define GL_POLYGON_OFFSET_FILL     0x8037
#    define GL_POLYGON_OFFSET_FACTOR   0x8038
#    define GL_TEXTURE_BINDING_1D      0x8068
#    define GL_TEXTURE_BINDING_2D      0x8069
#    define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#    define GL_TEXTURE_RED_SIZE        0x805C
#    define GL_TEXTURE_GREEN_SIZE      0x805D
#    define GL_TEXTURE_BLUE_SIZE       0x805E
#    define GL_TEXTURE_ALPHA_SIZE      0x805F
#    define GL_DOUBLE                  0x140A
#    define GL_PROXY_TEXTURE_1D        0x8063
#    define GL_PROXY_TEXTURE_2D        0x8064
#    define GL_R3_G3_B2                0x2A10
#    define GL_RGB4                    0x804F
#    define GL_RGB5                    0x8050
#    define GL_RGB8                    0x8051
#    define GL_RGB10                   0x8052
#    define GL_RGB12                   0x8053
#    define GL_RGB16                   0x8054
#    define GL_RGBA2                   0x8055
#    define GL_RGBA4                   0x8056
#    define GL_RGB5_A1                 0x8057
#    define GL_RGBA8                   0x8058
#    define GL_RGB10_A2                0x8059
#    define GL_RGBA12                  0x805A
#    define GL_RGBA16                  0x805B
#    define GL_VERTEX_ARRAY            0x8074

// OpenGL Version 1.2
#    define GL_UNSIGNED_BYTE_3_3_2           0x8032
#    define GL_UNSIGNED_SHORT_4_4_4_4        0x8033
#    define GL_UNSIGNED_SHORT_5_5_5_1        0x8034
#    define GL_UNSIGNED_INT_8_8_8_8          0x8035
#    define GL_UNSIGNED_INT_10_10_10_2       0x8036
#    define GL_TEXTURE_BINDING_3D            0x806A
#    define GL_PACK_SKIP_IMAGES              0x806B
#    define GL_PACK_IMAGE_HEIGHT             0x806C
#    define GL_UNPACK_SKIP_IMAGES            0x806D
#    define GL_UNPACK_IMAGE_HEIGHT           0x806E
#    define GL_TEXTURE_3D                    0x806F
#    define GL_PROXY_TEXTURE_3D              0x8070
#    define GL_TEXTURE_DEPTH                 0x8071
#    define GL_TEXTURE_WRAP_R                0x8072
#    define GL_MAX_3D_TEXTURE_SIZE           0x8073
#    define GL_UNSIGNED_BYTE_2_3_3_REV       0x8362
#    define GL_UNSIGNED_SHORT_5_6_5          0x8363
#    define GL_UNSIGNED_SHORT_5_6_5_REV      0x8364
#    define GL_UNSIGNED_SHORT_4_4_4_4_REV    0x8365
#    define GL_UNSIGNED_SHORT_1_5_5_5_REV    0x8366
#    define GL_UNSIGNED_INT_8_8_8_8_REV      0x8367
#    define GL_UNSIGNED_INT_2_10_10_10_REV   0x8368
#    define GL_BGR                           0x80E0
#    define GL_BGRA                          0x80E1
#    define GL_MAX_ELEMENTS_VERTICES         0x80E8
#    define GL_MAX_ELEMENTS_INDICES          0x80E9
#    define GL_CLAMP_TO_EDGE                 0x812F
#    define GL_TEXTURE_MIN_LOD               0x813A
#    define GL_TEXTURE_MAX_LOD               0x813B
#    define GL_TEXTURE_BASE_LEVEL            0x813C
#    define GL_TEXTURE_MAX_LEVEL             0x813D
#    define GL_SMOOTH_POINT_SIZE_RANGE       0x0B12
#    define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#    define GL_SMOOTH_LINE_WIDTH_RANGE       0x0B22
#    define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#    define GL_ALIASED_LINE_WIDTH_RANGE      0x846E

// OpenGL Version 1.3
#    define GL_TEXTURE0                       0x84C0
#    define GL_TEXTURE1                       0x84C1
#    define GL_TEXTURE2                       0x84C2
#    define GL_TEXTURE3                       0x84C3
#    define GL_TEXTURE4                       0x84C4
#    define GL_TEXTURE5                       0x84C5
#    define GL_TEXTURE6                       0x84C6
#    define GL_TEXTURE7                       0x84C7
#    define GL_TEXTURE8                       0x84C8
#    define GL_TEXTURE9                       0x84C9
#    define GL_TEXTURE10                      0x84CA
#    define GL_TEXTURE11                      0x84CB
#    define GL_TEXTURE12                      0x84CC
#    define GL_TEXTURE13                      0x84CD
#    define GL_TEXTURE14                      0x84CE
#    define GL_TEXTURE15                      0x84CF
#    define GL_TEXTURE16                      0x84D0
#    define GL_TEXTURE17                      0x84D1
#    define GL_TEXTURE18                      0x84D2
#    define GL_TEXTURE19                      0x84D3
#    define GL_TEXTURE20                      0x84D4
#    define GL_TEXTURE21                      0x84D5
#    define GL_TEXTURE22                      0x84D6
#    define GL_TEXTURE23                      0x84D7
#    define GL_TEXTURE24                      0x84D8
#    define GL_TEXTURE25                      0x84D9
#    define GL_TEXTURE26                      0x84DA
#    define GL_TEXTURE27                      0x84DB
#    define GL_TEXTURE28                      0x84DC
#    define GL_TEXTURE29                      0x84DD
#    define GL_TEXTURE30                      0x84DE
#    define GL_TEXTURE31                      0x84DF
#    define GL_ACTIVE_TEXTURE                 0x84E0
#    define GL_MULTISAMPLE                    0x809D
#    define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#    define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#    define GL_SAMPLE_COVERAGE                0x80A0
#    define GL_SAMPLE_BUFFERS                 0x80A8
#    define GL_SAMPLES                        0x80A9
#    define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#    define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#    define GL_TEXTURE_CUBE_MAP               0x8513
#    define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#    define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#    define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#    define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#    define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#    define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#    define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#    define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
#    define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#    define GL_COMPRESSED_RGB                 0x84ED
#    define GL_COMPRESSED_RGBA                0x84EE
#    define GL_TEXTURE_COMPRESSION_HINT       0x84EF
#    define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
#    define GL_TEXTURE_COMPRESSED             0x86A1
#    define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#    define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#    define GL_CLAMP_TO_BORDER                0x812D

// OpenGL Version 1.4
#    define GL_BLEND_DST_RGB             0x80C8
#    define GL_BLEND_SRC_RGB             0x80C9
#    define GL_BLEND_DST_ALPHA           0x80CA
#    define GL_BLEND_SRC_ALPHA           0x80CB
#    define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#    define GL_DEPTH_COMPONENT16         0x81A5
#    define GL_DEPTH_COMPONENT24         0x81A6
#    define GL_DEPTH_COMPONENT32         0x81A7
#    define GL_MIRRORED_REPEAT           0x8370
#    define GL_MAX_TEXTURE_LOD_BIAS      0x84FD
#    define GL_TEXTURE_LOD_BIAS          0x8501
#    define GL_INCR_WRAP                 0x8507
#    define GL_DECR_WRAP                 0x8508
#    define GL_TEXTURE_DEPTH_SIZE        0x884A
#    define GL_TEXTURE_COMPARE_MODE      0x884C
#    define GL_TEXTURE_COMPARE_FUNC      0x884D
#    define GL_BLEND_COLOR               0x8005
#    define GL_BLEND_EQUATION            0x8009
#    define GL_CONSTANT_COLOR            0x8001
#    define GL_ONE_MINUS_CONSTANT_COLOR  0x8002
#    define GL_CONSTANT_ALPHA            0x8003
#    define GL_ONE_MINUS_CONSTANT_ALPHA  0x8004
#    define GL_FUNC_ADD                  0x8006
#    define GL_FUNC_REVERSE_SUBTRACT     0x800B
#    define GL_FUNC_SUBTRACT             0x800A
#    define GL_MIN                       0x8007
#    define GL_MAX                       0x8008

// OpenGL Version 1.5
#    define GL_BUFFER_SIZE                        0x8764
#    define GL_BUFFER_USAGE                       0x8765
#    define GL_QUERY_COUNTER_BITS                 0x8864
#    define GL_CURRENT_QUERY                      0x8865
#    define GL_QUERY_RESULT                       0x8866
#    define GL_QUERY_RESULT_AVAILABLE             0x8867
#    define GL_ARRAY_BUFFER                       0x8892
#    define GL_ELEMENT_ARRAY_BUFFER               0x8893
#    define GL_ARRAY_BUFFER_BINDING               0x8894
#    define GL_ELEMENT_ARRAY_BUFFER_BINDING       0x8895
#    define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#    define GL_READ_ONLY                          0x88B8
#    define GL_WRITE_ONLY                         0x88B9
#    define GL_READ_WRITE                         0x88BA
#    define GL_BUFFER_ACCESS                      0x88BB
#    define GL_BUFFER_MAPPED                      0x88BC
#    define GL_BUFFER_MAP_POINTER                 0x88BD
#    define GL_STREAM_DRAW                        0x88E0
#    define GL_STREAM_READ                        0x88E1
#    define GL_STREAM_COPY                        0x88E2
#    define GL_STATIC_DRAW                        0x88E4
#    define GL_STATIC_READ                        0x88E5
#    define GL_STATIC_COPY                        0x88E6
#    define GL_DYNAMIC_DRAW                       0x88E8
#    define GL_DYNAMIC_READ                       0x88E9
#    define GL_DYNAMIC_COPY                       0x88EA
#    define GL_SAMPLES_PASSED                     0x8914
#    define GL_SRC1_ALPHA                         0x8589

// OpenGL Version 2.0
#    define GL_BLEND_EQUATION_RGB               0x8009
#    define GL_VERTEX_ATTRIB_ARRAY_ENABLED      0x8622
#    define GL_VERTEX_ATTRIB_ARRAY_SIZE         0x8623
#    define GL_VERTEX_ATTRIB_ARRAY_STRIDE       0x8624
#    define GL_VERTEX_ATTRIB_ARRAY_TYPE         0x8625
#    define GL_CURRENT_VERTEX_ATTRIB            0x8626
#    define GL_VERTEX_PROGRAM_POINT_SIZE        0x8642
#    define GL_VERTEX_ATTRIB_ARRAY_POINTER      0x8645
#    define GL_STENCIL_BACK_FUNC                0x8800
#    define GL_STENCIL_BACK_FAIL                0x8801
#    define GL_STENCIL_BACK_PASS_DEPTH_FAIL     0x8802
#    define GL_STENCIL_BACK_PASS_DEPTH_PASS     0x8803
#    define GL_MAX_DRAW_BUFFERS                 0x8824
#    define GL_DRAW_BUFFER0                     0x8825
#    define GL_DRAW_BUFFER1                     0x8826
#    define GL_DRAW_BUFFER2                     0x8827
#    define GL_DRAW_BUFFER3                     0x8828
#    define GL_DRAW_BUFFER4                     0x8829
#    define GL_DRAW_BUFFER5                     0x882A
#    define GL_DRAW_BUFFER6                     0x882B
#    define GL_DRAW_BUFFER7                     0x882C
#    define GL_DRAW_BUFFER8                     0x882D
#    define GL_DRAW_BUFFER9                     0x882E
#    define GL_DRAW_BUFFER10                    0x882F
#    define GL_DRAW_BUFFER11                    0x8830
#    define GL_DRAW_BUFFER12                    0x8831
#    define GL_DRAW_BUFFER13                    0x8832
#    define GL_DRAW_BUFFER14                    0x8833
#    define GL_DRAW_BUFFER15                    0x8834
#    define GL_BLEND_EQUATION_ALPHA             0x883D
#    define GL_MAX_VERTEX_ATTRIBS               0x8869
#    define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED   0x886A
#    define GL_MAX_TEXTURE_IMAGE_UNITS          0x8872
#    define GL_FRAGMENT_SHADER                  0x8B30
#    define GL_VERTEX_SHADER                    0x8B31
#    define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS  0x8B49
#    define GL_MAX_VERTEX_UNIFORM_COMPONENTS    0x8B4A
#    define GL_MAX_VARYING_FLOATS               0x8B4B
#    define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS   0x8B4C
#    define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#    define GL_SHADER_TYPE                      0x8B4F
#    define GL_FLOAT_VEC2                       0x8B50
#    define GL_FLOAT_VEC3                       0x8B51
#    define GL_FLOAT_VEC4                       0x8B52
#    define GL_INT_VEC2                         0x8B53
#    define GL_INT_VEC3                         0x8B54
#    define GL_INT_VEC4                         0x8B55
#    define GL_BOOL                             0x8B56
#    define GL_BOOL_VEC2                        0x8B57
#    define GL_BOOL_VEC3                        0x8B58
#    define GL_BOOL_VEC4                        0x8B59
#    define GL_FLOAT_MAT2                       0x8B5A
#    define GL_FLOAT_MAT3                       0x8B5B
#    define GL_FLOAT_MAT4                       0x8B5C
#    define GL_SAMPLER_1D                       0x8B5D
#    define GL_SAMPLER_2D                       0x8B5E
#    define GL_SAMPLER_3D                       0x8B5F
#    define GL_SAMPLER_CUBE                     0x8B60
#    define GL_SAMPLER_1D_SHADOW                0x8B61
#    define GL_SAMPLER_2D_SHADOW                0x8B62
#    define GL_DELETE_STATUS                    0x8B80
#    define GL_COMPILE_STATUS                   0x8B81
#    define GL_LINK_STATUS                      0x8B82
#    define GL_VALIDATE_STATUS                  0x8B83
#    define GL_INFO_LOG_LENGTH                  0x8B84
#    define GL_ATTACHED_SHADERS                 0x8B85
#    define GL_ACTIVE_UNIFORMS                  0x8B86
#    define GL_ACTIVE_UNIFORM_MAX_LENGTH        0x8B87
#    define GL_SHADER_SOURCE_LENGTH             0x8B88
#    define GL_ACTIVE_ATTRIBUTES                0x8B89
#    define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH      0x8B8A
#    define GL_FRAGMENT_SHADER_DERIVATIVE_HINT  0x8B8B
#    define GL_SHADING_LANGUAGE_VERSION         0x8B8C
#    define GL_CURRENT_PROGRAM                  0x8B8D
#    define GL_POINT_SPRITE_COORD_ORIGIN        0x8CA0
#    define GL_LOWER_LEFT                       0x8CA1
#    define GL_UPPER_LEFT                       0x8CA2
#    define GL_STENCIL_BACK_REF                 0x8CA3
#    define GL_STENCIL_BACK_VALUE_MASK          0x8CA4
#    define GL_STENCIL_BACK_WRITEMASK           0x8CA5

// OpenGL Version 2.1
#    define GL_PIXEL_PACK_BUFFER           0x88EB
#    define GL_PIXEL_UNPACK_BUFFER         0x88EC
#    define GL_PIXEL_PACK_BUFFER_BINDING   0x88ED
#    define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#    define GL_FLOAT_MAT2x3                0x8B65
#    define GL_FLOAT_MAT2x4                0x8B66
#    define GL_FLOAT_MAT3x2                0x8B67
#    define GL_FLOAT_MAT3x4                0x8B68
#    define GL_FLOAT_MAT4x2                0x8B69
#    define GL_FLOAT_MAT4x3                0x8B6A
#    define GL_SRGB                        0x8C40
#    define GL_SRGB8                       0x8C41
#    define GL_SRGB_ALPHA                  0x8C42
#    define GL_SRGB8_ALPHA8                0x8C43
#    define GL_COMPRESSED_SRGB             0x8C48
#    define GL_COMPRESSED_SRGB_ALPHA       0x8C49

// OpenGL Version 3.0
#    define GL_COMPARE_REF_TO_TEXTURE                        0x884E
#    define GL_CLIP_DISTANCE0                                0x3000
#    define GL_CLIP_DISTANCE1                                0x3001
#    define GL_CLIP_DISTANCE2                                0x3002
#    define GL_CLIP_DISTANCE3                                0x3003
#    define GL_CLIP_DISTANCE4                                0x3004
#    define GL_CLIP_DISTANCE5                                0x3005
#    define GL_CLIP_DISTANCE6                                0x3006
#    define GL_CLIP_DISTANCE7                                0x3007
#    define GL_MAX_CLIP_DISTANCES                            0x0D32
#    define GL_MAJOR_VERSION                                 0x821B
#    define GL_MINOR_VERSION                                 0x821C
#    define GL_NUM_EXTENSIONS                                0x821D
#    define GL_CONTEXT_FLAGS                                 0x821E
#    define GL_COMPRESSED_RED                                0x8225
#    define GL_COMPRESSED_RG                                 0x8226
#    define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT           0x00000001
#    define GL_RGBA32F                                       0x8814
#    define GL_RGB32F                                        0x8815
#    define GL_RGBA16F                                       0x881A
#    define GL_RGB16F                                        0x881B
#    define GL_VERTEX_ATTRIB_ARRAY_INTEGER                   0x88FD
#    define GL_MAX_ARRAY_TEXTURE_LAYERS                      0x88FF
#    define GL_MIN_PROGRAM_TEXEL_OFFSET                      0x8904
#    define GL_MAX_PROGRAM_TEXEL_OFFSET                      0x8905
#    define GL_CLAMP_READ_COLOR                              0x891C
#    define GL_FIXED_ONLY                                    0x891D
#    define GL_MAX_VARYING_COMPONENTS                        0x8B4B
#    define GL_TEXTURE_1D_ARRAY                              0x8C18
#    define GL_PROXY_TEXTURE_1D_ARRAY                        0x8C19
#    define GL_TEXTURE_2D_ARRAY                              0x8C1A
#    define GL_PROXY_TEXTURE_2D_ARRAY                        0x8C1B
#    define GL_TEXTURE_BINDING_1D_ARRAY                      0x8C1C
#    define GL_TEXTURE_BINDING_2D_ARRAY                      0x8C1D
#    define GL_R11F_G11F_B10F                                0x8C3A
#    define GL_UNSIGNED_INT_10F_11F_11F_REV                  0x8C3B
#    define GL_RGB9_E5                                       0x8C3D
#    define GL_UNSIGNED_INT_5_9_9_9_REV                      0x8C3E
#    define GL_TEXTURE_SHARED_SIZE                           0x8C3F
#    define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH         0x8C76
#    define GL_TRANSFORM_FEEDBACK_BUFFER_MODE                0x8C7F
#    define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    0x8C80
#    define GL_TRANSFORM_FEEDBACK_VARYINGS                   0x8C83
#    define GL_TRANSFORM_FEEDBACK_BUFFER_START               0x8C84
#    define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE                0x8C85
#    define GL_PRIMITIVES_GENERATED                          0x8C87
#    define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         0x8C88
#    define GL_RASTERIZER_DISCARD                            0x8C89
#    define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#    define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       0x8C8B
#    define GL_INTERLEAVED_ATTRIBS                           0x8C8C
#    define GL_SEPARATE_ATTRIBS                              0x8C8D
#    define GL_TRANSFORM_FEEDBACK_BUFFER                     0x8C8E
#    define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING             0x8C8F
#    define GL_RGBA32UI                                      0x8D70
#    define GL_RGB32UI                                       0x8D71
#    define GL_RGBA16UI                                      0x8D76
#    define GL_RGB16UI                                       0x8D77
#    define GL_RGBA8UI                                       0x8D7C
#    define GL_RGB8UI                                        0x8D7D
#    define GL_RGBA32I                                       0x8D82
#    define GL_RGB32I                                        0x8D83
#    define GL_RGBA16I                                       0x8D88
#    define GL_RGB16I                                        0x8D89
#    define GL_RGBA8I                                        0x8D8E
#    define GL_RGB8I                                         0x8D8F
#    define GL_RED_INTEGER                                   0x8D94
#    define GL_GREEN_INTEGER                                 0x8D95
#    define GL_BLUE_INTEGER                                  0x8D96
#    define GL_RGB_INTEGER                                   0x8D98
#    define GL_RGBA_INTEGER                                  0x8D99
#    define GL_BGR_INTEGER                                   0x8D9A
#    define GL_BGRA_INTEGER                                  0x8D9B
#    define GL_SAMPLER_1D_ARRAY                              0x8DC0
#    define GL_SAMPLER_2D_ARRAY                              0x8DC1
#    define GL_SAMPLER_1D_ARRAY_SHADOW                       0x8DC3
#    define GL_SAMPLER_2D_ARRAY_SHADOW                       0x8DC4
#    define GL_SAMPLER_CUBE_SHADOW                           0x8DC5
#    define GL_UNSIGNED_INT_VEC2                             0x8DC6
#    define GL_UNSIGNED_INT_VEC3                             0x8DC7
#    define GL_UNSIGNED_INT_VEC4                             0x8DC8
#    define GL_INT_SAMPLER_1D                                0x8DC9
#    define GL_INT_SAMPLER_2D                                0x8DCA
#    define GL_INT_SAMPLER_3D                                0x8DCB
#    define GL_INT_SAMPLER_CUBE                              0x8DCC
#    define GL_INT_SAMPLER_1D_ARRAY                          0x8DCE
#    define GL_INT_SAMPLER_2D_ARRAY                          0x8DCF
#    define GL_UNSIGNED_INT_SAMPLER_1D                       0x8DD1
#    define GL_UNSIGNED_INT_SAMPLER_2D                       0x8DD2
#    define GL_UNSIGNED_INT_SAMPLER_3D                       0x8DD3
#    define GL_UNSIGNED_INT_SAMPLER_CUBE                     0x8DD4
#    define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY                 0x8DD6
#    define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY                 0x8DD7
#    define GL_QUERY_WAIT                                    0x8E13
#    define GL_QUERY_NO_WAIT                                 0x8E14
#    define GL_QUERY_BY_REGION_WAIT                          0x8E15
#    define GL_QUERY_BY_REGION_NO_WAIT                       0x8E16
#    define GL_BUFFER_ACCESS_FLAGS                           0x911F
#    define GL_BUFFER_MAP_LENGTH                             0x9120
#    define GL_BUFFER_MAP_OFFSET                             0x9121
#    define GL_DEPTH_COMPONENT32F                            0x8CAC
#    define GL_DEPTH32F_STENCIL8                             0x8CAD
#    define GL_FLOAT_32_UNSIGNED_INT_24_8_REV                0x8DAD
#    define GL_INVALID_FRAMEBUFFER_OPERATION                 0x0506
#    define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         0x8210
#    define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         0x8211
#    define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE               0x8212
#    define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             0x8213
#    define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              0x8214
#    define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             0x8215
#    define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             0x8216
#    define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           0x8217
#    define GL_FRAMEBUFFER_DEFAULT                           0x8218
#    define GL_FRAMEBUFFER_UNDEFINED                         0x8219
#    define GL_DEPTH_STENCIL_ATTACHMENT                      0x821A
#    define GL_MAX_RENDERBUFFER_SIZE                         0x84E8
#    define GL_DEPTH_STENCIL                                 0x84F9
#    define GL_UNSIGNED_INT_24_8                             0x84FA
#    define GL_DEPTH24_STENCIL8                              0x88F0
#    define GL_TEXTURE_STENCIL_SIZE                          0x88F1
#    define GL_TEXTURE_RED_TYPE                              0x8C10
#    define GL_TEXTURE_GREEN_TYPE                            0x8C11
#    define GL_TEXTURE_BLUE_TYPE                             0x8C12
#    define GL_TEXTURE_ALPHA_TYPE                            0x8C13
#    define GL_TEXTURE_DEPTH_TYPE                            0x8C16
#    define GL_UNSIGNED_NORMALIZED                           0x8C17
#    define GL_FRAMEBUFFER_BINDING                           0x8CA6
#    define GL_DRAW_FRAMEBUFFER_BINDING                      0x8CA6
#    define GL_RENDERBUFFER_BINDING                          0x8CA7
#    define GL_READ_FRAMEBUFFER                              0x8CA8
#    define GL_DRAW_FRAMEBUFFER                              0x8CA9
#    define GL_READ_FRAMEBUFFER_BINDING                      0x8CAA
#    define GL_RENDERBUFFER_SAMPLES                          0x8CAB
#    define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE            0x8CD0
#    define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME            0x8CD1
#    define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL          0x8CD2
#    define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE  0x8CD3
#    define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          0x8CD4
#    define GL_FRAMEBUFFER_COMPLETE                          0x8CD5
#    define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT             0x8CD6
#    define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT     0x8CD7
#    define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER            0x8CDB
#    define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER            0x8CDC
#    define GL_FRAMEBUFFER_UNSUPPORTED                       0x8CDD
#    define GL_MAX_COLOR_ATTACHMENTS                         0x8CDF
#    define GL_COLOR_ATTACHMENT0                             0x8CE0
#    define GL_COLOR_ATTACHMENT1                             0x8CE1
#    define GL_COLOR_ATTACHMENT2                             0x8CE2
#    define GL_COLOR_ATTACHMENT3                             0x8CE3
#    define GL_COLOR_ATTACHMENT4                             0x8CE4
#    define GL_COLOR_ATTACHMENT5                             0x8CE5
#    define GL_COLOR_ATTACHMENT6                             0x8CE6
#    define GL_COLOR_ATTACHMENT7                             0x8CE7
#    define GL_COLOR_ATTACHMENT8                             0x8CE8
#    define GL_COLOR_ATTACHMENT9                             0x8CE9
#    define GL_COLOR_ATTACHMENT10                            0x8CEA
#    define GL_COLOR_ATTACHMENT11                            0x8CEB
#    define GL_COLOR_ATTACHMENT12                            0x8CEC
#    define GL_COLOR_ATTACHMENT13                            0x8CED
#    define GL_COLOR_ATTACHMENT14                            0x8CEE
#    define GL_COLOR_ATTACHMENT15                            0x8CEF
#    define GL_COLOR_ATTACHMENT16                            0x8CF0
#    define GL_COLOR_ATTACHMENT17                            0x8CF1
#    define GL_COLOR_ATTACHMENT18                            0x8CF2
#    define GL_COLOR_ATTACHMENT19                            0x8CF3
#    define GL_COLOR_ATTACHMENT20                            0x8CF4
#    define GL_COLOR_ATTACHMENT21                            0x8CF5
#    define GL_COLOR_ATTACHMENT22                            0x8CF6
#    define GL_COLOR_ATTACHMENT23                            0x8CF7
#    define GL_COLOR_ATTACHMENT24                            0x8CF8
#    define GL_COLOR_ATTACHMENT25                            0x8CF9
#    define GL_COLOR_ATTACHMENT26                            0x8CFA
#    define GL_COLOR_ATTACHMENT27                            0x8CFB
#    define GL_COLOR_ATTACHMENT28                            0x8CFC
#    define GL_COLOR_ATTACHMENT29                            0x8CFD
#    define GL_COLOR_ATTACHMENT30                            0x8CFE
#    define GL_COLOR_ATTACHMENT31                            0x8CFF
#    define GL_DEPTH_ATTACHMENT                              0x8D00
#    define GL_STENCIL_ATTACHMENT                            0x8D20
#    define GL_FRAMEBUFFER                                   0x8D40
#    define GL_RENDERBUFFER                                  0x8D41
#    define GL_RENDERBUFFER_WIDTH                            0x8D42
#    define GL_RENDERBUFFER_HEIGHT                           0x8D43
#    define GL_RENDERBUFFER_INTERNAL_FORMAT                  0x8D44
#    define GL_STENCIL_INDEX1                                0x8D46
#    define GL_STENCIL_INDEX4                                0x8D47
#    define GL_STENCIL_INDEX8                                0x8D48
#    define GL_STENCIL_INDEX16                               0x8D49
#    define GL_RENDERBUFFER_RED_SIZE                         0x8D50
#    define GL_RENDERBUFFER_GREEN_SIZE                       0x8D51
#    define GL_RENDERBUFFER_BLUE_SIZE                        0x8D52
#    define GL_RENDERBUFFER_ALPHA_SIZE                       0x8D53
#    define GL_RENDERBUFFER_DEPTH_SIZE                       0x8D54
#    define GL_RENDERBUFFER_STENCIL_SIZE                     0x8D55
#    define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            0x8D56
#    define GL_MAX_SAMPLES                                   0x8D57
#    define GL_FRAMEBUFFER_SRGB                              0x8DB9
#    define GL_HALF_FLOAT                                    0x140B
#    define GL_MAP_READ_BIT                                  0x0001
#    define GL_MAP_WRITE_BIT                                 0x0002
#    define GL_MAP_INVALIDATE_RANGE_BIT                      0x0004
#    define GL_MAP_INVALIDATE_BUFFER_BIT                     0x0008
#    define GL_MAP_FLUSH_EXPLICIT_BIT                        0x0010
#    define GL_MAP_UNSYNCHRONIZED_BIT                        0x0020
#    define GL_COMPRESSED_RED_RGTC1                          0x8DBB
#    define GL_COMPRESSED_SIGNED_RED_RGTC1                   0x8DBC
#    define GL_COMPRESSED_RG_RGTC2                           0x8DBD
#    define GL_COMPRESSED_SIGNED_RG_RGTC2                    0x8DBE
#    define GL_RG                                            0x8227
#    define GL_RG_INTEGER                                    0x8228
#    define GL_R8                                            0x8229
#    define GL_R16                                           0x822A
#    define GL_RG8                                           0x822B
#    define GL_RG16                                          0x822C
#    define GL_R16F                                          0x822D
#    define GL_R32F                                          0x822E
#    define GL_RG16F                                         0x822F
#    define GL_RG32F                                         0x8230
#    define GL_R8I                                           0x8231
#    define GL_R8UI                                          0x8232
#    define GL_R16I                                          0x8233
#    define GL_R16UI                                         0x8234
#    define GL_R32I                                          0x8235
#    define GL_R32UI                                         0x8236
#    define GL_RG8I                                          0x8237
#    define GL_RG8UI                                         0x8238
#    define GL_RG16I                                         0x8239
#    define GL_RG16UI                                        0x823A
#    define GL_RG32I                                         0x823B
#    define GL_RG32UI                                        0x823C
#    define GL_VERTEX_ARRAY_BINDING                          0x85B5

// OpenGL Version 3.1
#    define GL_SAMPLER_2D_RECT                             0x8B63
#    define GL_SAMPLER_2D_RECT_SHADOW                      0x8B64
#    define GL_SAMPLER_BUFFER                              0x8DC2
#    define GL_INT_SAMPLER_2D_RECT                         0x8DCD
#    define GL_INT_SAMPLER_BUFFER                          0x8DD0
#    define GL_UNSIGNED_INT_SAMPLER_2D_RECT                0x8DD5
#    define GL_UNSIGNED_INT_SAMPLER_BUFFER                 0x8DD8
#    define GL_TEXTURE_BUFFER                              0x8C2A
#    define GL_MAX_TEXTURE_BUFFER_SIZE                     0x8C2B
#    define GL_TEXTURE_BINDING_BUFFER                      0x8C2C
#    define GL_TEXTURE_BUFFER_DATA_STORE_BINDING           0x8C2D
#    define GL_TEXTURE_RECTANGLE                           0x84F5
#    define GL_TEXTURE_BINDING_RECTANGLE                   0x84F6
#    define GL_PROXY_TEXTURE_RECTANGLE                     0x84F7
#    define GL_MAX_RECTANGLE_TEXTURE_SIZE                  0x84F8
#    define GL_R8_SNORM                                    0x8F94
#    define GL_RG8_SNORM                                   0x8F95
#    define GL_RGB8_SNORM                                  0x8F96
#    define GL_RGBA8_SNORM                                 0x8F97
#    define GL_R16_SNORM                                   0x8F98
#    define GL_RG16_SNORM                                  0x8F99
#    define GL_RGB16_SNORM                                 0x8F9A
#    define GL_RGBA16_SNORM                                0x8F9B
#    define GL_SIGNED_NORMALIZED                           0x8F9C
#    define GL_PRIMITIVE_RESTART                           0x8F9D
#    define GL_PRIMITIVE_RESTART_INDEX                     0x8F9E
#    define GL_COPY_READ_BUFFER                            0x8F36
#    define GL_COPY_WRITE_BUFFER                           0x8F37
#    define GL_UNIFORM_BUFFER                              0x8A11
#    define GL_UNIFORM_BUFFER_BINDING                      0x8A28
#    define GL_UNIFORM_BUFFER_START                        0x8A29
#    define GL_UNIFORM_BUFFER_SIZE                         0x8A2A
#    define GL_MAX_VERTEX_UNIFORM_BLOCKS                   0x8A2B
#    define GL_MAX_GEOMETRY_UNIFORM_BLOCKS                 0x8A2C
#    define GL_MAX_FRAGMENT_UNIFORM_BLOCKS                 0x8A2D
#    define GL_MAX_COMBINED_UNIFORM_BLOCKS                 0x8A2E
#    define GL_MAX_UNIFORM_BUFFER_BINDINGS                 0x8A2F
#    define GL_MAX_UNIFORM_BLOCK_SIZE                      0x8A30
#    define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS      0x8A31
#    define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS    0x8A32
#    define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS    0x8A33
#    define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT             0x8A34
#    define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH        0x8A35
#    define GL_ACTIVE_UNIFORM_BLOCKS                       0x8A36
#    define GL_UNIFORM_TYPE                                0x8A37
#    define GL_UNIFORM_SIZE                                0x8A38
#    define GL_UNIFORM_NAME_LENGTH                         0x8A39
#    define GL_UNIFORM_BLOCK_INDEX                         0x8A3A
#    define GL_UNIFORM_OFFSET                              0x8A3B
#    define GL_UNIFORM_ARRAY_STRIDE                        0x8A3C
#    define GL_UNIFORM_MATRIX_STRIDE                       0x8A3D
#    define GL_UNIFORM_IS_ROW_MAJOR                        0x8A3E
#    define GL_UNIFORM_BLOCK_BINDING                       0x8A3F
#    define GL_UNIFORM_BLOCK_DATA_SIZE                     0x8A40
#    define GL_UNIFORM_BLOCK_NAME_LENGTH                   0x8A41
#    define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS               0x8A42
#    define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES        0x8A43
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER   0x8A44
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#    define GL_INVALID_INDEX                               0xFFFFFFFFu

// OpenGL 3.2 Constants
#    define GL_CONTEXT_CORE_PROFILE_BIT                  0x00000001
#    define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT         0x00000002
#    define GL_LINES_ADJACENCY                           0x000A
#    define GL_LINE_STRIP_ADJACENCY                      0x000B
#    define GL_TRIANGLES_ADJACENCY                       0x000C
#    define GL_TRIANGLE_STRIP_ADJACENCY                  0x000D
#    define GL_PROGRAM_POINT_SIZE                        0x8642
#    define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS          0x8C29
#    define GL_FRAMEBUFFER_ATTACHMENT_LAYERED            0x8DA7
#    define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS      0x8DA8
#    define GL_GEOMETRY_SHADER                           0x8DD9
#    define GL_GEOMETRY_VERTICES_OUT                     0x8916
#    define GL_GEOMETRY_INPUT_TYPE                       0x8917
#    define GL_GEOMETRY_OUTPUT_TYPE                      0x8918
#    define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS           0x8DDF
#    define GL_MAX_GEOMETRY_OUTPUT_VERTICES              0x8DE0
#    define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS      0x8DE1
#    define GL_MAX_VERTEX_OUTPUT_COMPONENTS              0x9122
#    define GL_MAX_GEOMETRY_INPUT_COMPONENTS             0x9123
#    define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS            0x9124
#    define GL_MAX_FRAGMENT_INPUT_COMPONENTS             0x9125
#    define GL_CONTEXT_PROFILE_MASK                      0x9126
#    define GL_DEPTH_CLAMP                               0x864F
#    define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION  0x8E4C
#    define GL_FIRST_VERTEX_CONVENTION                   0x8E4D
#    define GL_LAST_VERTEX_CONVENTION                    0x8E4E
#    define GL_PROVOKING_VERTEX                          0x8E4F
#    define GL_TEXTURE_CUBE_MAP_SEAMLESS                 0x884F
#    define GL_MAX_SERVER_WAIT_TIMEOUT                   0x9111
#    define GL_OBJECT_TYPE                               0x9112
#    define GL_SYNC_CONDITION                            0x9113
#    define GL_SYNC_STATUS                               0x9114
#    define GL_SYNC_FLAGS                                0x9115
#    define GL_SYNC_FENCE                                0x9116
#    define GL_SYNC_GPU_COMMANDS_COMPLETE                0x9117
#    define GL_UNSIGNALED                                0x9118
#    define GL_SIGNALED                                  0x9119
#    define GL_ALREADY_SIGNALED                          0x911A
#    define GL_TIMEOUT_EXPIRED                           0x911B
#    define GL_CONDITION_SATISFIED                       0x911C
#    define GL_WAIT_FAILED                               0x911D
#    define GL_TIMEOUT_IGNORED                           0xFFFFFFFFFFFFFFFFull
#    define GL_SYNC_FLUSH_COMMANDS_BIT                   0x00000001
#    define GL_SAMPLE_POSITION                           0x8E50
#    define GL_SAMPLE_MASK                               0x8E51
#    define GL_SAMPLE_MASK_VALUE                         0x8E52
#    define GL_MAX_SAMPLE_MASK_WORDS                     0x8E59
#    define GL_TEXTURE_2D_MULTISAMPLE                    0x9100
#    define GL_PROXY_TEXTURE_2D_MULTISAMPLE              0x9101
#    define GL_TEXTURE_2D_MULTISAMPLE_ARRAY              0x9102
#    define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY        0x9103
#    define GL_TEXTURE_BINDING_2D_MULTISAMPLE            0x9104
#    define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY      0x9105
#    define GL_TEXTURE_SAMPLES                           0x9106
#    define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS            0x9107
#    define GL_SAMPLER_2D_MULTISAMPLE                    0x9108
#    define GL_INT_SAMPLER_2D_MULTISAMPLE                0x9109
#    define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE       0x910A
#    define GL_SAMPLER_2D_MULTISAMPLE_ARRAY              0x910B
#    define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY          0x910C
#    define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#    define GL_MAX_COLOR_TEXTURE_SAMPLES                 0x910E
#    define GL_MAX_DEPTH_TEXTURE_SAMPLES                 0x910F
#    define GL_MAX_INTEGER_SAMPLES                       0x9110

// OpenGL 3.3 Constants
#    define GL_VERTEX_ATTRIB_ARRAY_DIVISOR  0x88FE
#    define GL_SRC1_COLOR                   0x88F9
#    define GL_ONE_MINUS_SRC1_COLOR         0x88FA
#    define GL_ONE_MINUS_SRC1_ALPHA         0x88FB
#    define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#    define GL_ANY_SAMPLES_PASSED           0x8C2F
#    define GL_SAMPLER_BINDING              0x8919
#    define GL_RGB10_A2UI                   0x906F
#    define GL_TEXTURE_SWIZZLE_R            0x8E42
#    define GL_TEXTURE_SWIZZLE_G            0x8E43
#    define GL_TEXTURE_SWIZZLE_B            0x8E44
#    define GL_TEXTURE_SWIZZLE_A            0x8E45
#    define GL_TEXTURE_SWIZZLE_RGBA         0x8E46
#    define GL_TIME_ELAPSED                 0x88BF
#    define GL_TIMESTAMP                    0x8E28
#    define GL_INT_2_10_10_10_REV           0x8D9F

// OpenGL 4.0 Constants
#    define GL_SAMPLE_SHADING                                     0x8C36
#    define GL_MIN_SAMPLE_SHADING_VALUE                           0x8C37
#    define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET                  0x8E5E
#    define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET                  0x8E5F
#    define GL_TEXTURE_CUBE_MAP_ARRAY                             0x9009
#    define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY                     0x900A
#    define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY                       0x900B
#    define GL_SAMPLER_CUBE_MAP_ARRAY                             0x900C
#    define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW                      0x900D
#    define GL_INT_SAMPLER_CUBE_MAP_ARRAY                         0x900E
#    define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY                0x900F
#    define GL_DRAW_INDIRECT_BUFFER                               0x8F3F
#    define GL_DRAW_INDIRECT_BUFFER_BINDING                       0x8F43
#    define GL_GEOMETRY_SHADER_INVOCATIONS                        0x887F
#    define GL_MAX_GEOMETRY_SHADER_INVOCATIONS                    0x8E5A
#    define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET                  0x8E5B
#    define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET                  0x8E5C
#    define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS                 0x8E5D
#    define GL_MAX_VERTEX_STREAMS                                 0x8E71
#    define GL_DOUBLE_VEC2                                        0x8FFC
#    define GL_DOUBLE_VEC3                                        0x8FFD
#    define GL_DOUBLE_VEC4                                        0x8FFE
#    define GL_DOUBLE_MAT2                                        0x8F46
#    define GL_DOUBLE_MAT3                                        0x8F47
#    define GL_DOUBLE_MAT4                                        0x8F48
#    define GL_DOUBLE_MAT2x3                                      0x8F49
#    define GL_DOUBLE_MAT2x4                                      0x8F4A
#    define GL_DOUBLE_MAT3x2                                      0x8F4B
#    define GL_DOUBLE_MAT3x4                                      0x8F4C
#    define GL_DOUBLE_MAT4x2                                      0x8F4D
#    define GL_DOUBLE_MAT4x3                                      0x8F4E
#    define GL_ACTIVE_SUBROUTINES                                 0x8DE5
#    define GL_ACTIVE_SUBROUTINE_UNIFORMS                         0x8DE6
#    define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS                0x8E47
#    define GL_ACTIVE_SUBROUTINE_MAX_LENGTH                       0x8E48
#    define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH               0x8E49
#    define GL_MAX_SUBROUTINES                                    0x8DE7
#    define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS                   0x8DE8
#    define GL_NUM_COMPATIBLE_SUBROUTINES                         0x8E4A
#    define GL_COMPATIBLE_SUBROUTINES                             0x8E4B
#    define GL_PATCHES                                            0x000E
#    define GL_PATCH_VERTICES                                     0x8E72
#    define GL_PATCH_DEFAULT_INNER_LEVEL                          0x8E73
#    define GL_PATCH_DEFAULT_OUTER_LEVEL                          0x8E74
#    define GL_TESS_CONTROL_OUTPUT_VERTICES                       0x8E75
#    define GL_TESS_GEN_MODE                                      0x8E76
#    define GL_TESS_GEN_SPACING                                   0x8E77
#    define GL_TESS_GEN_VERTEX_ORDER                              0x8E78
#    define GL_TESS_GEN_POINT_MODE                                0x8E79
#    define GL_ISOLINES                                           0x8E7A
#    define GL_FRACTIONAL_ODD                                     0x8E7B
#    define GL_FRACTIONAL_EVEN                                    0x8E7C
#    define GL_MAX_PATCH_VERTICES                                 0x8E7D
#    define GL_MAX_TESS_GEN_LEVEL                                 0x8E7E
#    define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS                0x8E7F
#    define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS             0x8E80
#    define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS               0x8E81
#    define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS            0x8E82
#    define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS                 0x8E83
#    define GL_MAX_TESS_PATCH_COMPONENTS                          0x8E84
#    define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS           0x8E85
#    define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS              0x8E86
#    define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS                    0x8E89
#    define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS                 0x8E8A
#    define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS                  0x886C
#    define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS               0x886D
#    define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS       0x8E1E
#    define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS    0x8E1F
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER    0x84F0
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#    define GL_TESS_EVALUATION_SHADER                             0x8E87
#    define GL_TESS_CONTROL_SHADER                                0x8E88
#    define GL_TRANSFORM_FEEDBACK                                 0x8E22
#    define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED                   0x8E23
#    define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE                   0x8E24
#    define GL_TRANSFORM_FEEDBACK_BINDING                         0x8E25
#    define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS                     0x8E70

// OpenGL 4.1 Constants
#    define GL_FIXED                            0x140C
#    define GL_IMPLEMENTATION_COLOR_READ_TYPE   0x8B9A
#    define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#    define GL_LOW_FLOAT                        0x8DF0
#    define GL_MEDIUM_FLOAT                     0x8DF1
#    define GL_HIGH_FLOAT                       0x8DF2
#    define GL_LOW_INT                          0x8DF3
#    define GL_MEDIUM_INT                       0x8DF4
#    define GL_HIGH_INT                         0x8DF5
#    define GL_SHADER_COMPILER                  0x8DFA
#    define GL_SHADER_BINARY_FORMATS            0x8DF8
#    define GL_NUM_SHADER_BINARY_FORMATS        0x8DF9
#    define GL_MAX_VERTEX_UNIFORM_VECTORS       0x8DFB
#    define GL_MAX_VARYING_VECTORS              0x8DFC
#    define GL_MAX_FRAGMENT_UNIFORM_VECTORS     0x8DFD
#    define GL_RGB565                           0x8D62
#    define GL_PROGRAM_BINARY_RETRIEVABLE_HINT  0x8257
#    define GL_PROGRAM_BINARY_LENGTH            0x8741
#    define GL_NUM_PROGRAM_BINARY_FORMATS       0x87FE
#    define GL_PROGRAM_BINARY_FORMATS           0x87FF
#    define GL_VERTEX_SHADER_BIT                0x00000001
#    define GL_FRAGMENT_SHADER_BIT              0x00000002
#    define GL_GEOMETRY_SHADER_BIT              0x00000004
#    define GL_TESS_CONTROL_SHADER_BIT          0x00000008
#    define GL_TESS_EVALUATION_SHADER_BIT       0x00000010
#    define GL_ALL_SHADER_BITS                  0xFFFFFFFF
#    define GL_PROGRAM_SEPARABLE                0x8258
#    define GL_ACTIVE_PROGRAM                   0x8259
#    define GL_PROGRAM_PIPELINE_BINDING         0x825A
#    define GL_MAX_VIEWPORTS                    0x825B
#    define GL_VIEWPORT_SUBPIXEL_BITS           0x825C
#    define GL_VIEWPORT_BOUNDS_RANGE            0x825D
#    define GL_LAYER_PROVOKING_VERTEX           0x825E
#    define GL_VIEWPORT_INDEX_PROVOKING_VERTEX  0x825F
#    define GL_UNDEFINED_VERTEX                 0x8260

// OpenGL 4.2 Constants
#    define GL_COPY_READ_BUFFER_BINDING                                   0x8F36
#    define GL_COPY_WRITE_BUFFER_BINDING                                  0x8F37
#    define GL_TRANSFORM_FEEDBACK_ACTIVE                                  0x8E24
#    define GL_TRANSFORM_FEEDBACK_PAUSED                                  0x8E23
#    define GL_UNPACK_COMPRESSED_BLOCK_WIDTH                              0x9127
#    define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT                             0x9128
#    define GL_UNPACK_COMPRESSED_BLOCK_DEPTH                              0x9129
#    define GL_UNPACK_COMPRESSED_BLOCK_SIZE                               0x912A
#    define GL_PACK_COMPRESSED_BLOCK_WIDTH                                0x912B
#    define GL_PACK_COMPRESSED_BLOCK_HEIGHT                               0x912C
#    define GL_PACK_COMPRESSED_BLOCK_DEPTH                                0x912D
#    define GL_PACK_COMPRESSED_BLOCK_SIZE                                 0x912E
#    define GL_NUM_SAMPLE_COUNTS                                          0x9380
#    define GL_MIN_MAP_BUFFER_ALIGNMENT                                   0x90BC
#    define GL_ATOMIC_COUNTER_BUFFER                                      0x92C0
#    define GL_ATOMIC_COUNTER_BUFFER_BINDING                              0x92C1
#    define GL_ATOMIC_COUNTER_BUFFER_START                                0x92C2
#    define GL_ATOMIC_COUNTER_BUFFER_SIZE                                 0x92C3
#    define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE                            0x92C4
#    define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS               0x92C5
#    define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES        0x92C6
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER          0x92C7
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER    0x92C8
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER        0x92CA
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER        0x92CB
#    define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS                          0x92CC
#    define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS                    0x92CD
#    define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS                 0x92CE
#    define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS                        0x92CF
#    define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS                        0x92D0
#    define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS                        0x92D1
#    define GL_MAX_VERTEX_ATOMIC_COUNTERS                                 0x92D2
#    define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS                           0x92D3
#    define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS                        0x92D4
#    define GL_MAX_GEOMETRY_ATOMIC_COUNTERS                               0x92D5
#    define GL_MAX_FRAGMENT_ATOMIC_COUNTERS                               0x92D6
#    define GL_MAX_COMBINED_ATOMIC_COUNTERS                               0x92D7
#    define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE                             0x92D8
#    define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS                         0x92DC
#    define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS                              0x92D9
#    define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX                        0x92DA
#    define GL_UNSIGNED_INT_ATOMIC_COUNTER                                0x92DB
#    define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT                            0x00000001
#    define GL_ELEMENT_ARRAY_BARRIER_BIT                                  0x00000002
#    define GL_UNIFORM_BARRIER_BIT                                        0x00000004
#    define GL_TEXTURE_FETCH_BARRIER_BIT                                  0x00000008
#    define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT                            0x00000020
#    define GL_COMMAND_BARRIER_BIT                                        0x00000040
#    define GL_PIXEL_BUFFER_BARRIER_BIT                                   0x00000080
#    define GL_TEXTURE_UPDATE_BARRIER_BIT                                 0x00000100
#    define GL_BUFFER_UPDATE_BARRIER_BIT                                  0x00000200
#    define GL_FRAMEBUFFER_BARRIER_BIT                                    0x00000400
#    define GL_TRANSFORM_FEEDBACK_BARRIER_BIT                             0x00000800
#    define GL_ATOMIC_COUNTER_BARRIER_BIT                                 0x00001000
#    define GL_ALL_BARRIER_BITS                                           0xFFFFFFFF
#    define GL_MAX_IMAGE_UNITS                                            0x8F38
#    define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS              0x8F39
#    define GL_IMAGE_BINDING_NAME                                         0x8F3A
#    define GL_IMAGE_BINDING_LEVEL                                        0x8F3B
#    define GL_IMAGE_BINDING_LAYERED                                      0x8F3C
#    define GL_IMAGE_BINDING_LAYER                                        0x8F3D
#    define GL_IMAGE_BINDING_ACCESS                                       0x8F3E
#    define GL_IMAGE_1D                                                   0x904C
#    define GL_IMAGE_2D                                                   0x904D
#    define GL_IMAGE_3D                                                   0x904E
#    define GL_IMAGE_2D_RECT                                              0x904F
#    define GL_IMAGE_CUBE                                                 0x9050
#    define GL_IMAGE_BUFFER                                               0x9051
#    define GL_IMAGE_1D_ARRAY                                             0x9052
#    define GL_IMAGE_2D_ARRAY                                             0x9053
#    define GL_IMAGE_CUBE_MAP_ARRAY                                       0x9054
#    define GL_IMAGE_2D_MULTISAMPLE                                       0x9055
#    define GL_IMAGE_2D_MULTISAMPLE_ARRAY                                 0x9056
#    define GL_INT_IMAGE_1D                                               0x9057
#    define GL_INT_IMAGE_2D                                               0x9058
#    define GL_INT_IMAGE_3D                                               0x9059
#    define GL_INT_IMAGE_2D_RECT                                          0x905A
#    define GL_INT_IMAGE_CUBE                                             0x905B
#    define GL_INT_IMAGE_BUFFER                                           0x905C
#    define GL_INT_IMAGE_1D_ARRAY                                         0x905D
#    define GL_INT_IMAGE_2D_ARRAY                                         0x905E
#    define GL_INT_IMAGE_CUBE_MAP_ARRAY                                   0x905F
#    define GL_INT_IMAGE_2D_MULTISAMPLE                                   0x9060
#    define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY                             0x9061
#    define GL_UNSIGNED_INT_IMAGE_1D                                      0x9062
#    define GL_UNSIGNED_INT_IMAGE_2D                                      0x9063
#    define GL_UNSIGNED_INT_IMAGE_3D                                      0x9064
#    define GL_UNSIGNED_INT_IMAGE_2D_RECT                                 0x9065
#    define GL_UNSIGNED_INT_IMAGE_CUBE                                    0x9066
#    define GL_UNSIGNED_INT_IMAGE_BUFFER                                  0x9067
#    define GL_UNSIGNED_INT_IMAGE_1D_ARRAY                                0x9068
#    define GL_UNSIGNED_INT_IMAGE_2D_ARRAY                                0x9069
#    define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY                          0x906A
#    define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE                          0x906B
#    define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY                    0x906C
#    define GL_MAX_IMAGE_SAMPLES                                          0x906D
#    define GL_IMAGE_BINDING_FORMAT                                       0x906E
#    define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE                            0x90C7
#    define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE                         0x90C8
#    define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS                        0x90C9
#    define GL_MAX_VERTEX_IMAGE_UNIFORMS                                  0x90CA
#    define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS                            0x90CB
#    define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS                         0x90CC
#    define GL_MAX_GEOMETRY_IMAGE_UNIFORMS                                0x90CD
#    define GL_MAX_FRAGMENT_IMAGE_UNIFORMS                                0x90CE
#    define GL_MAX_COMBINED_IMAGE_UNIFORMS                                0x90CF
#    define GL_COMPRESSED_RGBA_BPTC_UNORM                                 0x8E8C
#    define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM                           0x8E8D
#    define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT                           0x8E8E
#    define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT                         0x8E8F
#    define GL_TEXTURE_IMMUTABLE_FORMAT                                   0x912F

// OpenGL 4.3 Constants
#    define GL_NUM_SHADING_LANGUAGE_VERSIONS                      0x82E9
#    define GL_VERTEX_ATTRIB_ARRAY_LONG                           0x874E
#    define GL_COMPRESSED_RGB8_ETC2                               0x9274
#    define GL_COMPRESSED_SRGB8_ETC2                              0x9275
#    define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2           0x9276
#    define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2          0x9277
#    define GL_COMPRESSED_RGBA8_ETC2_EAC                          0x9278
#    define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC                   0x9279
#    define GL_COMPRESSED_R11_EAC                                 0x9270
#    define GL_COMPRESSED_SIGNED_R11_EAC                          0x9271
#    define GL_COMPRESSED_RG11_EAC                                0x9272
#    define GL_COMPRESSED_SIGNED_RG11_EAC                         0x9273
#    define GL_PRIMITIVE_RESTART_FIXED_INDEX                      0x8D69
#    define GL_ANY_SAMPLES_PASSED_CONSERVATIVE                    0x8D6A
#    define GL_MAX_ELEMENT_INDEX                                  0x8D6B
#    define GL_COMPUTE_SHADER                                     0x91B9
#    define GL_MAX_COMPUTE_UNIFORM_BLOCKS                         0x91BB
#    define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS                    0x91BC
#    define GL_MAX_COMPUTE_IMAGE_UNIFORMS                         0x91BD
#    define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE                     0x8262
#    define GL_MAX_COMPUTE_UNIFORM_COMPONENTS                     0x8263
#    define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS                 0x8264
#    define GL_MAX_COMPUTE_ATOMIC_COUNTERS                        0x8265
#    define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS            0x8266
#    define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS                 0x90EB
#    define GL_MAX_COMPUTE_WORK_GROUP_COUNT                       0x91BE
#    define GL_MAX_COMPUTE_WORK_GROUP_SIZE                        0x91BF
#    define GL_COMPUTE_WORK_GROUP_SIZE                            0x8267
#    define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER         0x90EC
#    define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#    define GL_DISPATCH_INDIRECT_BUFFER                           0x90EE
#    define GL_DISPATCH_INDIRECT_BUFFER_BINDING                   0x90EF
#    define GL_COMPUTE_SHADER_BIT                                 0x00000020
#    define GL_DEBUG_OUTPUT_SYNCHRONOUS                           0x8242
#    define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH                   0x8243
#    define GL_DEBUG_CALLBACK_FUNCTION                            0x8244
#    define GL_DEBUG_CALLBACK_USER_PARAM                          0x8245
#    define GL_DEBUG_SOURCE_API                                   0x8246
#    define GL_DEBUG_SOURCE_WINDOW_SYSTEM                         0x8247
#    define GL_DEBUG_SOURCE_SHADER_COMPILER                       0x8248
#    define GL_DEBUG_SOURCE_THIRD_PARTY                           0x8249
#    define GL_DEBUG_SOURCE_APPLICATION                           0x824A
#    define GL_DEBUG_SOURCE_OTHER                                 0x824B
#    define GL_DEBUG_TYPE_ERROR                                   0x824C
#    define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR                     0x824D
#    define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR                      0x824E
#    define GL_DEBUG_TYPE_PORTABILITY                             0x824F
#    define GL_DEBUG_TYPE_PERFORMANCE                             0x8250
#    define GL_DEBUG_TYPE_OTHER                                   0x8251
#    define GL_MAX_DEBUG_MESSAGE_LENGTH                           0x9143
#    define GL_MAX_DEBUG_LOGGED_MESSAGES                          0x9144
#    define GL_DEBUG_LOGGED_MESSAGES                              0x9145
#    define GL_DEBUG_SEVERITY_HIGH                                0x9146
#    define GL_DEBUG_SEVERITY_MEDIUM                              0x9147
#    define GL_DEBUG_SEVERITY_LOW                                 0x9148
#    define GL_DEBUG_TYPE_MARKER                                  0x8268
#    define GL_DEBUG_TYPE_PUSH_GROUP                              0x8269
#    define GL_DEBUG_TYPE_POP_GROUP                               0x826A
#    define GL_DEBUG_SEVERITY_NOTIFICATION                        0x826B
#    define GL_MAX_DEBUG_GROUP_STACK_DEPTH                        0x826C
#    define GL_DEBUG_GROUP_STACK_DEPTH                            0x826D
#    define GL_BUFFER                                             0x82E0
#    define GL_SHADER                                             0x82E1
#    define GL_PROGRAM                                            0x82E2
#    define GL_QUERY                                              0x82E3
#    define GL_PROGRAM_PIPELINE                                   0x82E4
#    define GL_SAMPLER                                            0x82E6
#    define GL_MAX_LABEL_LENGTH                                   0x82E8
#    define GL_DEBUG_OUTPUT                                       0x92E0
#    define GL_CONTEXT_FLAG_DEBUG_BIT                             0x00000002
#    define GL_MAX_UNIFORM_LOCATIONS                              0x826E
#    define GL_FRAMEBUFFER_DEFAULT_WIDTH                          0x9310
#    define GL_FRAMEBUFFER_DEFAULT_HEIGHT                         0x9311
#    define GL_FRAMEBUFFER_DEFAULT_LAYERS                         0x9312
#    define GL_FRAMEBUFFER_DEFAULT_SAMPLES                        0x9313
#    define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS         0x9314
#    define GL_MAX_FRAMEBUFFER_WIDTH                              0x9315
#    define GL_MAX_FRAMEBUFFER_HEIGHT                             0x9316
#    define GL_MAX_FRAMEBUFFER_LAYERS                             0x9317
#    define GL_MAX_FRAMEBUFFER_SAMPLES                            0x9318
#    define GL_SHADER_STORAGE_BUFFER                              0x90D2
#    define GL_SHADER_STORAGE_BUFFER_BINDING                      0x90D3
#    define GL_SHADER_STORAGE_BUFFER_START                        0x90D4
#    define GL_SHADER_STORAGE_BUFFER_SIZE                         0x90D5
#    define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS                   0x90D6
#    define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS                 0x90D7
#    define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS             0x90D8
#    define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS          0x90D9
#    define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS                 0x90DA
#    define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS                  0x90DB
#    define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS                 0x90DC
#    define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS                 0x90DD
#    define GL_MAX_SHADER_STORAGE_BLOCK_SIZE                      0x90DE
#    define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT             0x90DF
#    define GL_SHADER_STORAGE_BARRIER_BIT                         0x00002000
#    define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES               0x8F39
#    define GL_DEPTH_STENCIL_TEXTURE_MODE                         0x90EA
#    define GL_TEXTURE_BUFFER_OFFSET                              0x919D
#    define GL_TEXTURE_BUFFER_SIZE                                0x919E
#    define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT                    0x919F
#    define GL_TEXTURE_VIEW_MIN_LEVEL                             0x82DB
#    define GL_TEXTURE_VIEW_NUM_LEVELS                            0x82DC
#    define GL_TEXTURE_VIEW_MIN_LAYER                             0x82DD
#    define GL_TEXTURE_VIEW_NUM_LAYERS                            0x82DE
#    define GL_TEXTURE_IMMUTABLE_LEVELS                           0x82DF
#    define GL_VERTEX_ATTRIB_BINDING                              0x82D4
#    define GL_VERTEX_ATTRIB_RELATIVE_OFFSET                      0x82D5
#    define GL_VERTEX_BINDING_DIVISOR                             0x82D6
#    define GL_VERTEX_BINDING_OFFSET                              0x82D7
#    define GL_VERTEX_BINDING_STRIDE                              0x82D8
#    define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET                  0x82D9
#    define GL_MAX_VERTEX_ATTRIB_BINDINGS                         0x82DA
#    define GL_VERTEX_BINDING_BUFFER                              0x8F4F

// OpenGL 4.4 Constants
#    define GL_MAX_VERTEX_ATTRIB_STRIDE                0x82E5
#    define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#    define GL_TEXTURE_BUFFER_BINDING                  0x8C2A
#    define GL_MAP_PERSISTENT_BIT                      0x0040
#    define GL_MAP_COHERENT_BIT                        0x0080
#    define GL_DYNAMIC_STORAGE_BIT                     0x0100
#    define GL_CLIENT_STORAGE_BIT                      0x0200
#    define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT        0x00004000
#    define GL_BUFFER_IMMUTABLE_STORAGE                0x821F
#    define GL_BUFFER_STORAGE_FLAGS                    0x8220
#    define GL_CLEAR_TEXTURE                           0x9365
#    define GL_LOCATION_COMPONENT                      0x934A
#    define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX         0x934B
#    define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE        0x934C
#    define GL_QUERY_BUFFER                            0x9192
#    define GL_QUERY_BUFFER_BARRIER_BIT                0x00008000
#    define GL_QUERY_BUFFER_BINDING                    0x9193
#    define GL_QUERY_RESULT_NO_WAIT                    0x9194
#    define GL_MIRROR_CLAMP_TO_EDGE                    0x8743

// OpenGL 4.5 Constants
#    define GL_CONTEXT_LOST                         0x0507
#    define GL_NEGATIVE_ONE_TO_ONE                  0x935E
#    define GL_ZERO_TO_ONE                          0x935F
#    define GL_CLIP_ORIGIN                          0x935C
#    define GL_CLIP_DEPTH_MODE                      0x935D
#    define GL_QUERY_WAIT_INVERTED                  0x8E17
#    define GL_QUERY_NO_WAIT_INVERTED               0x8E18
#    define GL_QUERY_BY_REGION_WAIT_INVERTED        0x8E19
#    define GL_QUERY_BY_REGION_NO_WAIT_INVERTED     0x8E1A
#    define GL_MAX_CULL_DISTANCES                   0x82F9
#    define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#    define GL_TEXTURE_TARGET                       0x1006
#    define GL_QUERY_TARGET                         0x82EA
#    define GL_GUILTY_CONTEXT_RESET                 0x8253
#    define GL_INNOCENT_CONTEXT_RESET               0x8254
#    define GL_UNKNOWN_CONTEXT_RESET                0x8255
#    define GL_RESET_NOTIFICATION_STRATEGY          0x8256
#    define GL_LOSE_CONTEXT_ON_RESET                0x8252
#    define GL_NO_RESET_NOTIFICATION                0x8261
#    define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT       0x00000004
#    define GL_CONTEXT_RELEASE_BEHAVIOR             0x82FB
#    define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH       0x82FC

// OpenGL 4.6 Constants
#    define GL_SHADER_BINARY_FORMAT_SPIR_V        0x9551
#    define GL_SPIR_V_BINARY                      0x9552
#    define GL_PARAMETER_BUFFER                   0x80EE
#    define GL_PARAMETER_BUFFER_BINDING           0x80EF
#    define GL_CONTEXT_FLAG_NO_ERROR_BIT          0x00000008
#    define GL_VERTICES_SUBMITTED                 0x82EE
#    define GL_PRIMITIVES_SUBMITTED               0x82EF
#    define GL_VERTEX_SHADER_INVOCATIONS          0x82F0
#    define GL_TESS_CONTROL_SHADER_PATCHES        0x82F1
#    define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#    define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#    define GL_FRAGMENT_SHADER_INVOCATIONS        0x82F4
#    define GL_COMPUTE_SHADER_INVOCATIONS         0x82F5
#    define GL_CLIPPING_INPUT_PRIMITIVES          0x82F6
#    define GL_CLIPPING_OUTPUT_PRIMITIVES         0x82F7
#    define GL_POLYGON_OFFSET_CLAMP               0x8E1B
#    define GL_SPIR_V_EXTENSIONS                  0x9553
#    define GL_NUM_SPIR_V_EXTENSIONS              0x9554
#    define GL_TEXTURE_MAX_ANISOTROPY             0x84FE
#    define GL_MAX_TEXTURE_MAX_ANISOTROPY         0x84FF
#    define GL_TRANSFORM_FEEDBACK_OVERFLOW        0x82EC
#    define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED

#endif // GL_DEPTH_BUFFER_BIT



================================================
FILE: source/OpenGL/GLTypes.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include <cstddef> // for ptrdiff_t
#include <cstdint> // for fixed-width integer types

// OpenGL Type Definitions using precise fixed-width types
typedef uint32_t         GLenum;     // OpenGL enumeration values
typedef uint32_t         GLbitfield; // OpenGL bitfield values
typedef uint32_t         GLuint;     // Unsigned 32-bit integer
typedef int32_t          GLint;      // Signed 32-bit integer
typedef int32_t          GLsizei;    // Non-negative size values
typedef uint8_t          GLboolean;  // Boolean values (0 or 1)
typedef int8_t           GLbyte;     // Signed 8-bit integer
typedef int16_t          GLshort;    // Signed 16-bit integer
typedef uint8_t          GLubyte;    // Unsigned 8-bit integer
typedef uint16_t         GLushort;   // Unsigned 16-bit integer
typedef unsigned long    GLulong;    // Unsigned 64-bit integer
typedef float            GLfloat;    // 32-bit floating point
typedef float            GLclampf;   // Clamped 32-bit floating point
typedef double           GLdouble;   // 64-bit floating point
typedef double           GLclampd;   // Clamped 64-bit floating point
typedef void             GLvoid;     // Void type
typedef char             GLchar;     // Character type
typedef ptrdiff_t        GLintptr;   // Pointer-sized signed integer
typedef ptrdiff_t        GLsizeiptr; // Pointer-sized size value
typedef int64_t          GLint64;    // Signed 64-bit integer
typedef uint64_t         GLuint64;   // Unsigned 64-bit integer
typedef struct __GLsync* GLsync;     // Sync object pointer


#if not defined(APIENTRY)
#    if defined(__MINGW32__) || defined(__CYGWIN__) || (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__)
#        define APIENTRY __stdcall
#    else
#        define APIENTRY
#    endif
#endif

typedef void(APIENTRY* DEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);



================================================
FILE: source/OpenGL/Handle.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */

#pragma once
#include "GLTypes.h"

namespace OpenGL
{
    // OpenGL uses GLuint for handles
    using Handle = GLuint;
}



================================================
FILE: source/OpenGL/Shader.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Shader.h"

#include "Engine/Engine.h"
#include "Engine/Logger.h"
#include "Engine/Path.h"
#include "GL.h"
#include <algorithm>

namespace
{
    void                                                 print_glsl_text(std::string_view source);
    [[nodiscard]] OpenGL::Handle                         compile_shader_source(GLenum type, std::string_view glsl_text);
    [[nodiscard]] OpenGL::Handle                         compile_shader_file(GLenum type, const std::filesystem::path& file_path);
    [[nodiscard]] OpenGL::ShaderHandle                   link_shader_program(OpenGL::Handle vertex_handle, OpenGL::Handle fragment_handle);
    [[nodiscard]] std::unordered_map<std::string, GLint> get_uniform_locations(OpenGL::ShaderHandle shader);
}

namespace OpenGL
{
    CompiledShader CreateShader(std::filesystem::path vertex_filepath, std::filesystem::path fragment_filepath)
    {
        const auto     vertex_handle   = compile_shader_file(GL_VERTEX_SHADER, vertex_filepath);
        const auto     fragment_handle = compile_shader_file(GL_FRAGMENT_SHADER, fragment_filepath);
        CompiledShader cs{};
        cs.Shader           = link_shader_program(vertex_handle, fragment_handle);
        cs.UniformLocations = get_uniform_locations(cs.Shader);
        return cs;
    }

    CompiledShader CreateShader(std::string_view vertex_source, std::string_view fragment_source)
    {
        const auto     vertex_handle   = compile_shader_source(GL_VERTEX_SHADER, vertex_source);
        const auto     fragment_handle = compile_shader_source(GL_FRAGMENT_SHADER, fragment_source);
        CompiledShader cs{};
        cs.Shader           = link_shader_program(vertex_handle, fragment_handle);
        cs.UniformLocations = get_uniform_locations(cs.Shader);
        return cs;
    }

    void DestroyShader(CompiledShader& shader) noexcept
    {
        GL::DeleteProgram(shader.Shader);
        shader.Shader = 0;

        shader.UniformLocations.clear();
    }

    void BindUniformBufferToShader(ShaderHandle shader_handle, GLuint binding_number, Handle uniform_bufer, std::string_view uniform_block_name)
    {
        const auto block_index = GL::GetUniformBlockIndex(shader_handle, uniform_block_name.data());
        if (block_index != GL_INVALID_INDEX)
        {
            GL::UniformBlockBinding(shader_handle, block_index, binding_number);
            GL::BindBufferBase(GL_UNIFORM_BUFFER, binding_number, uniform_bufer);
        }
        else
        {
            Engine::GetLogger().LogError("Uniform block '" + std::string(uniform_block_name) + "' not found in shader.");
        }
    }
}

namespace
{
    void print_glsl_text(std::string_view source)
    {
        using CountInt                          = decltype(std::count(source.begin(), source.end(), '\n'));
        CountInt           num_lines            = std::count(source.begin(), source.end(), '\n');
        const int          max_linenumber_width = static_cast<int>(std::to_string(num_lines).size());
        CountInt           line_number          = 1;
        std::string        line;
        std::ostringstream sout;
        std::istringstream source_stream(source.data());
        while (std::getline(source_stream, line))
        {
            sout << std::setw(max_linenumber_width) << std::right << line_number << "| " << line << '\n';
            ++line_number;
        }
        Engine::GetLogger().LogVerbose(sout.str());
    }

    OpenGL::Handle compile_shader_source(GLenum type, std::string_view glsl_text)
    {
        OpenGL::Handle shader = GL::CreateShader(type);
        GLchar const*  source[]{ glsl_text.data() };
        GL::ShaderSource(shader, 1, source, nullptr);
        GL::CompileShader(shader);
        GLint is_compiled = 0;
        GL::GetShaderiv(shader, GL_COMPILE_STATUS, &is_compiled);
        if (is_compiled == GL_FALSE)
        {
            GLint log_length = 0;
            GL::GetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
            std::string error_log;
            error_log.resize(static_cast<std::string::size_type>(log_length) + 1);
            GL::GetShaderInfoLog(shader, log_length, nullptr, error_log.data());
            GL::DeleteShader(shader);
            shader = 0;
            Engine::GetLogger().LogError(error_log);
            print_glsl_text(glsl_text);
            throw std::runtime_error(error_log);
        }
        return shader;
    }

    OpenGL::Handle compile_shader_file(GLenum type, const std::filesystem::path& file_path)
    {
        const auto    shader_file_path = assets::locate_asset(file_path);
        std::ifstream ifs(shader_file_path, std::ios::in);
        if (!ifs)
        {
            Engine::GetLogger().LogError("Cannot open " + file_path.string());
            return 0;
        }
        std::string glsl_text;
        glsl_text.reserve(gsl::narrow<std::size_t>(std::filesystem::file_size(shader_file_path)));
        std::copy((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>(), std::back_insert_iterator(glsl_text));
        return compile_shader_source(type, std::string_view(glsl_text));
    }

    OpenGL::ShaderHandle link_shader_program(OpenGL::Handle vertex_handle, OpenGL::Handle fragment_handle)
    {
        OpenGL::ShaderHandle program_handle = GL::CreateProgram();
        if (program_handle == 0)
        {
            throw std::runtime_error("Unable to create program\n");
        }

        GL::AttachShader(program_handle, vertex_handle);
        GL::AttachShader(program_handle, fragment_handle);

        GL::LinkProgram(program_handle);

        GL::DeleteShader(vertex_handle);
        GL::DeleteShader(fragment_handle);

        GLint is_linked = 0;
        GL::GetProgramiv(program_handle, GL_LINK_STATUS, &is_linked);
        if (is_linked == GL_FALSE)
        {
            GLint log_length = 0;
            GL::GetProgramiv(program_handle, GL_INFO_LOG_LENGTH, &log_length);
            std::string error;
            error.resize(static_cast<unsigned>(log_length) + 1);
            GL::GetProgramInfoLog(program_handle, log_length, nullptr, error.data());
            Engine::GetLogger().LogError(error);
            throw std::runtime_error(error);
        }
        return program_handle;
    }

    std::unordered_map<std::string, GLint> get_uniform_locations(OpenGL::ShaderHandle shader)
    {
        std::unordered_map<std::string, GLint> uniform_locations;
        GLint                                  num_uniforms = 0;
        GL::GetProgramiv(shader, GL_ACTIVE_UNIFORMS, &num_uniforms);
        if (num_uniforms <= 0)
        {
            return uniform_locations;
        }
        GLint max_name_length = 0;
        GL::GetProgramiv(shader, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max_name_length);
        uniform_locations.reserve(static_cast<std::size_t>(num_uniforms));
        std::string uniform_name;
        uniform_name.resize(static_cast<std::size_t>(max_name_length));

        for (GLint i = 0; i < num_uniforms; ++i)
        {
            GLsizei length = 0;
            GLint   size   = 0;
            GLenum  type   = 0;
            GL::GetActiveUniform(shader, static_cast<GLuint>(i), max_name_length, &length, &size, &type, uniform_name.data());
            uniform_name.resize(static_cast<std::size_t>(length));
            GLint location = GL::GetUniformLocation(shader, uniform_name.c_str());
            if (location != -1)
            {
                uniform_locations[uniform_name] = location;
            }
            uniform_name.resize(static_cast<std::size_t>(max_name_length));
        }
        return uniform_locations;
    }
}



================================================
FILE: source/OpenGL/Shader.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Handle.h"
#include <filesystem>
#include <string>
#include <string_view>
#include <unordered_map>
#include <utility>

namespace OpenGL
{
    /**
     * \brief Descriptive alias for OpenGL shader program handles
     *
     * ShaderHandle provides a more specific and readable name for the generic
     * OpenGL handle type when referring to compiled shader programs. This improves
     * code clarity without adding compile-time type safety.
     */
    using ShaderHandle = Handle;

    /**
     * \brief Complete shader program with uniform location cache for efficient rendering
     *
     * CompiledShader represents a fully compiled and linked OpenGL shader program
     * that's ready for use in rendering operations. This struct bundles the shader
     * program handle with a pre-computed cache of uniform locations, eliminating
     * the need for expensive uniform location lookups during rendering.
     *
     * Purpose and Benefits:
     * - Encapsulates the complete shader compilation and linking process
     * - Provides efficient uniform access through cached locations
     * - Simplifies shader resource management
     * - Reduces runtime overhead by avoiding repeated OpenGL queries
     *
     * The uniform location cache is particularly important for performance, as
     * calling GL::GetUniformLocation() during rendering can be expensive. By
     * pre-computing and storing these locations, uniform updates become much
     * faster during the render loop.
     *
     * Typical shader workflow:
     * 1. Create shader from vertex and fragment sources
     * 2. Use cached uniform locations for fast parameter updates
     * 3. Bind shader program for rendering operations
     * 4. Destroy shader when no longer needed
     *
     * Resource management:
     * Both the shader program and uniform location cache should be properly
     * cleaned up when the shader is no longer needed to prevent resource leaks.
     */
    struct [[nodiscard]] CompiledShader
    {
        /** \brief Handle to the compiled and linked OpenGL shader program */
        ShaderHandle Shader;

        /** \brief Cache of uniform names mapped to their OpenGL locations for fast access */
        std::unordered_map<std::string, GLint> UniformLocations;
    };

    /**
     * \brief Create shader program from vertex and fragment shader files
     * \param vertex_filepath Path to the vertex shader source file (.vert)
     * \param fragment_filepath Path to the fragment shader source file (.frag)
     * \return Fully compiled shader program with cached uniform locations
     *
     * Loads, compiles, and links a complete shader program from separate vertex
     * and fragment shader files. This is the standard approach for shader
     * development, allowing separate editing and version control of vertex
     * and fragment shader code.
     *
     * The compilation process includes:
     * - Loading shader source code from the specified files
     * - Compiling vertex and fragment shaders separately
     * - Linking both shaders into a complete program
     * - Extracting and caching all uniform locations for fast access
     * - Cleaning up intermediate shader objects
     *
     * Error handling and debugging:
     * If compilation or linking fails, detailed error messages are logged with
     * line numbers to help identify the problematic shader code. The function
     * throws exceptions for compilation errors, making shader loading failures
     * immediately apparent.
     *
     * File organization patterns:
     * - Vertex shaders typically have .vert extension
     * - Fragment shaders typically have .frag extension
     * - Shaders are located through the asset system for proper path resolution
     *
     * This approach is ideal for production code where shaders are stored as
     * separate files and can be modified without recompiling the application.
     */
    CompiledShader CreateShader(std::filesystem::path vertex_filepath, std::filesystem::path fragment_filepath);

    /**
     * \brief Create shader program from vertex and fragment shader source strings
     * \param vertex_source Complete GLSL source code for the vertex shader
     * \param fragment_source Complete GLSL source code for the fragment shader
     * \return Fully compiled shader program with cached uniform locations
     *
     * Compiles and links a complete shader program directly from source code
     * strings. This approach is useful for programmatically generated shaders,
     * embedded shader code, or when shader sources are loaded through custom
     * mechanisms rather than direct file access.
     *
     * The compilation process mirrors the file-based version:
     * - Compiling vertex and fragment shaders from provided strings
     * - Linking both shaders into a complete program
     * - Extracting and caching all uniform locations
     * - Proper cleanup of intermediate resources
     *
     * Use cases:
     * - Procedurally generated shaders with variable content
     * - Embedded shaders compiled into the executable
     * - Shader templates with runtime string substitution
     * - Loading shaders from compressed archives or custom formats
     * - Shader preprocessing and macro expansion
     *
     * Error handling:
     * Like the file-based version, compilation errors result in detailed logging
     * with line numbers and exception throwing for immediate failure detection.
     *
     * This approach provides maximum flexibility for dynamic shader generation
     * while maintaining the same performance characteristics as file-based shaders.
     */
    CompiledShader CreateShader(std::string_view vertex_source, std::string_view fragment_source);

    /**
     * \brief Safely destroy shader program and release all associated resources
     * \param shader Compiled shader structure to destroy (will be reset to safe state)
     *
     * Properly cleans up the OpenGL shader program and clears the uniform location
     * cache, preventing resource leaks and ensuring the structure is in a safe
     * state for reuse or destruction.
     *
     * Resource cleanup includes:
     * - Deleting the OpenGL shader program object
     * - Clearing the uniform location cache
     * - Resetting the shader handle to zero for safety
     *
     * The function is designed to be safe for multiple calls on the same shader
     * structure, as it resets handles after deletion. This prevents double-deletion
     * errors and makes the function suitable for use in destructors or cleanup code.
     *
     * Usage patterns:
     * - Call when shader is no longer needed
     * - Include in application shutdown sequences
     * - Use in RAII wrapper destructors for automatic cleanup
     * - Call before reassigning shader variables
     *
     * After calling this function, the shader structure should not be used for
     * rendering operations until a new shader program is created and assigned.
     */
    void DestroyShader(CompiledShader& shader) noexcept;

    /**
     * \brief Bind uniform buffer to shader's uniform block for shared data access
     * \param shader_handle Handle to the shader program
     * \param binding_number Binding point index for the uniform buffer
     * \param uniform_bufer Handle to the uniform buffer object
     * \param uniform_block_name Name of the uniform block in the shader
     *
     * Establishes a connection between a uniform buffer object and a named uniform
     * block in the shader program. This enables efficient sharing of uniform data
     * across multiple shader programs and reduces the overhead of individual
     * uniform updates.
     *
     * Uniform buffer benefits:
     * - Share common data (matrices, lighting parameters) across multiple shaders
     * - Reduce driver overhead compared to individual uniform calls
     * - Enable more efficient uniform updates for large data sets
     * - Provide better organization of related uniform variables
     *
     * The binding process:
     * - Locates the named uniform block within the shader program
     * - Assigns the block to the specified binding point
     * - Binds the uniform buffer to the same binding point
     * - Logs errors if the uniform block is not found
     *
     * Common uniform block uses:
     * - Camera matrices (view, projection, view-projection)
     * - Lighting parameters (light positions, colors, attenuation)
     * - Material properties shared across multiple objects
     * - Time-based values for animations and effects
     *
     * The binding number should be consistent across all shaders that need to
     * access the same uniform buffer data, enabling true data sharing.
     */
    void BindUniformBufferToShader(ShaderHandle shader_handle, GLuint binding_number, Handle uniform_bufer, std::string_view uniform_block_name);
}



================================================
FILE: source/OpenGL/Texture.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Texture.h"
#include "CS200/Image.h"
#include "Environment.h"
#include "GL.h"

namespace OpenGL
{
    TextureHandle CreateTextureFromImage(const CS200::Image& image, Filtering filtering, Wrapping wrapping) noexcept
    {
        Math::ivec2 image_size = image.GetSize();
        return CreateTextureFromMemory(image_size, { image.data(), static_cast<size_t>(image_size.x * image_size.y) }, filtering, wrapping);
    }

    TextureHandle CreateTextureFromMemory(Math::ivec2 size, std::span<const CS200::RGBA> colors, Filtering filtering, Wrapping wrapping) noexcept
    {
        TextureHandle texture{};
        GL::GenTextures(1, &texture);
        GL::BindTexture(GL_TEXTURE_2D, texture);
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, static_cast<GLint>(filtering));
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, static_cast<GLint>(filtering));

        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(wrapping));
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(wrapping));

        constexpr int base_mipmap_level = 0; // just bare level, we don't care
        constexpr int zero_border       = 0;
        GL::TexImage2D(GL_TEXTURE_2D, base_mipmap_level, GL_RGBA8, size.x, size.y, zero_border, GL_RGBA, GL_UNSIGNED_BYTE, colors.data());
        GL::BindTexture(GL_TEXTURE_2D, 0);
        return texture;
    }

    TextureHandle CreateRGBATexture(Math::ivec2 size, Filtering filtering, Wrapping wrapping) noexcept
    {
        TextureHandle texture{};
        GL::GenTextures(1, &texture);
        GL::BindTexture(GL_TEXTURE_2D, texture);
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, static_cast<GLint>(filtering));
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, static_cast<GLint>(filtering));

        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(wrapping));
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(wrapping));

        constexpr int base_mipmap_level = 0; // just bare level, we don't care
        constexpr int zero_border       = 0;
         if (OpenGL::IsWebGL || OpenGL::current_version() >= OpenGL::version(4, 2))
         {
             GL::TexStorage2D(GL_TEXTURE_2D, base_mipmap_level + 1, GL_RGBA8, size.x, size.y);
         }
         else
         {
            GL::TexImage2D(GL_TEXTURE_2D, base_mipmap_level, GL_RGBA8, size.x, size.y, zero_border, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);//match channel!!!!!!!!!!!!!!
         }
        
        GL::BindTexture(GL_TEXTURE_2D, 0);
        return texture;
    }

    void SetFiltering(TextureHandle texture_handle, Filtering filtering) noexcept
    {
        GL::BindTexture(GL_TEXTURE_2D, texture_handle);
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, static_cast<GLint>(filtering));
        GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, static_cast<GLint>(filtering));
        GL::BindTexture(GL_TEXTURE_2D, 0);
    }

    void SetWrapping(TextureHandle texture_handle, Wrapping wrapping, TextureCoordinate coord) noexcept
    {
        GL::BindTexture(GL_TEXTURE_2D, texture_handle);
        switch (coord)
        {
            case TextureCoordinate::Both:
                GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(wrapping));
                GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(wrapping));
                break;
            case TextureCoordinate::S: GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, static_cast<GLint>(wrapping)); break;
            case TextureCoordinate::T: GL::TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, static_cast<GLint>(wrapping)); break;
        }

        GL::BindTexture(GL_TEXTURE_2D, 0);
    }

    
}



================================================
FILE: source/OpenGL/Texture.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "CS200/RGBA.h"
#include "Engine/Vec2.h"
#include "GLConstants.h"
#include "GLTypes.h"
#include "Handle.h"
#include <filesystem>
#include <span>

namespace CS200
{
    class Image;
}

namespace OpenGL
{
    /**
     * \brief Texture filtering modes for controlling pixel sampling behavior
     *
     * Filtering determines how OpenGL samples texture pixels when the texture
     * is displayed at a different size than its native resolution. The choice
     * between nearest-pixel and linear filtering dramatically affects the
     * visual appearance of textures.
     *
     * Filtering affects both magnification (when texture appears larger than
     * its pixel resolution) and minification (when texture appears smaller).
     * The choice depends on the desired visual style and performance requirements.
     *
     * Visual characteristics:
     * - NearestPixel: Sharp, pixelated appearance with hard edges
     * - Linear: Smooth, blended appearance with soft edges
     *
     * Performance considerations:
     * - NearestPixel: Faster sampling, lower memory bandwidth
     * - Linear: More expensive sampling, higher memory bandwidth
     */
    enum class Filtering : GLint
    {
        NearestPixel = GL_NEAREST, ///< Sharp pixelated sampling, ideal for pixel art and crisp graphics
        Linear       = GL_LINEAR   ///< Smooth interpolated sampling, ideal for photographs and realistic textures
    };

    /**
     * \brief Texture wrapping modes for controlling behavior outside texture boundaries
     *
     * Wrapping determines what happens when texture coordinates fall outside
     * the [0,1] range. Different wrapping modes enable various tiling and
     * clamping behaviors essential for different rendering scenarios.
     *
     * Each mode serves specific use cases:
     * - Tiling textures (Repeat, MirroredRepeat)
     * - UI elements and single textures (ClampToEdge, ClampToBorder)
     * - Special effects and seamless patterns (MirrorClampToEdge)
     *
     * The wrapping mode is applied to both S (horizontal) and T (vertical)
     * texture coordinate axes, affecting how textures extend beyond their
     * original boundaries.
     */
    enum class Wrapping : GLint
    {
        Repeat         = GL_REPEAT,          ///< Tile texture infinitely in all directions
        ClampToEdge    = GL_CLAMP_TO_EDGE,   ///< Stretch edge pixels, preventing tiling artifacts
        MirroredRepeat = GL_MIRRORED_REPEAT, ///< Tile with alternating mirror reflections
    };

    /**
     * \brief Descriptive alias for OpenGL texture object handles
     *
     * TextureHandle provides a more specific and readable name for the generic
     * OpenGL handle type when referring to texture objects. This improves code
     * clarity without adding compile-time type safety.
     */
    using TextureHandle = Handle;

    /**
     * \brief Create OpenGL texture from loaded image data
     * \param image Image object containing loaded pixel data and dimensions
     * \param filtering Texture sampling method (default: nearest pixel for crisp graphics)
     * \param wrapping Texture coordinate wrapping behavior (default: repeat for tiling)
     * \return Handle to the created OpenGL texture object
     *
     * Creates an OpenGL texture from a pre-loaded Image object, transferring the
     * pixel data to GPU memory and configuring the texture for rendering use.
     * This is the standard approach for loading textures from image files.
     *
     * The image data is transferred in RGBA format with the specified filtering
     * and wrapping settings applied immediately. The texture is ready for use
     * in rendering operations after creation.
     *
     * Common usage patterns:
     * - Loading sprite textures from PNG/JPEG files
     * - Creating texture atlases for efficient batch rendering
     * - Loading UI element graphics and icons
     * - Importing procedurally generated images
     *
     * The function extracts size and pixel data from the Image object and
     * delegates to CreateTextureFromMemory() for the actual OpenGL setup.
     * This provides a convenient interface while maintaining implementation
     * consistency across different texture creation methods.
     */
    [[nodiscard]] TextureHandle CreateTextureFromImage(const CS200::Image& image, Filtering filtering = Filtering::NearestPixel, Wrapping wrapping = Wrapping::Repeat) noexcept;

    /**
     * \brief Create OpenGL texture from raw pixel data in memory
     * \param size Texture dimensions in pixels (width, height)
     * \param colors Span of RGBA pixel data in row-major order
     * \param filtering Texture sampling method (default: nearest pixel)
     * \param wrapping Texture coordinate wrapping behavior (default: repeat)
     * \return Handle to the created OpenGL texture object
     *
     * Creates an OpenGL texture directly from a span of RGBA color data,
     * providing maximum flexibility for programmatically generated textures
     * or custom pixel data sources. The pixel data is transferred to GPU
     * memory and configured for immediate rendering use.
     *
     * Pixel data requirements:
     * - Must contain exactly (width 횞 height) RGBA values
     * - Data is interpreted in row-major order (left-to-right, top-to-bottom)
     * - Each pixel is a packed 32-bit RGBA value
     *
     * Common use cases:
     * - Procedurally generated textures (noise, patterns, gradients)
     * - Runtime texture modification and updates
     * - Converting between different color formats
     * - Creating textures from mathematical functions
     * - Importing from custom or binary file formats
     *
     * The implementation creates the OpenGL texture object, applies the
     * specified filtering and wrapping settings, and uploads the pixel
     * data using GL::TexImage2D() for immediate GPU availability.
     */
    [[nodiscard]] TextureHandle
        CreateTextureFromMemory(Math::ivec2 size, std::span<const CS200::RGBA> colors, Filtering filtering = Filtering::NearestPixel, Wrapping wrapping = Wrapping::Repeat) noexcept;

    /**
     * \brief Create empty RGBA texture without initial pixel data
     * \param size Texture dimensions in pixels (width, height)
     * \param filtering Texture sampling method (default: nearest pixel)
     * \param wrapping Texture coordinate wrapping behavior (default: repeat)
     * \return Handle to the created OpenGL texture object
     *
     * Creates an OpenGL texture with allocated GPU memory but no initial pixel
     * data. This is optimal for textures that will be used as render targets
     * (framebuffer attachments) or will have their data uploaded later through
     * other means.
     *
     * The texture is created with RGBA8 format, providing 8 bits per channel
     * for standard color representation. The memory is allocated but contains
     * undefined initial values until populated through rendering operations
     * or explicit data uploads.
     *
     * Primary use cases:
     * - Framebuffer color attachments for render-to-texture operations
     * - Dynamic textures that will be updated at runtime
     * - Temporary render targets for multi-pass rendering
     * - Screen capture or screenshot buffers
     * - Procedural texture generation targets
     *
     * The implementation uses different OpenGL functions depending on the
     * available OpenGL version: GL::TexStorage2D() for newer versions (more
     * efficient) or GL::TexImage2D() with null data for compatibility.
     *
     * Memory efficiency:
     * Creating empty textures avoids unnecessary data transfers and is
     * particularly efficient when the texture will be written to by
     * rendering operations rather than CPU-provided data.
     */
    [[nodiscard]] TextureHandle CreateRGBATexture(Math::ivec2 size, Filtering filtering = Filtering::NearestPixel, Wrapping wrapping = Wrapping::Repeat) noexcept;

    /**
     * \brief Update texture filtering mode after creation
     * \param texture_handle Handle to the texture object to modify
     * \param filtering New filtering mode to apply
     *
     * Changes the texture sampling behavior for an existing texture object.
     * This allows runtime switching between crisp pixel-perfect rendering
     * and smooth interpolated rendering based on visual requirements or
     * user preferences.
     *
     * The filtering setting affects both magnification and minification,
     * determining how the texture appears when scaled larger or smaller
     * than its native resolution.
     *
     * Common scenarios:
     * - Switching between pixel art and smooth rendering modes
     * - Adjusting texture quality based on performance requirements
     * - Creating visual effects with different sampling characteristics
     * - Implementing user-configurable graphics quality settings
     *
     * The function temporarily binds the texture, updates both MIN_FILTER
     * and MAG_FILTER parameters, then unbinds the texture. This ensures
     * the filtering change takes effect immediately for subsequent rendering.
     */
    void SetFiltering(TextureHandle texture_handle, Filtering filtering) noexcept;

    enum TextureCoordinate
    {
        S,
        T,
        Both
    };

    /**
     * \brief Update texture wrapping mode after creation
     * \param texture_handle Handle to the texture object to modify
     * \param wrapping New wrapping mode to apply
     * \param coord Texture coordinate axis to apply the wrapping mode (default: both S and T)
     *
     * Changes how the texture behaves when texture coordinates extend beyond
     * the [0,1] range. This enables runtime switching between different tiling
     * and clamping behaviors without recreating the texture.
     *
     * The wrapping mode can be applied to S (horizontal), T (vertical), or both
     * texture coordinate axes, affecting how the texture extends in all
     * directions beyond its boundaries.
     *
     * Dynamic wrapping use cases:
     * - Switching between tiled and non-tiled rendering modes
     * - Adapting texture behavior for different rendering contexts
     * - Creating visual effects with changing boundary conditions
     * - Implementing different texture addressing for UI vs. world geometry
     *
     * The function temporarily binds the texture, updates WRAP_S,
     * WRAP_T, or both parameters with the new wrapping mode, then unbinds the texture.
     * Changes take effect immediately for subsequent texture sampling operations.
     */
    void SetWrapping(TextureHandle texture_handle, Wrapping wrapping, TextureCoordinate coord = TextureCoordinate::Both) noexcept;
}



================================================
FILE: source/OpenGL/VertexArray.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "VertexArray.h"
#include "GL.h"

namespace OpenGL
{
    /**
     * \brief Creates and configures a Vertex Array Object (VAO) with multiple vertex buffers and optional index buffer
     *
     * This function sets up a complete VAO by:
     * 1. Generating a new VAO handle
     * 2. Binding vertex buffers and configuring their attribute layouts
     * 3. Setting up vertex attribute pointers for each attribute (position, color, texture coords, etc.)
     * 4. Handling both regular floating-point and integer vertex attributes
     * 5. Configuring instanced rendering divisors if needed
     * 6. Optionally binding an index buffer for indexed drawing
     *
     * A VAO encapsulates all the vertex attribute state, so once created, you can simply bind
     * the VAO to use all the configured vertex buffers and their layouts for rendering.
     *
     * \param vertices An initializer list of VertexBuffer objects, each containing:
     *                 - buffer_handle: The OpenGL buffer handle containing vertex data
     *                 - buffer_layout: Description of how the data is organized (attributes, stride, offset)
     * \param index_buffer Optional index buffer handle for indexed rendering (0 if not used)
     *
     * \return VertexArrayHandle The OpenGL handle to the created VAO
     *
     * \note The VAO will be unbound (set to 0) before returning to avoid affecting subsequent OpenGL state
     * \note Each vertex attribute will be assigned sequential attribute indices starting from 0
     */
    VertexArrayHandle CreateVertexArrayObject([[maybe_unused]] std::initializer_list<VertexBuffer> vertices, [[maybe_unused]] BufferHandle index_buffer)
    {
        // PSEUDO CODE for CreateVertexArrayObject:
        // 1. Create a new Vertex Array Object (VAO)
        // 2. Bind the VAO to make it active
        // 3. For each vertex buffer:
        //    a. Bind the buffer as GL_ARRAY_BUFFER
        //    b. Calculate the stride (total bytes per vertex)
        //    c. For each attribute in the buffer layout:
        //       - Enable the vertex attribute array
        //       - Set up the vertex attribute pointer (regular or integer)
        //       - Set the vertex attribute divisor for instancing
        // 4. If an index buffer is provided, bind it as GL_ELEMENT_ARRAY_BUFFER
        // 5. Unbind the VAO (bind 0)
        // 6. Return the VAO handle

        // Declare a variable to hold the VAO handle
        VertexArrayHandle vao{};

        GL::GenVertexArrays(1, &vao);
        // Pass 1 for count and the address of vao to store the generated handle
        // Documentation: https://docs.gl/es3/glGenVertexArrays

        GL::BindVertexArray(vao);
        // This makes all subsequent vertex attribute calls affect this VAO
        // Documentation: https://docs.gl/es3/glBindVertexArray

        // Keep track of the current attribute index (starts at 0)
        [[maybe_unused]] GLuint attribute_index = 0;

        // Each VertexBuffer contains a buffer_handle and buffer_layout
        // Use structured binding:
        for (const auto& [buffer_handle, buffer_layout] : vertices)
        {
            // This tells OpenGL which buffer to read vertex data from
            // Documentation: https://docs.gl/es3/glBindBuffer
            GL::BindBuffer(GL_ARRAY_BUFFER, buffer_handle);

            // Loop through all attributes in buffer_layout.Attributes
            // Sum up each attr_type.SizeBytes to get the total stride
            [[maybe_unused]] GLsizei stride = 0;
            for (const auto& attr_type : buffer_layout.Attributes)
            {
                stride += attr_type.SizeBytes;
            }

            // Cast buffer_layout.BufferStartingByteOffset to GLintptr
            [[maybe_unused]] GLintptr offset = 0;
            offset                           = static_cast<GLintptr>(buffer_layout.BufferStartingByteOffset);

            // Use:
            for (Attribute::Type attr_type : buffer_layout.Attributes)
            {
                if (attr_type == Attribute::None)
                {
                    continue;
                }

                // Documentation: https://docs.gl/es3/glEnableVertexAttribArray
                GL::EnableVertexAttribArray(attribute_index);
                const GLenum    gl_type         = attr_type.GLType;
                const GLint     component_count = attr_type.ComponentCount;
                const GLboolean normalized      = attr_type.Normalize;
                const bool      is_integer      = attr_type.IntAttribute;
                const GLuint    divisor         = attr_type.Divisor;

                if (is_integer == true)
                {
                    // If true:
                    //   Use GL::VertexAttribIPointer for integer attributes
                    GL::VertexAttribIPointer(attribute_index, component_count, gl_type, stride, reinterpret_cast<GLvoid*>(offset));
                    //   Parameters: (attribute_index, component_count, gl_type, stride, offset as GLvoid*)
                    //   Documentation: https://docs.gl/es3/glVertexAttribPointer (contains VertexAttribIPointer)
                }
                else
                {
                    // Else:
                    //   Use GL::VertexAttribPointer for float/normalized attributes
                    GL::VertexAttribPointer(attribute_index, component_count, gl_type, normalized, stride, reinterpret_cast<GLvoid*>(offset));
                    //   Parameters: (attribute_index, component_count, gl_type, normalized, stride, offset as GLvoid*)
                    //   Documentation: https://docs.gl/es3/glVertexAttribPointer
                }


                GL::VertexAttribDivisor(attribute_index, divisor);
                // Parameters: (attribute_index, divisor)
                // Documentation: https://docs.gl/es3/glVertexAttribDivisor

                ++attribute_index;

                offset += attr_type.SizeBytes;
            }
        }

        if (index_buffer != 0)
        {
            // If true:
            //   Bind the index buffer as GL_ELEMENT_ARRAY_BUFFER
            GL::BindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);
            //   Documentation: https://docs.gl/es3/glBindBuffer
        }


        GL::BindVertexArray(0);
        // This ensures we don't accidentally modify this VAO later
        // Documentation: https://docs.gl/es3/glBindVertexArray

        return vao;
    }

    VertexArrayHandle CreateVertexArrayObject(VertexBuffer vertices, BufferHandle index_buffer)
    {
        return CreateVertexArrayObject({ vertices }, index_buffer);
    }

}



================================================
FILE: source/OpenGL/VertexArray.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once
#include "GLConstants.h"
#include "GLTypes.h"
#include "Handle.h"
#include <cstdint>
#include <initializer_list>
#include <utility>
#include <vector>

namespace OpenGL
{
	/**
	 * \brief Descriptive alias for OpenGL buffer object handles
	 *
	 * BufferHandle provides a more specific and readable name for the generic
	 * OpenGL handle type when referring to buffer objects. This improves code
	 * clarity without adding compile-time type safety.
	 */
	using BufferHandle = Handle;

	/**
	 * \brief Descriptive alias for OpenGL vertex array object handles
	 *
	 * VertexArrayHandle provides a more specific and readable name for the generic
	 * OpenGL handle type when referring to vertex array objects (VAOs). This improves
	 * code clarity without adding compile-time type safety.
	 */
	using VertexArrayHandle = Handle;

	namespace Attribute
	{
		/**
		 * \brief Compact vertex attribute descriptor for efficient OpenGL vertex specification
		 *
		 * Type provides a space-efficient way to describe vertex attributes by packing
		 * all the necessary OpenGL vertex attribute information into a single 32-bit value.
		 * This includes the data type, component count, size, normalization settings,
		 * and instancing divisor values.
		 *
		 * The bit-packed design allows for:
		 * - Efficient storage of attribute specifications
		 * - Fast comparison and sorting of attribute layouts
		 * - Compile-time computation of attribute configurations
		 * - Support for both integer and float attribute types
		 * - Instanced rendering through divisor values
		 *
		 * Bit Layout:
		 * - Bits 15-0:  OpenGL component type (GL_FLOAT, GL_UNSIGNED_BYTE, etc.)
		 * - Bits 18-16: Component count (1-4 components per attribute)
		 * - Bits 23-19: Attribute size in bytes (1-16 bytes)
		 * - Bit 24:     Normalization flag for integer-to-float conversion
		 * - Bit 25:     Integer attribute flag (glVertexAttribIPointer vs glVertexAttribPointer)
		 * - Bits 31-26: Instancing divisor (0-63) for per-instance attributes
		 *
		 * This design enables both standard per-vertex attributes and advanced
		 * instanced rendering techniques while maintaining compatibility with
		 * OpenGL's vertex attribute specification requirements.
		 */
		struct Type
		{
			uint16_t GLType			: 16; // Bits 15-0   (16 bits): OpenGL component type (GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, etc.)
			uint8_t	 ComponentCount : 3;  // Bits 18-16   (3 bits): Component count (1, 2, 3, 4)
			uint8_t	 SizeBytes		: 5;  // Bits 23-19   (5 bits): Attribute size in bytes (max size is 16 - vec4)
			bool	 Normalize		: 1;  // Bit  24      (1 bit) : Normalized flag (0 = false, 1 = true)
			bool	 IntAttribute	: 1;  // Bit  25      (1 bit) : Integer attribute flag (0 = use glVertexAttribPointer, 1 = use glVertexAttribIPointer)
			uint8_t	 Divisor		: 6;  // Bits 26-31   (6 bits): Divisor Value to support instancing (0-63)

			constexpr auto operator<=>(const Type&) const noexcept = default;

			/**
			 * \brief Set the instancing divisor for per-instance attributes
			 * \param divisor_value Divisor for instanced rendering (0 = per-vertex, >0 = per-instance)
			 * \return Reference to this Type for method chaining
			 *
			 * Configures the attribute for instanced rendering by setting how frequently
			 * the attribute advances during instanced drawing calls. A divisor of 0 means
			 * the attribute advances once per vertex (standard behavior), while values
			 * greater than 0 cause the attribute to advance once per N instances.
			 *
			 * Common divisor patterns:
			 * - 0: Per-vertex data (positions, normals, texture coordinates)
			 * - 1: Per-instance data (transformation matrices, colors, IDs)
			 * - N: Per-N-instances data (shared data across multiple instances)
			 *
			 * This enables efficient instanced rendering where certain attributes
			 * remain constant across multiple instances of the same geometry.
			 */
			//constexpr Type& WithDivisor(uint8_t divisor_value) noexcept
			//{
			//	Divisor = divisor_value & 0x3F; // only 6 bits
			//	return *this;
			//}

			//make copy instead so that compatible with constexpr variables
			constexpr Type WithDivisor(uint8_t divisor_value) const noexcept
			{
				Type copy	 = *this;				 
				copy.Divisor = divisor_value & 0x3F; 
				return copy;						 
			}
		};

		static_assert(sizeof(Type) == sizeof(uint32_t));
	}

	/**
	 * \brief Layout specification for vertex attributes within a buffer
	 *
	 * BufferLayout describes how vertex attributes are organized within a single
	 * buffer object, including their types, order, and optional starting offset.
	 * This enables flexible vertex data organization and supports interleaved
	 * vertex formats, multiple attribute streams, and complex data layouts.
	 *
	 * The layout system supports:
	 * - Interleaved vertex data (position, normal, texture coordinates in sequence)
	 * - Multiple attribute streams from the same buffer
	 * - Buffer sub-regions with custom starting offsets
	 * - Mixed attribute types and sizes within the same buffer
	 *
	 * Common vertex layout patterns:
	 * - Simple: {Float3, Float2} for position + texture coordinates
	 * - Complete: {Float3, Float3, Float2} for position + normal + UV
	 * - Packed: {UByte4ToNormalized} for compressed color attributes
	 * - Instanced: Mix of per-vertex and per-instance attributes
	 *
	 * The starting byte offset enables using sub-regions of larger buffers
	 * or skipping headers in complex buffer formats.
	 */
	struct BufferLayout
	{
		/** \brief Byte offset from buffer start where attribute data begins */
		uint32_t BufferStartingByteOffset = 0;

		/** \brief Ordered list of attribute types in this buffer layout */
		std::vector<Attribute::Type> Attributes{};

		BufferLayout() = default;

		/**
		 * \brief Create layout with attributes starting at buffer beginning
		 * \param attributes Initializer list of attribute types in order
		 */
		BufferLayout(std::initializer_list<Attribute::Type> attributes) : BufferStartingByteOffset{ 0 }, Attributes{ attributes }
		{
		}

		/**
		 * \brief Create layout with custom starting offset
		 * \param starting_byte_offset Byte offset from buffer start
		 * \param attributes Initializer list of attribute types in order
		 */
		BufferLayout(uint32_t starting_byte_offset, std::initializer_list<Attribute::Type> attributes) : BufferStartingByteOffset{ starting_byte_offset }, Attributes{ attributes }
		{
		}
	};

	/**
	 * \brief Complete vertex buffer specification with handle and layout information
	 *
	 * VertexBuffer pairs an OpenGL buffer object with its corresponding layout
	 * description, providing all the information needed to configure vertex
	 * attributes for rendering. This combination ensures that buffer data
	 * and its interpretation are kept together as a cohesive unit.
	 *
	 * The structure enables:
	 * - Self-describing vertex buffers with embedded layout information
	 * - Easy sharing of buffer configurations across rendering operations
	 * - Type-safe vertex attribute setup through layout specifications
	 * - Support for multiple vertex streams with different layouts
	 *
	 * Usage patterns:
	 * - Single buffer with interleaved vertex data
	 * - Multiple buffers with different attribute types
	 * - Instanced rendering with per-vertex and per-instance streams
	 * - Dynamic vertex buffers with consistent layouts
	 *
	 * The layout information is used during Vertex Array Object creation
	 * to automatically configure the appropriate vertex attribute pointers
	 * and enable the correct attribute locations.
	 */
	struct VertexBuffer
	{
		/** \brief Handle to the OpenGL buffer object containing vertex data */
		BufferHandle Handle{ 0 };

		/** \brief Layout specification describing how attributes are organized */
		BufferLayout Layout{};
	};

	/**
	 * \brief Create Vertex Array Object (VAO) from multiple vertex buffers
	 * \param vertices Initializer list of vertex buffers with their layouts
	 * \param index_buffer Optional element buffer for indexed rendering (default: 0)
	 * \return Handle to the created and configured Vertex Array Object
	 *
	 * Creates a complete Vertex Array Object that encapsulates the vertex attribute
	 * configuration for multiple vertex buffers. This enables complex vertex setups
	 * with multiple attribute streams, different data types, and sophisticated
	 * rendering techniques like instanced rendering.
	 *
	 * The function performs comprehensive VAO setup:
	 * - Creates and binds a new Vertex Array Object
	 * - Configures vertex attributes for each buffer according to its layout
	 * - Calculates appropriate strides and offsets for interleaved data
	 * - Sets up instancing divisors for per-instance attributes
	 * - Binds optional index buffer for indexed rendering
	 * - Enables all configured vertex attribute arrays
	 *
	 * Multi-buffer capabilities:
	 * - Separate buffers for different attribute types (positions, normals, UVs)
	 * - Mixed per-vertex and per-instance attribute streams
	 * - Different data formats optimized for specific attribute types
	 * - Independent update frequencies for dynamic vs. static data
	 *
	 * Attribute configuration:
	 * Each buffer's layout is processed to determine the correct OpenGL vertex
	 * attribute setup, including proper use of GL::VertexAttribPointer() for
	 * floating-point data and GL::VertexAttribIPointer() for integer data.
	 *
	 * The resulting VAO can be bound once for rendering, eliminating the need
	 * to reconfigure vertex attributes on every draw call.
	 */
	VertexArrayHandle CreateVertexArrayObject(std::initializer_list<VertexBuffer> vertices, BufferHandle index_buffer = 0);

	/**
	 * \brief Create Vertex Array Object (VAO) from a single vertex buffer
	 * \param vertices Single vertex buffer with its layout specification
	 * \param index_buffer Optional element buffer for indexed rendering (default: 0)
	 * \return Handle to the created and configured Vertex Array Object
	 *
	 * Creates a Vertex Array Object for the common case of a single vertex buffer
	 * containing all required vertex attributes. This is a convenience wrapper
	 * around the multi-buffer version, ideal for simple rendering scenarios
	 * with interleaved vertex data.
	 *
	 * Single-buffer advantages:
	 * - Simplified memory management with one buffer object
	 * - Better cache coherency with interleaved vertex data
	 * - Reduced OpenGL state changes during attribute setup
	 * - Lower memory overhead for simple vertex formats
	 *
	 * Common interleaved patterns:
	 * - Position + Color: {Float3, Float4} or {Float2, UByte4ToNormalized}
	 * - Position + UV: {Float3, Float2} for textured geometry
	 * - Complete vertex: {Float3, Float3, Float2} for position + normal + UV
	 * - Sprite data: {Float2, Float2} for position + texture coordinates
	 *
	 * The function delegates to the multi-buffer version with a single-element
	 * initializer list, ensuring consistent behavior and implementation while
	 * providing a cleaner API for simple use cases.
	 */
	VertexArrayHandle CreateVertexArrayObject(VertexBuffer vertices, BufferHandle index_buffer = 0);

	namespace Attribute
	{
		namespace details
		{
			// Constants for encoding
			constexpr bool NORMALIZE	= true;
			constexpr bool NO_NORMALIZE = false;
			constexpr bool TO_INT		= true;	 // Use glVertexAttribIPointer
			constexpr bool TO_FLOAT		= false; // Use glVertexAttribPointer

		}

		/**
		 * \brief Predefined vertex attribute types for common data formats
		 *
		 * This collection provides pre-configured attribute types for all common
		 * vertex data formats, eliminating the need to manually specify OpenGL
		 * types, component counts, and conversion settings. Each attribute type
		 * is optimized for its specific use case and shader input requirements.
		 *
		 * Naming Convention:
		 * - Base types: Bool, Byte, Short, Int, UByte, UShort, UInt, Float
		 * - Vector types: Type2, Type3, Type4 (e.g., Float2, Int3, UByte4)
		 * - Conversions: TypeToFloat, TypeToNormalized (e.g., ByteToFloat, UByteToNormalized)
		 *
		 * Conversion Types:
		 * - ToFloat: Convert integer types to float without normalization
		 * - ToNormalized: Convert integer types to normalized float ranges
		 *   - Signed types: [-1, 1] range (Byte, Short, Int)
		 *   - Unsigned types: [0, 1] range (UByte, UShort, UInt)
		 *
		 * Memory Optimization:
		 * - Use smaller integer types (Byte, UByte) for packed data
		 * - Use normalized conversions for color and normal data
		 * - Use native Float types for precise calculations
		 *
		 * Common Usage Patterns:
		 * - Positions: Float2, Float3
		 * - Colors: UByte4ToNormalized (compact), Float4 (precise)
		 * - Normals: Float3, Byte3ToNormalized (compact)
		 * - Texture Coordinates: Float2
		 * - Indices: UShort, UInt (in index buffers)
		 *
		 * Instancing Support:
		 * All attribute types can be modified with .WithDivisor(N) to create
		 * per-instance attributes for instanced rendering techniques.
		 */

		constexpr Type None				   = { 0, 0, 0, 0, 0, 0 };
		constexpr Type Bool				   = { GL_UNSIGNED_BYTE, 1, 1 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// bool -> bool
		constexpr Type Bool2			   = { GL_UNSIGNED_BYTE, 2, 2 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// bool[2] -> bvec2
		constexpr Type Bool3			   = { GL_UNSIGNED_BYTE, 3, 3 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// bool[3] -> bvec3
		constexpr Type Bool4			   = { GL_UNSIGNED_BYTE, 4, 4 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// bool[4] -> bvec4
		constexpr Type Byte				   = { GL_BYTE, 1, 1 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_INT, 0 };						// int8_t -> int
		constexpr Type Byte2			   = { GL_BYTE, 2, 2 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_INT, 0 };						// int8_t[2] -> ivec2
		constexpr Type Byte2ToFloat		   = { GL_BYTE, 2, 2 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// int8_t[2] -> vec2
		constexpr Type Byte2ToNormalized   = { GL_BYTE, 2, 2 * sizeof(int8_t), details::NORMALIZE, details::TO_FLOAT, 0 };						// int8_t[2] -> vec2 [-1, 1]
		constexpr Type Byte3			   = { GL_BYTE, 3, 3 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_INT, 0 };						// int8_t[3] -> ivec3
		constexpr Type Byte3ToFloat		   = { GL_BYTE, 3, 3 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// int8_t[3] -> vec3
		constexpr Type Byte3ToNormalized   = { GL_BYTE, 3, 3 * sizeof(int8_t), details::NORMALIZE, details::TO_FLOAT, 0 };						// int8_t[3] -> vec3 [-1, 1]
		constexpr Type Byte4			   = { GL_BYTE, 4, 4 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_INT, 0 };						// int8_t[4] -> ivec4
		constexpr Type Byte4ToFloat		   = { GL_BYTE, 4, 4 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// int8_t[4] -> vec4
		constexpr Type Byte4ToNormalized   = { GL_BYTE, 4, 4 * sizeof(int8_t), details::NORMALIZE, details::TO_FLOAT, 0 };						// int8_t[4] -> vec4 [-1, 1]
		constexpr Type ByteToFloat		   = { GL_BYTE, 1, 1 * sizeof(int8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// int8_t -> float
		constexpr Type ByteToNormalized	   = { GL_BYTE, 1, 1 * sizeof(int8_t), details::NORMALIZE, details::TO_FLOAT, 0 };						// int8_t -> float [-1, 1]
		constexpr Type Float			   = { GL_FLOAT, 1, 1 * sizeof(float), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// float -> float
		constexpr Type Float2			   = { GL_FLOAT, 2, 2 * sizeof(float), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// float[2] -> vec2
		constexpr Type Float3			   = { GL_FLOAT, 3, 3 * sizeof(float), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// float[3] -> vec3
		constexpr Type Float4			   = { GL_FLOAT, 4, 4 * sizeof(float), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// float[4] -> vec4
		constexpr Type Int				   = { GL_INT, 1, 1 * sizeof(int), details::NO_NORMALIZE, details::TO_INT, 0 };							// int -> int
		constexpr Type Int2				   = { GL_INT, 2, 2 * sizeof(int), details::NO_NORMALIZE, details::TO_INT, 0 };							// int[2] -> ivec2
		constexpr Type Int2ToFloat		   = { GL_INT, 2, 2 * sizeof(int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };						// int[2] -> vec2
		constexpr Type Int2ToNormalized	   = { GL_INT, 2, 2 * sizeof(int), details::NORMALIZE, details::TO_FLOAT, 0 };							// int[2] -> vec2 [-1, 1]
		constexpr Type Int3				   = { GL_INT, 3, 3 * sizeof(int), details::NO_NORMALIZE, details::TO_INT, 0 };							// int[3] -> ivec3
		constexpr Type Int3ToFloat		   = { GL_INT, 3, 3 * sizeof(int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };						// int[3] -> vec3
		constexpr Type Int3ToNormalized	   = { GL_INT, 3, 3 * sizeof(int), details::NORMALIZE, details::TO_FLOAT, 0 };							// int[3] -> vec3 [-1, 1]
		constexpr Type Int4				   = { GL_INT, 4, 4 * sizeof(int), details::NO_NORMALIZE, details::TO_INT, 0 };							// int[4] -> ivec4
		constexpr Type Int4ToFloat		   = { GL_INT, 4, 4 * sizeof(int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };						// int[4] -> vec4
		constexpr Type Int4ToNormalized	   = { GL_INT, 4, 4 * sizeof(int), details::NORMALIZE, details::TO_FLOAT, 0 };							// int[4] -> vec4 [-1, 1]
		constexpr Type IntToFloat		   = { GL_INT, 1, 1 * sizeof(int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };						// int -> float
		constexpr Type IntToNormalized	   = { GL_INT, 1, 1 * sizeof(int), details::NORMALIZE, details::TO_FLOAT, 0 };							// int -> float [-1, 1]
		constexpr Type Short			   = { GL_SHORT, 1, 1 * sizeof(short), details::NO_NORMALIZE, details::TO_INT, 0 };						// short -> int
		constexpr Type Short2			   = { GL_SHORT, 2, 2 * sizeof(short), details::NO_NORMALIZE, details::TO_INT, 0 };						// short[2] -> ivec2
		constexpr Type Short2ToFloat	   = { GL_SHORT, 2, 2 * sizeof(short), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// short[2] -> vec2
		constexpr Type Short2ToNormalized  = { GL_SHORT, 2, 2 * sizeof(short), details::NORMALIZE, details::TO_FLOAT, 0 };						// short[2] -> vec2 [-1, 1]
		constexpr Type Short3			   = { GL_SHORT, 3, 3 * sizeof(short), details::NO_NORMALIZE, details::TO_INT, 0 };						// short[3] -> ivec3
		constexpr Type Short3ToFloat	   = { GL_SHORT, 3, 3 * sizeof(short), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// short[3] -> vec3
		constexpr Type Short3ToNormalized  = { GL_SHORT, 3, 3 * sizeof(short), details::NORMALIZE, details::TO_FLOAT, 0 };						// short[3] -> vec3 [-1, 1]
		constexpr Type Short4			   = { GL_SHORT, 4, 4 * sizeof(short), details::NO_NORMALIZE, details::TO_INT, 0 };						// short[4] -> ivec4
		constexpr Type Short4ToFloat	   = { GL_SHORT, 4, 4 * sizeof(short), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// short[4] -> vec4
		constexpr Type Short4ToNormalized  = { GL_SHORT, 4, 4 * sizeof(short), details::NORMALIZE, details::TO_FLOAT, 0 };						// short[4] -> vec4 [-1, 1]
		constexpr Type ShortToFloat		   = { GL_SHORT, 1, 1 * sizeof(short), details::NO_NORMALIZE, details::TO_FLOAT, 0 };					// short -> float
		constexpr Type ShortToNormalized   = { GL_SHORT, 1, 1 * sizeof(short), details::NORMALIZE, details::TO_FLOAT, 0 };						// short -> float [-1, 1]
		constexpr Type UByte			   = { GL_UNSIGNED_BYTE, 1, 1 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// uint8_t -> uint
		constexpr Type UByte2			   = { GL_UNSIGNED_BYTE, 2, 2 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// uint8_t[2] -> uvec2
		constexpr Type UByte2ToFloat	   = { GL_UNSIGNED_BYTE, 2, 2 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[2] -> vec2
		constexpr Type UByte2ToNormalized  = { GL_UNSIGNED_BYTE, 2, 2 * sizeof(uint8_t), details::NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[2] -> vec2 [0, 1]
		constexpr Type UByte3			   = { GL_UNSIGNED_BYTE, 3, 3 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// uint8_t[3] -> uvec3
		constexpr Type UByte3ToFloat	   = { GL_UNSIGNED_BYTE, 3, 3 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[3] -> vec3
		constexpr Type UByte3ToNormalized  = { GL_UNSIGNED_BYTE, 3, 3 * sizeof(uint8_t), details::NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[3] -> vec3 [0, 1]
		constexpr Type UByte4			   = { GL_UNSIGNED_BYTE, 4, 4 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_INT, 0 };			// uint8_t[4] -> uvec4
		constexpr Type UByte4ToFloat	   = { GL_UNSIGNED_BYTE, 4, 4 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[4] -> vec4
		constexpr Type UByte4ToNormalized  = { GL_UNSIGNED_BYTE, 4, 4 * sizeof(uint8_t), details::NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t[4] -> vec4 [0, 1]
		constexpr Type UByteToFloat		   = { GL_UNSIGNED_BYTE, 1, 1 * sizeof(uint8_t), details::NO_NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t -> float
		constexpr Type UByteToNormalized   = { GL_UNSIGNED_BYTE, 1, 1 * sizeof(uint8_t), details::NORMALIZE, details::TO_FLOAT, 0 };			// uint8_t -> float [0, 1]
		constexpr Type UInt				   = { GL_UNSIGNED_INT, 1, 1 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_INT, 0 };		// uint -> uint
		constexpr Type UInt2			   = { GL_UNSIGNED_INT, 2, 2 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_INT, 0 };		// uint[2] -> uvec2
		constexpr Type UInt2ToFloat		   = { GL_UNSIGNED_INT, 2, 2 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };		// uint[2] -> vec2
		constexpr Type UInt2ToNormalized   = { GL_UNSIGNED_INT, 2, 2 * sizeof(unsigned int), details::NORMALIZE, details::TO_FLOAT, 0 };		// uint[2] -> vec2 [0, 1]
		constexpr Type UInt3			   = { GL_UNSIGNED_INT, 3, 3 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_INT, 0 };		// uint[3] -> uvec3
		constexpr Type UInt3ToFloat		   = { GL_UNSIGNED_INT, 3, 3 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };		// uint[3] -> vec3
		constexpr Type UInt3ToNormalized   = { GL_UNSIGNED_INT, 3, 3 * sizeof(unsigned int), details::NORMALIZE, details::TO_FLOAT, 0 };		// uint[3] -> vec3 [0, 1]
		constexpr Type UInt4			   = { GL_UNSIGNED_INT, 4, 4 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_INT, 0 };		// uint[4] -> uvec4
		constexpr Type UInt4ToFloat		   = { GL_UNSIGNED_INT, 4, 4 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };		// uint[4] -> vec4
		constexpr Type UInt4ToNormalized   = { GL_UNSIGNED_INT, 4, 4 * sizeof(unsigned int), details::NORMALIZE, details::TO_FLOAT, 0 };		// uint[4] -> vec4 [0, 1]
		constexpr Type UIntToFloat		   = { GL_UNSIGNED_INT, 1, 1 * sizeof(unsigned int), details::NO_NORMALIZE, details::TO_FLOAT, 0 };		// uint -> float
		constexpr Type UIntToNormalized	   = { GL_UNSIGNED_INT, 1, 1 * sizeof(unsigned int), details::NORMALIZE, details::TO_FLOAT, 0 };		// uint -> float [0, 1]
		constexpr Type UShort			   = { GL_UNSIGNED_SHORT, 1, 1 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_INT, 0 };	// ushort -> uint
		constexpr Type UShort2			   = { GL_UNSIGNED_SHORT, 2, 2 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_INT, 0 };	// ushort[2] -> uvec2
		constexpr Type UShort2ToFloat	   = { GL_UNSIGNED_SHORT, 2, 2 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_FLOAT, 0 }; // ushort[2] -> vec2
		constexpr Type UShort2ToNormalized = { GL_UNSIGNED_SHORT, 2, 2 * sizeof(unsigned short), details::NORMALIZE, details::TO_FLOAT, 0 };	// ushort[2] -> vec2 [0, 1]
		constexpr Type UShort3			   = { GL_UNSIGNED_SHORT, 3, 3 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_INT, 0 };	// ushort[3] -> uvec3
		constexpr Type UShort3ToFloat	   = { GL_UNSIGNED_SHORT, 3, 3 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_FLOAT, 0 }; // ushort[3] -> vec3
		constexpr Type UShort3ToNormalized = { GL_UNSIGNED_SHORT, 3, 3 * sizeof(unsigned short), details::NORMALIZE, details::TO_FLOAT, 0 };	// ushort[3] -> vec3 [0, 1]
		constexpr Type UShort4			   = { GL_UNSIGNED_SHORT, 4, 4 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_INT, 0 };	// ushort[4] -> uvec4
		constexpr Type UShort4ToFloat	   = { GL_UNSIGNED_SHORT, 4, 4 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_FLOAT, 0 }; // ushort[4] -> vec4
		constexpr Type UShort4ToNormalized = { GL_UNSIGNED_SHORT, 4, 4 * sizeof(unsigned short), details::NORMALIZE, details::TO_FLOAT, 0 };	// ushort[4] -> vec4 [0, 1]
		constexpr Type UShortToFloat	   = { GL_UNSIGNED_SHORT, 1, 1 * sizeof(unsigned short), details::NO_NORMALIZE, details::TO_FLOAT, 0 }; // ushort -> float
		constexpr Type UShortToNormalized  = { GL_UNSIGNED_SHORT, 1, 1 * sizeof(unsigned short), details::NORMALIZE, details::TO_FLOAT, 0 };	// ushort -> float [0, 1]
	};


}


