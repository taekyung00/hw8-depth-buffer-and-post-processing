Directory: cs200-hw8
Files analyzed: 103

Estimated tokens: 142.8k

Directory structure:
└── cs200-hw8/
    └── source/
        ├── main.cpp
        ├── CS200/
        │   ├── BatchRenderer2D.cpp
        │   ├── BatchRenderer2D.h
        │   ├── Image.cpp
        │   ├── Image.h
        │   ├── ImGuiHelper.cpp
        │   ├── ImGuiHelper.h
        │   ├── ImmediateRenderer2D.cpp
        │   ├── ImmediateRenderer2D.h
        │   ├── InstancedRenderer2D.cpp
        │   ├── InstancedRenderer2D.h
        │   ├── IRenderer2D.h
        │   ├── NDC.h
        │   ├── OffscreenFramebuffer.cpp
        │   ├── OffscreenFramebuffer.h
        │   ├── PostProcessingPipeline.cpp
        │   ├── PostProcessingPipeline.h
        │   ├── Renderer2DUtils.cpp
        │   ├── Renderer2DUtils.h
        │   ├── RenderingAPI.cpp
        │   ├── RenderingAPI.h
        │   ├── RGBA.h
        │   ├── Shape.cpp
        │   └── Shape.h
        ├── Demo/
        │   ├── DemoDepthPost.cpp
        │   └── DemoDepthPost.h
        ├── Engine/
        │   ├── Animation.cpp
        │   ├── Animation.h
        │   ├── Camera.cpp
        │   ├── Camera.h
        │   ├── Collision.cpp
        │   ├── Collision.h
        │   ├── Component.h
        │   ├── ComponentManager.h
        │   ├── Engine.cpp
        │   ├── Engine.h
        │   ├── Error.h
        │   ├── Font.cpp
        │   ├── Font.h
        │   ├── Fonts.h
        │   ├── FPS.h
        │   ├── GameObject.cpp
        │   ├── GameObject.h
        │   ├── GameObjectManager.cpp
        │   ├── GameObjectManager.h
        │   ├── GameState.h
        │   ├── GameStateManager.cpp
        │   ├── GameStateManager.h
        │   ├── Input.cpp
        │   ├── Input.h
        │   ├── Logger.cpp
        │   ├── Logger.h
        │   ├── Matrix.cpp
        │   ├── Matrix.h
        │   ├── Particle.cpp
        │   ├── Particle.h
        │   ├── Path.cpp
        │   ├── Path.h
        │   ├── Random.cpp
        │   ├── Random.h
        │   ├── Rect.h
        │   ├── ShowCollision.cpp
        │   ├── ShowCollision.h
        │   ├── Sprite.cpp
        │   ├── Sprite.h
        │   ├── TextManager.cpp
        │   ├── TextManager.h
        │   ├── Texture.cpp
        │   ├── Texture.h
        │   ├── TextureManager.cpp
        │   ├── TextureManager.h
        │   ├── Timer.h
        │   ├── Vec2.cpp
        │   ├── Vec2.h
        │   ├── Window.cpp
        │   └── Window.h
        ├── Game/
        │   ├── Background.cpp
        │   ├── Background.h
        │   ├── GameObjectTypes.h
        │   ├── MainMenu.cpp
        │   ├── MainMenu.h
        │   ├── Particles.h
        │   ├── Score.cpp
        │   ├── Score.h
        │   ├── Splash.cpp
        │   ├── Splash.h
        │   └── States.h
        └── OpenGL/
            ├── Buffer.cpp
            ├── Buffer.h
            ├── Environment.h
            ├── Framebuffer.cpp
            ├── Framebuffer.h
            ├── GL.cpp
            ├── GL.h
            ├── GLConstants.h
            ├── GLTypes.h
            ├── Handle.h
            ├── Shader.cpp
            ├── Shader.h
            ├── Texture.cpp
            ├── Texture.h
            ├── VertexArray.cpp
            └── VertexArray.h


================================================
FILE: source/main.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2024 Fall
 * \copyright DigiPen Institute of Technology
 */

#include "Engine/Engine.h"
#include "Engine/GameStateManager.h"
#include "Engine/Window.h"
#include "Game/Splash.h"

namespace
{
    [[maybe_unused]] int  gWindowWidth  = 400;
    [[maybe_unused]] int  gWindowHeight = 400;
    [[maybe_unused]] bool gNeedResize   = false;
}


#if defined(__EMSCRIPTEN__)
#    include <emscripten.h>
#    include <emscripten/bind.h>
#    include <emscripten/em_asm.h>

void main_loop()
{
    Engine& engine = Engine::Instance();
    if (gNeedResize)
    {
        Engine::GetWindow().ForceResize(gWindowWidth, gWindowHeight);
        gNeedResize = false;
    }

    engine.Update();

    if (engine.HasGameEnded())
    {
        emscripten_cancel_main_loop();
        engine.Stop();
    }
}

EMSCRIPTEN_BINDINGS(main_window)
{
    emscripten::function(
        "setWindowSize", emscripten::optional_override(
                             [](int sizeX, int sizeY)
                             {
                                 sizeX                  = (sizeX < 400) ? 400 : sizeX; // Minimum size enforcement
                                 sizeY                  = (sizeY < 400) ? 400 : sizeY; // Minimum size enforcement  
                                 const auto window_size = Engine::GetWindow().GetSize();
                                 if (sizeX != window_size.x || sizeY != window_size.y)
                                 {
                                     gNeedResize   = true;
                                     gWindowWidth  = sizeX;
                                     gWindowHeight = sizeY;
                                 }
                             }));
}
#endif

int main([[maybe_unused]] int argc, [[maybe_unused]] char* argv[])
{
    Engine& engine = Engine::Instance();
    engine.Start("Taekyung Ho CS200 HW8");
    engine.GetGameStateManager().PushState<Splash>();

#if !defined(__EMSCRIPTEN__)
    while (engine.HasGameEnded() == false)
    {
        engine.Update();
    }
    engine.Stop();
#else
    // https://emscripten.org/docs/api_reference/emscripten.h.html#c.emscripten_set_main_loop
    constexpr bool simulate_infinite_loop  = true;
    constexpr int  match_browser_framerate = -1;
    emscripten_set_main_loop(main_loop, match_browser_framerate, simulate_infinite_loop);
#endif
    return 0;
}



================================================
FILE: source/CS200/BatchRenderer2D.cpp
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "BatchRenderer2D.h"

#include "Engine/Path.h"
#include "OpenGL/Buffer.h"
#include "OpenGL/GL.h"
#include "OpenGL/VertexArray.h"
#include "Renderer2DUtils.h"
#include <fstream>
#include <numeric>
#include <sstream>

namespace CS200
{
	BatchRenderer2D::BatchRenderer2D(unsigned max_quads)
	{
		maxVertices = max_quads * 4; // each quad have 4 vertices
		maxIndices	= max_quads * 6;
		vertexData.resize(maxVertices);
		sdfVertexData.resize(maxVertices);

		// wait until other stuffs are ready.. ->Init
	}

	BatchRenderer2D::BatchRenderer2D(BatchRenderer2D&& other) noexcept
		: vertexData(std::move(other.vertexData)),
          vertexBufferHandle(other.vertexBufferHandle),
          texturingCombineShader(std::move(other.texturingCombineShader)),
          modelHandle(other.modelHandle),
          sdfVertexData(std::move(other.sdfVertexData)),
          sdfVertexBufferHandle(other.sdfVertexBufferHandle),
          sdfShader(std::move(other.sdfShader)),
          sdfModelHandle(other.sdfModelHandle),
          sdfVertexDataEnd(other.sdfVertexDataEnd),
          sdfIndexCount(other.sdfIndexCount),
          indexBufferHandle(other.indexBufferHandle),
          camera_uniform_buffer(other.camera_uniform_buffer),
          camera_array(other.camera_array),
          currentCameraMatrix(other.currentCameraMatrix),
          maxVertices(other.maxVertices),
          maxIndices(other.maxIndices),
          vertexDataEnd(other.vertexDataEnd),
          indexCount(other.indexCount),
          textureSlots(std::move(other.textureSlots)),
          activeTextureSize(other.activeTextureSize),
          draw_call(other.draw_call), 
		  texture_call(other.texture_call)
	{
		other.vertexBufferHandle	 = 0;
		other.modelHandle			 = 0;
		other.sdfVertexBufferHandle	 = 0;
		other.sdfModelHandle		 = 0;
		other.indexBufferHandle		 = 0;
		other.camera_uniform_buffer	 = 0;
		other.texturingCombineShader = {};
		other.sdfShader				 = {};
		other.vertexDataEnd			 = nullptr;
		other.indexCount			 = 0;
		other.sdfVertexDataEnd		 = nullptr;
		other.sdfIndexCount			 = 0;
		other.activeTextureSize		 = 0;
		other.draw_call				 = 0;
		other.texture_call			 = 0;
	}

	BatchRenderer2D& BatchRenderer2D::operator=(BatchRenderer2D&& other) noexcept
	{
		std::swap(vertexData, other.vertexData);
		std::swap(vertexBufferHandle, other.vertexBufferHandle);
		std::swap(indexBufferHandle, other.indexBufferHandle);
		std::swap(modelHandle, other.modelHandle);
		std::swap(texturingCombineShader, other.texturingCombineShader);
		std::swap(currentCameraMatrix, other.currentCameraMatrix);

		std::swap(sdfVertexData, other.sdfVertexData);
		std::swap(sdfVertexBufferHandle, other.sdfVertexBufferHandle);
		std::swap(sdfShader, other.sdfShader);
		std::swap(sdfModelHandle, other.sdfModelHandle);
		std::swap(sdfVertexDataEnd, other.sdfVertexDataEnd);
		std::swap(sdfIndexCount, other.sdfIndexCount);

		std::swap(camera_uniform_buffer, other.camera_uniform_buffer);
		std::swap(camera_array, other.camera_array);
		std::swap(draw_call, other.draw_call);
		std::swap(texture_call, other.texture_call);

		std::swap(maxVertices, other.maxVertices);
		std::swap(maxIndices, other.maxIndices);
		std::swap(vertexDataEnd, other.vertexDataEnd);
		std::swap(indexCount, other.indexCount);
		std::swap(textureSlots, other.textureSlots);
		std::swap(activeTextureSize, other.activeTextureSize);
		return *this;
	}

	BatchRenderer2D::~BatchRenderer2D()
	{
		Shutdown();
	}

	void BatchRenderer2D::Init()
	{
		// get how many texture opengl can draw
		GLint max_tex_units = 0;
		GL::GetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &max_tex_units); // check with docs.gl to get minimum(16) and maximum
		textureSlots.resize(static_cast<size_t>(std::min(max_tex_units, 64)));

		// load shaders with parsing
		const std::filesystem::path vertex_file = assets::locate_asset("Assets/shaders/BatchRenderer2D/quad.vert");
		std::ifstream				vert_stream(vertex_file);
		std::stringstream			vert_text_stream;
		vert_text_stream << vert_stream.rdbuf();
		const std::string vertex_glsl = vert_text_stream.str();


		const std::filesystem::path fragment_file = assets::locate_asset("Assets/shaders/BatchRenderer2D/quad.frag");
		std::ifstream				frag_stream(fragment_file);
		std::stringstream			frag_text_stream;
		frag_text_stream << frag_stream.rdbuf();
		std::string		  frag_glsl		= frag_text_stream.str();
		const size_t	  first_newline = frag_glsl.find('\n');
		const std::string define_line	= "\n#define MAX_TEXTURE_SLOTS " + std::to_string(textureSlots.size());
		frag_glsl.insert(first_newline, define_line);

		texturingCombineShader = OpenGL::CreateShader(std::string_view{ vertex_glsl }, std::string_view{ frag_glsl });


		// have to set their binding index
		GL::UseProgram(texturingCombineShader.Shader);

		std::vector<int> sampler_binding_values(textureSlots.size());
		std::iota(sampler_binding_values.begin(), sampler_binding_values.end(), 0);
		const GLint location = GL::GetUniformLocation(texturingCombineShader.Shader, "uTextures");
		GL::Uniform1iv(location, static_cast<GLsizei>(textureSlots.size()), sampler_binding_values.data());

		GL::UseProgram(0);

		// create vertex array object, buffer vertices, buffer indices
		vertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(QuadVertex) * maxVertices));


		// setup index buffer

		// unlike vertex buffer that gonna change every frame, index don't change
		// i.e. 0 1 2 2 3 0 ... << this pattern repeat
		// but just amount of index gonna change(how many do we need?)
		std::vector<unsigned> indice_values(maxIndices);
		unsigned			  offset = 0;
		for (unsigned i = 0; i < maxIndices; i += 6)
		{
			indice_values[i + 0] = offset + 0;
			indice_values[i + 1] = offset + 1;
			indice_values[i + 2] = offset + 2;
			indice_values[i + 3] = offset + 2;
			indice_values[i + 4] = offset + 3;
			indice_values[i + 5] = offset + 0;
			offset += 4;
		}

		indexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Indices, std::as_bytes(std::span{ indice_values }));

		// Create vertex array object
		const auto layout = {
			OpenGL::VertexBuffer{ vertexBufferHandle, { OpenGL::Attribute::Float2, OpenGL::Attribute::Float2, OpenGL::Attribute::UByte4ToNormalized, OpenGL::Attribute::Int, OpenGL::Attribute::Float } }
		};
		modelHandle = OpenGL::CreateVertexArrayObject(layout, indexBufferHandle);


		// SDF
		//  create vertex array object, buffer vertices, buffer indices
		sdfShader = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/BatchRenderer2D/sdf.vert"), assets::locate_asset("Assets/shaders/BatchRenderer2D/sdf.frag"));

		sdfVertexBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, static_cast<GLsizeiptr>(sizeof(SDFVertex) * maxVertices));
		const auto sdfLayout  = {
			 OpenGL::VertexBuffer{ sdfVertexBufferHandle,
								   {
									   OpenGL::Attribute::Float2,			  // aWorldPosition
									   OpenGL::Attribute::Float2,			  // aTestPoint
									   OpenGL::Attribute::UByte4ToNormalized, // aFillColor
									   OpenGL::Attribute::UByte4ToNormalized, // aLineColor
									   OpenGL::Attribute::Float2,			  // aWorldSize
									   OpenGL::Attribute::Float,			  // aLineWidth
									   OpenGL::Attribute::Int,				  // aShape
									   OpenGL::Attribute::Float				  // aDepth
								   } }
		};
		sdfModelHandle = OpenGL::CreateVertexArrayObject(sdfLayout, indexBufferHandle);

		//- Create uniform buffer for camera/view-projection matrix
		camera_uniform_buffer = OpenGL::CreateBuffer(OpenGL::BufferType::UniformBlocks, sizeof(camera_array));

		OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");
		OpenGL::BindUniformBufferToShader(sdfShader.Shader, 0, camera_uniform_buffer, "NDC");
	}

	void BatchRenderer2D::Shutdown()
	{
		OpenGL::DestroyShader(texturingCombineShader);
		OpenGL::DestroyShader(sdfShader);

		GL::DeleteBuffers(1, &vertexBufferHandle), vertexBufferHandle		= 0;
		GL::DeleteBuffers(1, &indexBufferHandle), indexBufferHandle			= 0;
		GL::DeleteBuffers(1, &sdfVertexBufferHandle), sdfVertexBufferHandle = 0;

		GL::DeleteBuffers(1, &camera_uniform_buffer), camera_uniform_buffer = 0;

		GL::DeleteVertexArrays(1, &modelHandle), modelHandle	   = 0;
		GL::DeleteVertexArrays(1, &sdfModelHandle), sdfModelHandle = 0;
	}

	void BatchRenderer2D::BeginScene(const Math::TransformationMatrix& view_projection)
	{
		//- Store matrix for potential later use
		currentCameraMatrix = view_projection;

		//- Convert 3x3 matrix to 4x3 format for uniform buffer
		updateCameraUniformValues(currentCameraMatrix);

		//- Update uniform buffer with new matrix data
		OpenGL::UpdateBufferData(OpenGL::BufferType::UniformBlocks, camera_uniform_buffer, std::as_bytes(std::span{ camera_array }));

		//- Bind uniform buffer for use by shaders
		GL::BindBuffer(GL_UNIFORM_BUFFER, camera_uniform_buffer);

		draw_call	 = 0;
		texture_call = 0;
		startBatch();
	}

	void BatchRenderer2D::EndScene()
	{
		flush();
	}

	void BatchRenderer2D::DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth)
	{
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}

		if (indexCount + 6 > maxIndices)
		{
			flush();
		}

		int	 tex_index = 0;
		bool found	   = false;
		for (size_t i = 0; i < activeTextureSize; ++i)
		{
			if (textureSlots[i] == texture)
			{
				found	  = true;
				tex_index = static_cast<int>(i);
			}
		}

		if (!found)
		{
			if (activeTextureSize >= textureSlots.size())
			{
				flush();
			}
			tex_index						= static_cast<int>(activeTextureSize);
			textureSlots[activeTextureSize] = texture;
			++activeTextureSize;
		}

		// Convert texture_coords_lbrt (left, bottom, right, top) to texture coordinate transform matrix
		const float left   = static_cast<float>(texture_coord_bl.x);
		const float bottom = static_cast<float>(texture_coord_bl.y);
		const float right  = static_cast<float>(texture_coord_tr.x);
		const float top	   = static_cast<float>(texture_coord_tr.y);

		const std::array<float, 2> texture_coords[4] = {
			{  left, bottom }, //  bottom left
			{ right, bottom }, //  bottom right
			{ right,	 top }, //  top right
			{  left,	top }  //  top left
		};

		// we don't have to make texcoord_transform matrix, just use 4 texture coords right away!

		// const std::array<unsigned char, 4> tint = pack_color(tint_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};


		for (unsigned i = 0; i < 4; ++i) // i is for 4 vertex(bottom/top - right/left)
		{
			// matrix multiply manually (3by 3, transform matrix) * (3 by 1, position matrix) => model to world!
			const float x =
				static_cast<float>(static_cast<double>(model_positions[i][0])  * transform[0][0] + static_cast<double>(model_positions[i][1])  * transform[0][1] + transform[0][2]);
			const float y = static_cast<float>(static_cast<double>(model_positions[i][0]) * transform[1][0] + static_cast<double>(model_positions[i][1]) * transform[1][1] + transform[1][2]);

			vertexDataEnd->x			= x;
			vertexDataEnd->y			= y;
			vertexDataEnd->s			= texture_coords[i][0];
			vertexDataEnd->t			= texture_coords[i][1];
			vertexDataEnd->tint			= ColorArray(tintColor);
			vertexDataEnd->textureIndex = tex_index;
			vertexDataEnd->depth		= depth;
			++vertexDataEnd;
		}
		indexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawCircle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (indexCount + 6 > maxIndices)
		{
			flush();
		}
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}

		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};

		for (unsigned i = 0; i < 4; ++i)
		{
			const float x = model_positions[i][0] * sdf_transform.QuadTransform[0] + model_positions[i][1] * sdf_transform.QuadTransform[3] + sdf_transform.QuadTransform[6];
			const float y = model_positions[i][0] * sdf_transform.QuadTransform[1] + model_positions[i][1] * sdf_transform.QuadTransform[4] + sdf_transform.QuadTransform[7];

			const float s = model_positions[i][0] * sdf_transform.QuadSize[0];
			const float t = model_positions[i][1] * sdf_transform.QuadSize[1];

			sdfVertexDataEnd->x			  = x;
			sdfVertexDataEnd->y			  = y;
			sdfVertexDataEnd->testPoint_s = s;
			sdfVertexDataEnd->testPoint_t = t;
			sdfVertexDataEnd->fillColor	  = fill_bytes;
			sdfVertexDataEnd->lineColor	  = line_bytes;
			sdfVertexDataEnd->worldSize_x = sdf_transform.WorldSize[0];
			sdfVertexDataEnd->worldSize_y = sdf_transform.WorldSize[1];
			sdfVertexDataEnd->lineWidth	  = static_cast<float>(line_width);
			sdfVertexDataEnd->shape		  = static_cast<int>(SDFShape::Circle); // 0
			sdfVertexDataEnd->depth		  = depth;

			++sdfVertexDataEnd;
		}
		sdfIndexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawRectangle(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] CS200::RGBA fill_color, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		if (indexCount + 6 > maxIndices)
		{
			flush();
		}
		if (sdfIndexCount + 6 > maxIndices)
		{
			flush();
		}
		const auto sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
		const auto fill_bytes	 = ColorArray(fill_color);
		const auto line_bytes	 = ColorArray(line_color);

		constexpr std::array<float, 2> model_positions[4] = {
			{ -0.5, -0.5 }, //  bottom left
			{ +0.5, -0.5 }, //  bottom right
			{ +0.5, +0.5 }, //  top right
			{ -0.5, +0.5 }	//  top left
		};

		for (unsigned i = 0; i < 4; ++i)
		{
			const float x = model_positions[i][0] * sdf_transform.QuadTransform[0] + model_positions[i][1] * sdf_transform.QuadTransform[3] + sdf_transform.QuadTransform[6];
			const float y = model_positions[i][0] * sdf_transform.QuadTransform[1] + model_positions[i][1] * sdf_transform.QuadTransform[4] + sdf_transform.QuadTransform[7];
			const float s = model_positions[i][0] * sdf_transform.QuadSize[0];
			const float t = model_positions[i][1] * sdf_transform.QuadSize[1];

			sdfVertexDataEnd->x			  = x;
			sdfVertexDataEnd->y			  = y;
			sdfVertexDataEnd->testPoint_s = s;
			sdfVertexDataEnd->testPoint_t = t;
			sdfVertexDataEnd->fillColor	  = fill_bytes;
			sdfVertexDataEnd->lineColor	  = line_bytes;
			sdfVertexDataEnd->worldSize_x = sdf_transform.WorldSize[0];
			sdfVertexDataEnd->worldSize_y = sdf_transform.WorldSize[1];
			sdfVertexDataEnd->lineWidth	  = static_cast<float>(line_width);
			sdfVertexDataEnd->shape		  = static_cast<int>(SDFShape::Rectangle); // 1
			sdfVertexDataEnd->depth		  = depth;

			++sdfVertexDataEnd;
		}
		sdfIndexCount += 6;

		++texture_call;
	}

	void BatchRenderer2D::DrawLine(
		[[maybe_unused]] const Math::TransformationMatrix& transform, [[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color,
		[[maybe_unused]] double line_width, float depth)
	{
		const auto line_transform = Renderer2DUtils::CalculateLineTransform(transform, start_point, end_point, line_width);
		DrawRectangle(line_transform, line_color, line_color, line_width,depth);
	}

	void BatchRenderer2D::DrawLine([[maybe_unused]] Math::vec2 start_point, [[maybe_unused]] Math::vec2 end_point, [[maybe_unused]] CS200::RGBA line_color, [[maybe_unused]] double line_width, float depth)
	{
		DrawLine(Math::TransformationMatrix{}, start_point, end_point, line_color, line_width, depth);
	}

	void BatchRenderer2D::startBatch()
	{
		vertexDataEnd	  = vertexData.data();
		indexCount		  = 0;
		activeTextureSize = 0;

		sdfVertexDataEnd = sdfVertexData.data();
		sdfIndexCount	 = 0;

	}

	void BatchRenderer2D::flush()
	{
		if (indexCount > 0)
		{
			// upload our vertices(vertex buffer is dynamic)
			const ptrdiff_t					 vertex_count  = vertexDataEnd - vertexData.data();
			const std::span					 data_span	   = std::span{ vertexData.data(), static_cast<size_t>(vertex_count) };
			const std::span<const std::byte> bytes_to_send = std::as_bytes(data_span);

			GL::BindBuffer(GL_ARRAY_BUFFER, vertexBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(QuadVertex) * maxVertices), nullptr, GL_DYNAMIC_DRAW); // orphaning

			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, vertexBufferHandle, bytes_to_send);


			// select our texture
			for (size_t i = 0; i < activeTextureSize; ++i)
			{
				GL::ActiveTexture(static_cast<GLenum>(GL_TEXTURE0 + i));
				GL::BindTexture(GL_TEXTURE_2D, textureSlots[i]);
			}

			// draw
			GL::UseProgram(texturingCombineShader.Shader);
			GL::BindVertexArray(modelHandle);
			GL::DrawElements(GL_TRIANGLES, static_cast<GLsizei>(indexCount), GL_UNSIGNED_INT, nullptr);
			++draw_call;
		}

		if (sdfIndexCount > 0)
		{
			const ptrdiff_t					 sdf_vertex_count_ptrdiff = sdfVertexDataEnd - sdfVertexData.data();
			const std::span					 sdf_data_span			  = std::span{ sdfVertexData.data(), static_cast<size_t>(sdf_vertex_count_ptrdiff) };
			const std::span<const std::byte> sdf_bytes_to_send		  = std::as_bytes(sdf_data_span);

			GL::BindBuffer(GL_ARRAY_BUFFER, sdfVertexBufferHandle);
			GL::BufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(SDFVertex) * maxVertices), nullptr, GL_DYNAMIC_DRAW); // orphaning
			OpenGL::UpdateBufferData(OpenGL::BufferType::Vertices, sdfVertexBufferHandle, sdf_bytes_to_send);

			GL::UseProgram(sdfShader.Shader);
			GL::BindVertexArray(sdfModelHandle);
			GL::DrawElements(GL_TRIANGLES, static_cast<GLsizei>(sdfIndexCount), GL_UNSIGNED_INT, nullptr);
			++draw_call;
		}


		// unbind stuff
		GL::BindVertexArray(0);
		GL::UseProgram(0);
		GL::BindTexture(GL_TEXTURE_2D, 0);
		GL::BindBuffer(GL_ARRAY_BUFFER, 0);

		startBatch(); // reset
	}

	void BatchRenderer2D::updateCameraUniformValues(const Math::TransformationMatrix& view_projection)
	{
		const auto as_3x3 = Renderer2DUtils::to_opengl_mat3(view_projection);
		for (std::size_t col = 0; col < 3; ++col)
		{
			const std::size_t src_offset = col * 3;
			const std::size_t dst_offset = col * 4;

			camera_array[dst_offset + 0] = as_3x3[src_offset + 0]; // how?****
			camera_array[dst_offset + 1] = as_3x3[src_offset + 1];
			camera_array[dst_offset + 2] = as_3x3[src_offset + 2];
			camera_array[dst_offset + 3] = 0.0f;
		}
	}

	size_t BatchRenderer2D::GetDrawCallCounter()
	{
		return draw_call;
	}

	size_t BatchRenderer2D::GetDrawTextureCounter()
	{
		return texture_call;
	}

} // namespace CS200



================================================
FILE: source/CS200/BatchRenderer2D.h
================================================
/**
 * \file
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Matrix.h"
#include "IRenderer2D.h"
#include "OpenGL/Shader.h"
#include "OpenGL/VertexArray.h"
#include <array>
#include <vector>

/**
 *
 * basic idea - either buffer is full(reached max_quads) or user invoked endscene-> draw one time
 */
namespace CS200
{
	class BatchRenderer2D : public IRenderer2D
	{
	public:
		BatchRenderer2D(unsigned max_quads = 10'000);
		BatchRenderer2D(const BatchRenderer2D& other) = delete;
		BatchRenderer2D(BatchRenderer2D&& other) noexcept;
		BatchRenderer2D& operator=(const BatchRenderer2D& other) = delete;
		BatchRenderer2D& operator=(BatchRenderer2D&& other) noexcept;
		~BatchRenderer2D() override;

		void Init() override;
		void Shutdown() override;
		// void BeginScene(std::span<const float, 9> ndc_matrix) override;
		void BeginScene(const Math::TransformationMatrix& view_projection) override;
		void EndScene() override;
		void
			DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth) override;
		// void DrawQuad(std::span<const float, 9> transform, OpenGL::Handle texture, std::span<const float, 4> texture_coords_lbrt, std::span<const float, 4> tint_color) override;
		void DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;
		void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;

	private:
		struct QuadVertex
		{
			float						 x = 0, y = 0;
			float						 s = 0, t = 0;
			std::array<unsigned char, 4> tint{};
			int							 textureIndex = 0;
			float						 depth;
		};

		std::vector<QuadVertex> vertexData{};
		OpenGL::BufferHandle	vertexBufferHandle{};

		OpenGL::CompiledShader texturingCombineShader{};

		OpenGL::VertexArrayHandle modelHandle{};

		// sdf
		struct SDFVertex
		{
			float						 x = 0, y = 0;					   // Layout 0: aWorldPosition
			float						 testPoint_s = 0, testPoint_t = 0; // Layout 1: aTestPoint
			std::array<unsigned char, 4> fillColor{};					   // Layout 2: aFillColor
			std::array<unsigned char, 4> lineColor{};					   // Layout 3: aLineColor
			float						 worldSize_x = 0, worldSize_y = 0; // Layout 4: aWorldSize
			float						 lineWidth = 0;					   // Layout 5: aLineWidth
			int							 shape	   = 0;					   // Layout 6: aShape (0=Circle, 1=Rect)
			float						 depth	   = 0;					   // Layout 7: aDepth
		};

		std::vector<SDFVertex>	  sdfVertexData{};
		OpenGL::BufferHandle	  sdfVertexBufferHandle{};
		OpenGL::CompiledShader	  sdfShader{};
		OpenGL::VertexArrayHandle sdfModelHandle{};
		SDFVertex*				  sdfVertexDataEnd = nullptr; // pointing where we are
		unsigned				  sdfIndexCount	   = 0;

		OpenGL::BufferHandle	   indexBufferHandle{};
		OpenGL::BufferHandle	   camera_uniform_buffer{};
		std::array<float, 12>	   camera_array{};
		Math::TransformationMatrix currentCameraMatrix{};
		// limit how much we're going to put into that vertex buffer
		unsigned				   maxVertices = 0;
		unsigned				   maxIndices  = 0;

		void updateCameraUniformValues(const Math::TransformationMatrix& view_projection);


		enum class SDFShape : uint8_t
		{
			Circle	  = 0,
			Rectangle = 1,
		};
		// void DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape);


		QuadVertex* vertexDataEnd = nullptr; // pointing where we are
		unsigned	indexCount	  = 0;

		// OpenGL::Handle theTexture = 0;
		std::vector<OpenGL::TextureHandle> textureSlots;
		size_t							   activeTextureSize = 0;

	private:
		void flush(); // when quad amount is reached to max_quad
		void startBatch();

		size_t draw_call = 0;
		size_t GetDrawCallCounter() override;

		size_t texture_call = 0;
		size_t GetDrawTextureCounter() override;
	};

}



================================================
FILE: source/CS200/Image.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "Image.h"

#include "Engine/Error.h"
#include "Engine/Path.h"

#include <stb_image.h>
#include <utility>

namespace CS200
{
    Image::Image(const std::filesystem::path& image_path, bool flip_vertical)
    {
        const std::filesystem::path image_path_ctor = assets::locate_asset(image_path);
        stbi_set_flip_vertically_on_load(flip_vertical);
        constexpr int num_channels       = 4;                                                                                                            // rgba
        int           files_num_channels = 0;                                                                                                            // to here
        image_data                       = stbi_load(image_path_ctor.string().c_str(), &dimensions.x, &dimensions.y, &files_num_channels, num_channels); // loading, use dynamic memory so we need free
        if (!image_data)
        {
            throw_error_message("Loading Fail ");
        }
    }

    Image::Image(Image&& temporary) noexcept : image_data{ temporary.image_data }, dimensions{ temporary.dimensions }
    {
        temporary.image_data = nullptr;
        temporary.dimensions = { 0, 0 };
    }

    Image& Image::operator=(Image&& temporary) noexcept
    {
        std::swap(image_data, temporary.image_data);
        std::swap(dimensions, temporary.dimensions);
        return *this;
    }

    Image::~Image()
    {
        if (image_data)
        {
            stbi_image_free(image_data);
        }
    }

    const RGBA* Image::data() const noexcept
    {
        return reinterpret_cast<const RGBA*>(image_data);
    }

    RGBA* Image::data() noexcept
    {
        return reinterpret_cast<RGBA*>(image_data);
    }

    Math::ivec2 Image::GetSize() const noexcept
    {
        return dimensions;
    }


    
}



================================================
FILE: source/CS200/Image.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Vec2.h"
#include "RGBA.h"
#include <filesystem>
#include <gsl/gsl>

#include <stb_image.h>

namespace CS200
{
    /**
     * \brief RAII wrapper for loading and managing image pixel data from files
     *
     * The Image class provides a safe, automatic way to load image files (PNG, JPG, etc.)
     * and access their pixel data for use in graphics applications. It handles all the
     * complexity of file loading, memory management, and data conversion.
     *
     * Key Features:
     * - Automatic file loading using stb_image library
     * - Always converts to consistent RGBA format (4 bytes, 32bits per pixel)
     * - RAII memory management (automatic cleanup in destructor)
     * - Move-only semantics to prevent expensive copying
     * - Optional vertical flipping for different coordinate systems
     *
     * Common Use Cases:
     * - Loading textures for sprites, backgrounds, UI elements
     * - Reading image data for procedural generation or analysis
     * - Converting various image formats to a consistent RGBA format
     * - Preparing pixel data for upload to GPU textures
     *
     * Memory Layout:
     * - Pixels stored in row-major order (left-to-right, top-to-bottom)
     * - Each pixel is 4 bytes: Red, Green, Blue, Alpha (0-255 each)
     * - Total memory = width 횞 height 횞 4 bytes
     *
     * Example Usage:
     * \code
     * // Load an image file
     * Image sprite_image("sprites/player.png");
     *
     * // Get image properties
     * auto size = sprite_image.GetSize();
     * int width = size.x, height = size.y;
     *
     * // Access pixel data
     * const RGBA* pixels = sprite_image.data();
     * RGBA top_left_pixel = pixels[0];
     *
     * // Move to another Image (efficient)
     * Image moved_image = std::move(sprite_image);
     * \endcode
     */
    class Image
    {
    public:
        /**
         * \brief Load an image from file and store its pixel data
         * \param image_path Path to the image file (relative to Assets folder, like "Assets/ship.png")
         * \param flip_vertical Whether to flip the image vertically when loading (default: false)
         *
         * Implementation notes:
         * - Use assets::locate_asset() to find the full file path
         * - Use stb_image library functions to load the image data
         * - Always load as 4-channel RGBA regardless of source format
         * - Set stbi_set_flip_vertically_on_load() before loading
         * - Throw an error if loading fails
         * - Store the loaded pixel data and image dimensions
         */
        explicit Image(const std::filesystem::path& image_path, bool flip_vertical = false);

        /**
         * \brief Copy constructor - deleted to prevent accidental copying
         * Images manage dynamic memory and should not be copied
         */
        Image(const Image&) = delete;

        /**
         * \brief Copy assignment - deleted to prevent accidental copying
         * Images manage dynamic memory and should not be copied
         */
        Image& operator=(const Image&) = delete;

        /**
         * \brief Move constructor - transfer ownership of image data
         * \param temporary The temporary Image object to move from
         *
         * Implementation notes:
         * - Transfer ownership of pixel data pointer and size
         * - Set the source object's data to nullptr and size to {0,0}
         * - Use noexcept to enable move optimizations
         */
        Image(Image&& temporary) noexcept;

        /**
         * \brief Move assignment - transfer ownership of image data
         * \param temporary The temporary Image object to move from
         * \return Reference to this object
         *
         * Implementation notes:
         * - Use std::swap to exchange data between objects
         * - This safely handles self-assignment and cleanup
         */
        Image& operator=(Image&& temporary) noexcept;

        /**
         * \brief Destructor - free the allocated image data
         *
         * Implementation notes:
         * - Check if pixel data pointer is not nullptr
         * - Use stbi_image_free() to properly release memory allocated by stb_image
         */
        ~Image();

        /**
         * \brief Get read-only access to the pixel data array
         * \return Const pointer to the first RGBA pixel
         *
         * Implementation notes:
         * - Return the stored pixel data pointer as const
         * - Pixels are stored in row-major order (left-to-right, top-to-bottom)
         */
        const RGBA* data() const noexcept;

        /**
         * \brief Get read-write access to the pixel data array
         * \return Pointer to the first RGBA pixel for modification
         *
         * Implementation notes:
         * - Return the stored pixel data pointer for modification
         * - Pixels are stored in row-major order (left-to-right, top-to-bottom)
         */
        RGBA* data() noexcept;

        /**
         * \brief Get the dimensions of the loaded image
         * \return Vector containing width (x) and height (y) in pixels
         *
         * Implementation notes:
         * - Return the stored image dimensions
         * - Width and height are set during image loading
         */
        Math::ivec2 GetSize() const noexcept;

    private:
        
        stbi_uc*    image_data = nullptr;
        Math::ivec2 dimensions;
    };

}



================================================
FILE: source/CS200/ImGuiHelper.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "ImGuiHelper.h"

#include <SDL.h>
#include <backends/imgui_impl_opengl3.h>
#include <backends/imgui_impl_sdl2.h>
#include <imgui.h>
#include <imgui_internal.h> // for DockBuilderGetCentralNode until they stabilize make DockBuilder

namespace
{
    std::string   gImGuiSaveFilePath;
    SDL_Window*   gCachedWindow    = nullptr;
    SDL_GLContext gCachedGLContext = nullptr;
}

namespace ImGuiHelper
{
    void Initialize(gsl::not_null<SDL_Window*> sdl_window, gsl::not_null<SDL_GLContext> gl_context, const std::filesystem::path& ini_file_path)
    {
        // Cache the window and context for later use
        gCachedWindow    = sdl_window;
        gCachedGLContext = gl_context;

        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        {
            ImGuiIO& io = ImGui::GetIO();
            io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
            io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;
            gImGuiSaveFilePath = ini_file_path.string();
            io.IniFilename     = gImGuiSaveFilePath.c_str();
        }
        ImGui_ImplSDL2_InitForOpenGL(sdl_window, gl_context);
        ImGui_ImplOpenGL3_Init();
    }

    void FeedEvent(const SDL_Event& event)
    {
        ImGui_ImplSDL2_ProcessEvent(&event);
    }

    Viewport Begin()
    {
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame();
        ImGui::NewFrame();

        // enable docking on main window, based off of imgui docking demo
        {
            const ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_PassthruCentralNode | ImGuiDockNodeFlags_NoDockingInCentralNode;
            const ImGuiWindowFlags   window_flags = ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize |
                                                  ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
            const ImGuiViewport* const main_viewport   = ImGui::GetMainViewport();
            const auto                 window_position = main_viewport->Pos;
            const auto                 window_size     = main_viewport->Size;
            ImGui::SetNextWindowPos(window_position);
            ImGui::SetNextWindowSize(window_size);
            ImGui::SetNextWindowViewport(main_viewport->ID);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
            ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
            ImGui::Begin("Main Window Dockspace", nullptr, window_flags);
            ImGui::PopStyleVar(3);
            const ImGuiID dockspace_id = ImGui::GetID("Main Window Dockspace");
            ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);

            // How to get central area : https://github.com/ocornut/imgui/issues/5921#issuecomment-1327801959
            // Central Node is the middle area where we want the main display to be
            const ImGuiDockNode* const node = ImGui::DockBuilderGetCentralNode(dockspace_id);
            if (node == nullptr) [[unlikely]]
                return Viewport{ 0, 0, static_cast<int>(window_size.x), static_cast<int>(window_size.y) };
            // the central node's position is relative to the monitor, so we need main viewport to turn relative to the window
            const int opengl_x = static_cast<int>((node->Pos.x - window_position.x)); // convert relative to window x
            const int opengl_y =
                static_cast<int>((window_size.y - ((node->Pos.y - window_position.y) + node->Size.y))); // convert relative to window x and then convert to opengl convention where 0,0 is bottom left
            const int opengl_w = static_cast<int>(node->Size.x);                                        // width of central node is what we want
            const int opengl_h = static_cast<int>(node->Size.y);                                        // height of central node is what we want
            ImGui::End();                                                                               // end main window docking
            return Viewport{ opengl_x, opengl_y, opengl_w, opengl_h };
        }
    }

    void End()
    {
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        const ImGuiIO& io = ImGui::GetIO();
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            ImGui::UpdatePlatformWindows();
            ImGui::RenderPlatformWindowsDefault();
            SDL_GL_MakeCurrent(gCachedWindow, gCachedGLContext);
        }
    }

    void Shutdown()
    {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplSDL2_Shutdown();
        ImGui::DestroyContext();

        gCachedWindow    = nullptr;
        gCachedGLContext = nullptr;
    }
}



================================================
FILE: source/CS200/ImGuiHelper.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include <filesystem>
#include <gsl/gsl>

struct SDL_Window;
typedef void* SDL_GLContext;
union SDL_Event;

namespace ImGuiHelper
{
    void Initialize(gsl::not_null<SDL_Window*> sdl_window, gsl::not_null<SDL_GLContext> gl_context, const std::filesystem::path& ini_file_path = "imgui.ini");
    void FeedEvent(const SDL_Event& event);

    struct Viewport
    {
        int  x = 0, y = 0;
        int  width = 0, height = 0;
        bool operator==(const Viewport&) const = default;
    };

    Viewport Begin();
    void     End();
    void     Shutdown();

}



================================================
FILE: source/CS200/ImmediateRenderer2D.cpp
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#include "ImmediateRenderer2D.h"
#include "Engine/Engine.h"
#include "Engine/Matrix.h"
#include "Engine/Path.h"
#include "Engine/Texture.h"
#include "Engine/Window.h"
#include "NDC.h"
#include "OpenGL/Buffer.h"
#include "OpenGL/GL.h"
#include "Renderer2DUtils.h"
#include "RenderingAPI.h"
#include <span>
#include <utility>

namespace CS200
{


    void ImmediateRenderer2D::Init()
    {
        /** - Create index buffer with quad indices (0,1,2,2,3,0)
         * - Create vertex buffer with quad vertices (-0.5 to 0.5 range)
         * - Set up VAO with position and texture coordinate attributes
         * - Create SDF vertex buffer (position-only attributes) */

        //- Load and compile vertex/fragment shaders from Assets/shaders/
        const std::filesystem::path vertex_file   = assets::locate_asset("Assets/shaders/ImmediateRenderer2D/quad.vert");
        const std::filesystem::path fragment_file = assets::locate_asset("Assets/shaders/ImmediateRenderer2D/quad.frag");
        texturingCombineShader                    = OpenGL::CreateShader(vertex_file, fragment_file);

        sdfShader = OpenGL::CreateShader(assets::locate_asset("Assets/shaders/ImmediateRenderer2D/sdf.vert"), assets::locate_asset("Assets/shaders/ImmediateRenderer2D/sdf.frag"));

        struct position
        {
            float x, y;
        };

        struct texture_coordinate
        {
            float s, t;
        };

        constexpr std::array positions = {
            position{ -0.5f, -0.5f }, // bottom-left
            position{ -0.5f,  0.5f }, // top-left
            position{  0.5f,  0.5f }, // top-right
            position{  0.5f, -0.5f }  // bottom-right
        };

        constexpr std::array texture_coordinates = {
            texture_coordinate{ 0.0f, 0.0f }, // bottom-left
            texture_coordinate{ 0.0f, 1.0f }, // top-left
            texture_coordinate{ 1.0f, 1.0f }, // top-right
            texture_coordinate{ 1.0f, 0.0f }  // bottom-right
        };

        constexpr std::array<unsigned char, 6> indices = { 0, 3, 2, 0, 2, 1 };

        quad.positionBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ positions }));
        quad.texCoordBufferHandle = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ texture_coordinates }));
        quad.indexBufferHandle    = OpenGL::CreateBuffer(OpenGL::BufferType::Indices, std::as_bytes(std::span{ indices }));
        quad.indicesCount         = static_cast<GLsizei>(indices.size());
        const auto layout         = {
            OpenGL::VertexBuffer{ quad.positionBufferHandle, { OpenGL::Attribute::Float2 } },
            OpenGL::VertexBuffer{ quad.texCoordBufferHandle, { OpenGL::Attribute::Float2 } }
        };
        quad.modelHandle = OpenGL::CreateVertexArrayObject(layout, quad.indexBufferHandle);


        //- Create SDF vertex buffer (position-only attributes)

        sdfBufferHandle                 = OpenGL::CreateBuffer(OpenGL::BufferType::Vertices, std::as_bytes(std::span{ positions }));
        const auto layout_position_only = {
            OpenGL::VertexBuffer{ quad.positionBufferHandle, { OpenGL::Attribute::Float2 } }
        };
        sdfVeretexArrayHandle = OpenGL::CreateVertexArrayObject(layout_position_only, quad.indexBufferHandle);
        //- Create uniform buffer for camera/view-projection matrix
       camera_uniform_buffer = OpenGL::CreateBuffer(OpenGL::BufferType::UniformBlocks, sizeof(camera_array));


        //- Bind uniform buffer to both shaders with name "Camera"
        //OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");
    }

    void ImmediateRenderer2D::Shutdown()
    {
        OpenGL::DestroyShader(texturingCombineShader);
        OpenGL::DestroyShader(sdfShader);

        GL::DeleteBuffers(1, &quad.positionBufferHandle), quad.positionBufferHandle = 0;
        GL::DeleteBuffers(1, &quad.texCoordBufferHandle), quad.texCoordBufferHandle = 0;
        GL::DeleteBuffers(1, &quad.indexBufferHandle), quad.indexBufferHandle       = 0;
        GL::DeleteBuffers(1, &sdfBufferHandle), sdfBufferHandle                     = 0;
        GL::DeleteBuffers(1, &camera_uniform_buffer), camera_uniform_buffer         = 0;

        GL::DeleteVertexArrays(1, &quad.modelHandle), quad.modelHandle           = 0;
        GL::DeleteVertexArrays(1, &sdfVeretexArrayHandle), sdfVeretexArrayHandle = 0;
    }

    void ImmediateRenderer2D::BeginScene([[maybe_unused]] const Math::TransformationMatrix& view_projection)
    {
        //- Store matrix for potential later use
        currentCameraMatrix = view_projection;

        //- Convert 3x3 matrix to 4x3 format for uniform buffer
        updateCameraUniformValues(currentCameraMatrix);

        //- Update uniform buffer with new matrix data
        OpenGL::UpdateBufferData(OpenGL::BufferType::UniformBlocks, camera_uniform_buffer, std::as_bytes(std::span{ camera_array }));

        //- Bind uniform buffer for use by shaders
        GL::BindBuffer(GL_UNIFORM_BUFFER, camera_uniform_buffer);

        OpenGL::BindUniformBufferToShader(texturingCombineShader.Shader, 0, camera_uniform_buffer, "NDC");

        draw_call = 0;
		texture_call = 0;
    }

    void ImmediateRenderer2D::EndScene()
    {
		
    }

    void ImmediateRenderer2D::DrawQuad(
		[[maybe_unused]] const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth)
    {
        //- Bind texture to texture unit 0
        GL::UseProgram(texturingCombineShader.Shader);
        GL::ActiveTexture(GL_TEXTURE0);
        GL::BindTexture(GL_TEXTURE_2D, texture);

        // - Calculate texture coordinate transformation matrix - by bl and tr, and translate to opengl version !!
        std::array<float, 9> texture_transform = { static_cast<float>(texture_coord_tr.x - texture_coord_bl.x),
                                                   0.f,
                                                   0.f, // column1
                                                   0.f,
                                                   static_cast<float>(texture_coord_tr.y - texture_coord_bl.y),
                                                   0.f, // column2
                                                   static_cast<float>(texture_coord_bl.x),
                                                   static_cast<float>(texture_coord_bl.y),
                                                   1.f };

        //- Set shader uniforms: model matrix, depth, texture transform, tint color
        const auto& locations = texturingCombineShader.UniformLocations;
        GL::Uniform1i(locations.at("uTex2d"), 0);

        const auto world_transform_opengl = Renderer2DUtils::to_opengl_mat3(transform);
        // std::array<float,9> world_transform_opengl{ 128.f, 0.0f, 0.0f, 0.0f, 128.f, 0.0f, 0.0f,0.0f, 1.0f };
        GL::UniformMatrix3fv(locations.at("uModel"), 1, GL_FALSE, world_transform_opengl.data());

        GL::UniformMatrix3fv(locations.at("uTexCoordTransform"), 1, GL_FALSE, texture_transform.data());


        GL::Uniform1f(locations.at("uDepth"), depth);


        const auto colors = unpack_color(tintColor);
        GL::Uniform4f(locations.at("uTint"), colors[0], colors[1], colors[2], colors[3]);


        //- Draw using quad VAO and index buffer
        GL::BindVertexArray(quad.modelHandle);
        constexpr GLenum  primitive_pattern        = GL_TRIANGLES;
        constexpr GLenum  indices_type             = GL_UNSIGNED_BYTE;
        constexpr GLvoid* byte_offset_into_indices = nullptr;
        GL::DrawElements(primitive_pattern, quad.indicesCount, indices_type, byte_offset_into_indices);
		++draw_call;
		++texture_call;
        GL::BindTexture(GL_TEXTURE_2D, 0);
        GL::BindVertexArray(0);
        GL::UseProgram(0);
    }

    void ImmediateRenderer2D::DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawSDF(transform, fill_color, line_color, line_width, SDFShape::Circle, depth);
    }

    void ImmediateRenderer2D::DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawSDF(transform, fill_color, line_color, line_width, SDFShape::Rectangle, depth);
    }

    void ImmediateRenderer2D::DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth)
    {
        const auto line_transform = Renderer2DUtils::CalculateLineTransform(transform, start_point, end_point, line_width);
        DrawSDF(line_transform, line_color, line_color, line_width, SDFShape::Rectangle, depth);
    }

    void ImmediateRenderer2D::DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth)
    {
        DrawLine(Math::TransformationMatrix{}, start_point, end_point, line_color, line_width, depth);
    }

    void ImmediateRenderer2D::updateCameraUniformValues(const Math::TransformationMatrix& view_projection)
    {
        const auto as_3x3 = Renderer2DUtils::to_opengl_mat3(view_projection);
        for (std::size_t col = 0; col < 3; ++col)
        {
            const std::size_t src_offset = col * 3;
            const std::size_t dst_offset = col * 4;

            camera_array[dst_offset + 0] = as_3x3[src_offset + 0]; // how?****
            camera_array[dst_offset + 1] = as_3x3[src_offset + 1];
            camera_array[dst_offset + 2] = as_3x3[src_offset + 2];
            camera_array[dst_offset + 3] = 0.0f;
        }
    }

    void ImmediateRenderer2D::DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape, float depth)
    {
        GL::UseProgram(sdfShader.Shader);
        // Calculate SDF-specific transform using Renderer2DUtils::CalculateSDFTransform()
        const auto  sdf_transform = Renderer2DUtils::CalculateSDFTransform(transform, line_width);
        // Set all SDF shader uniforms (model, colors, size, line width, shape type)
        const auto& locations     = sdfShader.UniformLocations;

        // vertex
       //GL::UniformMatrix3fv(locations.at("uToNDC"), 1, GL_FALSE, CS200::Renderer2DUtils::to_opengl_mat3(CS200::build_ndc_matrix(Engine::GetWindow().GetSize())).data());
        GL::UniformMatrix3fv(locations.at("uModel"), 1, GL_FALSE, sdf_transform.QuadTransform.data());
        GL::Uniform2f(locations.at("uSDFScale"), sdf_transform.QuadSize[0], sdf_transform.QuadSize[1]);
        GL::Uniform1f(locations.at("uDepth"), depth);

        // fragment
        GL::Uniform4fv(locations.at("uFillColor"), 1, CS200::unpack_color(fill_color).data());
        GL::Uniform4fv(locations.at("uLineColor"), 1, CS200::unpack_color(line_color).data());
        GL::Uniform2fv(locations.at("uWorldSize"), 1, sdf_transform.WorldSize.data());
        GL::Uniform1f(locations.at("uLineWidth"), static_cast<float>(line_width));
        GL::Uniform1i(locations.at("uShape"), static_cast<int>(sdf_shape));

        // Use SDF vertex array and draw triangles
        GL::BindVertexArray(sdfVeretexArrayHandle);
        constexpr GLenum  primitive_pattern        = GL_TRIANGLES;
        constexpr GLenum  indices_type             = GL_UNSIGNED_BYTE;
        constexpr GLvoid* byte_offset_into_indices = nullptr;
        GL::DrawElements(primitive_pattern, quad.indicesCount, indices_type, byte_offset_into_indices);
		++draw_call;
		++texture_call;
        // Shape rendering handled entirely in fragment shader
        GL::BindVertexArray(0);
        GL::UseProgram(0);
	}

	size_t ImmediateRenderer2D::GetDrawCallCounter()
	{
		return draw_call;
	}

	size_t ImmediateRenderer2D::GetDrawTextureCounter()
	{
		return texture_call;
	}


    ImmediateRenderer2D::ImmediateRenderer2D(ImmediateRenderer2D&& other) noexcept
		: quad(other.quad),												   // 1.
		  texturingCombineShader(std::move(other.texturingCombineShader)), // 2.
		  camera_uniform_buffer(other.camera_uniform_buffer),			   // 3.
		  sdfBufferHandle(other.sdfBufferHandle),						   // 4.
		  sdfShader(std::move(other.sdfShader)),						   // 5.
		  sdfVeretexArrayHandle(other.sdfVeretexArrayHandle),			   // 6.
		  camera_array(other.camera_array),								   // 7.
		  currentCameraMatrix(other.currentCameraMatrix),				   // 8.
		  draw_call(other.draw_call),									   // 9.
		  texture_call(other.texture_call)								   // 10.
    {
		other.quad.positionBufferHandle = 0;
		other.quad.texCoordBufferHandle = 0;
		other.quad.indexBufferHandle	= 0;
		other.quad.indicesCount			= 0;
		other.quad.modelHandle			= 0;

		other.texturingCombineShader = {};
		other.camera_uniform_buffer	 = 0;
		other.sdfBufferHandle		 = 0;
		other.sdfShader				 = {};
		other.sdfVeretexArrayHandle	 = 0;

        other.draw_call	   = 0;
		other.texture_call = 0;
    }

    ImmediateRenderer2D& ImmediateRenderer2D::operator=(ImmediateRenderer2D&& other) noexcept
    {
        //- Use std::swap to exchange all resources
        //- Safely handles self-assignment

        if (this == &other)
		{
			return *this;
		}

		std::swap(quad, other.quad);
		std::swap(texturingCombineShader, other.texturingCombineShader);
		std::swap(camera_uniform_buffer, other.camera_uniform_buffer);
		std::swap(sdfBufferHandle, other.sdfBufferHandle);
		std::swap(sdfShader, other.sdfShader);
		std::swap(sdfVeretexArrayHandle, other.sdfVeretexArrayHandle);
		std::swap(camera_array, other.camera_array);
		std::swap(currentCameraMatrix, other.currentCameraMatrix);
		std::swap(draw_call, other.draw_call);
		std::swap(texture_call, other.texture_call);

		return *this;
    }

    ImmediateRenderer2D::~ImmediateRenderer2D()
    {
        Shutdown();
    }
}



================================================
FILE: source/CS200/ImmediateRenderer2D.h
================================================
/**
 * \file
 * \author Rudy Castan
 * \author Taekyung Ho
 * \date 2025 Fall
 * \par CS200 Computer Graphics I
 * \copyright DigiPen Institute of Technology
 */
#pragma once

#include "Engine/Matrix.h"
#include "IRenderer2D.h"
#include "OpenGL/Shader.h"
#include "OpenGL/VertexArray.h"
#include <array>

namespace CS200
{
	/**
	 * \brief Immediate-mode 2D renderer for drawing sprites, shapes, and lines
	 *
	 * ImmediateRenderer2D provides a simple, immediate-mode interface for 2D graphics rendering.
	 * "Immediate mode" means each draw call renders directly to the screen without batching or
	 * optimization - perfect for learning graphics programming and prototyping.
	 *
	 * Key Features:
	 * - Textured quad rendering with tint colors and texture coordinate mapping
	 * - SDF (Signed Distance Field) based shape rendering for perfect circles and rectangles
	 * - Line rendering with arbitrary thickness
	 * - Camera/view-projection matrix support for world-to-screen transformations
	 * - Hardware-accelerated OpenGL rendering with custom shaders
	 *
	 * Rendering Pipeline:
	 * 1. Init() - Set up OpenGL resources (shaders, buffers, vertex arrays)
	 * 2. BeginScene() - Set camera/view matrix for the frame
	 * 3. Draw*() calls - Render individual primitives immediately
	 * 4. EndScene() - Finalize the frame (currently no-op)
	 * 5. Shutdown() - Clean up OpenGL resources
	 *
	 * Technical Implementation:
	 * - Uses two rendering paths: textured quads and SDF shapes
	 * - Quad rendering: Standard texture mapping with transform and tint
	 * - SDF rendering: Fragment shader-based shapes with perfect edges and outlines
	 * - Uniform buffer for camera data shared between shaders
	 * - Immediate submission to GPU (no batching)
	 *
	 * Common Use Cases:
	 * - Sprite rendering for games (characters, backgrounds, UI)
	 * - Debug visualization (bounding boxes, collision shapes)
	 * - Simple 2D graphics applications
	 * - Educational graphics programming
	 *
	 * Example Usage:
	 * \code
	 * // Create and initialize renderer (typically done in Engine initialization)
	 * ImmediateRenderer2D renderer;
	 * renderer.Init();
	 *
	 * // In your game loop update/draw function:
	 *
	 * // Set up NDC camera matrix for screen-space rendering
	 * Math::ivec2 screen_size = {800, 600};  // Your window/viewport size
	 * auto ndc_matrix = CS200::build_ndc_matrix(screen_size);
	 * renderer.BeginScene(ndc_matrix);
	 *
	 * // Draw a textured sprite (position/rotation/scale transform)
	 * auto sprite_transform = Math::TranslationMatrix({100, 200}) *
	 *                        Math::RotationMatrix(45.0) *
	 *                        Math::ScaleMatrix({64, 64});
	 * renderer.DrawQuad(sprite_transform, texture_handle, {0,0}, {1,1}, CS200::WHITE);
	 *
	 * // Draw shapes with fills and outlines
	 * auto circle_transform = Math::TranslationMatrix({300, 300}) * Math::ScaleMatrix({50, 50});
	 * renderer.DrawCircle(circle_transform, CS200::WHITE, CS200::BLACK, 2.0);
	 *
	 * // Draw debug lines
	 * renderer.DrawLine({0, 0}, {100, 100}, CS200::WHITE, 1.0);
	 *
	 * renderer.EndScene();
	 *
	 * // Cleanup when shutting down
	 * renderer.Shutdown();
	 * \endcode
	 */
	class ImmediateRenderer2D : public IRenderer2D
	{
	public:
		/**
		 * \brief Default constructor - creates uninitialized renderer
		 *
		 * Implementation notes:
		 * - Initialize all handles/resources to invalid/zero values
		 * - Must call Init() before use
		 */
		ImmediateRenderer2D() = default;

		/**
		 * \brief Copy constructor deleted - renderer manages unique OpenGL resources
		 */
		ImmediateRenderer2D(const ImmediateRenderer2D& other) = delete;

		/**
		 * \brief Move constructor - transfer ownership of OpenGL resources
		 * \param other The renderer to move from
		 *
		 * Implementation notes:
		 * - Transfer all OpenGL handles (VAOs, buffers, shaders)
		 * - Set source object's handles to zero/invalid
		 * - Move shader objects using std::move()
		 * - Copy view projection matrix data
		 */
		ImmediateRenderer2D(ImmediateRenderer2D&& other) noexcept;

		/**
		 * \brief Copy assignment deleted - renderer manages unique OpenGL resources
		 */
		ImmediateRenderer2D& operator=(const ImmediateRenderer2D& other) = delete;

		/**
		 * \brief Move assignment - transfer ownership of OpenGL resources
		 * \param other The renderer to move from
		 * \return Reference to this object
		 *
		 * Implementation notes:
		 * - Use std::swap to exchange all resources
		 * - Safely handles self-assignment
		 * - Automatic cleanup of previous resources
		 */
		ImmediateRenderer2D& operator=(ImmediateRenderer2D&& other) noexcept;

		/**
		 * \brief Destructor - automatically cleans up OpenGL resources
		 *
		 * Implementation notes:
		 * - Call Shutdown() to clean up resources
		 * - Safe to call even if Init() was never called
		 */
		~ImmediateRenderer2D() override;

		/**
		 * \brief Initialize OpenGL resources for rendering
		 *
		 * Implementation notes:
		 * - Create index buffer with quad indices (0,1,2,2,3,0)
		 * - Create vertex buffer with quad vertices (-0.5 to 0.5 range)
		 * - Set up VAO with position and texture coordinate attributes
		 * - Create SDF vertex buffer (position-only attributes)
		 * - Load and compile vertex/fragment shaders from Assets/shaders/
		 * - Create uniform buffer for camera/view-projection matrix
		 * - Bind uniform buffer to both shaders with name "Camera"
		 */
		void Init() override;

		/**
		 * \brief Clean up all OpenGL resources
		 *
		 * Implementation notes:
		 * - Delete all vertex arrays, buffers using OpenGL delete functions
		 * - Destroy shader programs using OpenGL::DestroyShader()
		 * - Set all handles back to zero/invalid
		 * - Safe to call multiple times
		 */
		void Shutdown() override;

		/**
		 * \brief Begin a new frame with camera/view transformation
		 * \param view_projection Combined view and projection matrix for the frame
		 *
		 * Implementation notes:
		 * - Convert 3x3 matrix to 4x3 format for uniform buffer
		 * - Update uniform buffer with new matrix data
		 * - Bind uniform buffer for use by shaders
		 * - Store matrix for potential later use
		 */
		void BeginScene(const Math::TransformationMatrix& view_projection) override;

		/**
		 * \brief End the current frame (currently no operations needed)
		 *
		 * Implementation notes:
		 * - No cleanup or finalization needed for immediate mode
		 * - Could be used for debugging/profiling in future
		 */
		void EndScene() override;

		/**
		 * \brief Draw a textured quad with transformation and tinting
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param texture OpenGL texture handle to sample from
		 * \param texture_coord_bl Bottom-left texture coordinate (typically {0,0})
		 * \param texture_coord_tr Top-right texture coordinate (typically {1,1})
		 * \param tintColor Color to multiply with texture (RGBA::White for no tint)
		 *
		 * Implementation notes:
		 * - Calculate texture coordinate transformation matrix
		 * - Set shader uniforms: model matrix, depth, texture transform, tint color
		 * - Bind texture to texture unit 0
		 * - Draw using quad VAO and index buffer
		 * - Use GL_TRIANGLES with 6 indices (2 triangles)
		 */
		void
			DrawQuad(const Math::TransformationMatrix& transform, OpenGL::TextureHandle texture, Math::vec2 texture_coord_bl, Math::vec2 texture_coord_tr, CS200::RGBA tintColor, float depth) override;

		/**
		 * \brief Draw a filled circle with optional outline using SDF rendering
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param fill_color Interior color of the circle
		 * \param line_color Outline color of the circle
		 * \param line_width Width of the outline in world units
		 *
		 * Implementation notes:
		 * - Use SDF (Signed Distance Field) shader for perfect circle
		 * - Call DrawSDF() with SDFShape::Circle
		 * - Radius determined by transform scale
		 */
		void DrawCircle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a filled rectangle with optional outline using SDF rendering
		 * \param transform World transformation matrix (position, rotation, scale)
		 * \param fill_color Interior color of the rectangle
		 * \param line_color Outline color of the rectangle
		 * \param line_width Width of the outline in world units
		 *
		 * Implementation notes:
		 * - Use SDF (Signed Distance Field) shader for perfect rectangle
		 * - Call DrawSDF() with SDFShape::Rectangle
		 * - Size determined by transform scale
		 */
		void DrawRectangle(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a line segment with specified thickness
		 * \param transform Additional transformation to apply to the line
		 * \param start_point Starting point of the line in local coordinates
		 * \param end_point Ending point of the line in local coordinates
		 * \param line_color Color of the line
		 * \param line_width Thickness of the line in world units
		 *
		 * Implementation notes:
		 * - Calculate line transformation using Renderer2DUtils::CalculateLineTransform()
		 * - Draw as a rotated/scaled rectangle using SDF rendering
		 * - Both fill and line colors set to same value
		 */
		void DrawLine(const Math::TransformationMatrix& transform, Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;
		/**
		 * \brief Draw a line segment with specified thickness (identity transform)
		 * \param start_point Starting point of the line in world coordinates
		 * \param end_point Ending point of the line in world coordinates
		 * \param line_color Color of the line
		 * \param line_width Thickness of the line in world units
		 *
		 * Implementation notes:
		 * - Convenience overload that calls other DrawLine() with identity matrix
		 * - Useful for simple line drawing without additional transformations
		 */
		void DrawLine(Math::vec2 start_point, Math::vec2 end_point, CS200::RGBA line_color, double line_width, float depth) override;


	private:

		struct object
		{
			OpenGL::BufferHandle	  positionBufferHandle{};
			OpenGL::BufferHandle	  texCoordBufferHandle{};
			OpenGL::BufferHandle	  indexBufferHandle{};
			GLsizei					  indicesCount{};
			OpenGL::VertexArrayHandle modelHandle{};
		} quad{};

		OpenGL::CompiledShader texturingCombineShader{};
		OpenGL::BufferHandle   camera_uniform_buffer{};

		// sdf
		OpenGL::BufferHandle	  sdfBufferHandle{};
		OpenGL::CompiledShader	  sdfShader{};
		OpenGL::VertexArrayHandle sdfVeretexArrayHandle{};

		std::array<float, 12> camera_array{};

		/**
		 * \brief Helper function for converting 3x3 matrix to 4x3 format for uniform buffer
		 * \param view_projection Combined view and projection matrix for the frame
		 *
		 */
		void updateCameraUniformValues(const Math::TransformationMatrix& view_projection);

		Math::TransformationMatrix currentCameraMatrix{};

		// SDF Shape identifiers - must be kept in sync with sdf.frag shader
		enum class SDFShape : uint8_t
		{
			Circle	  = 0,
			Rectangle = 1,
		};

		/**
		 * \brief Internal SDF rendering function used by shape drawing methods
		 * \param transform World transformation matrix
		 * \param fill_color Interior color of the shape
		 * \param line_color Outline color of the shape
		 * \param line_width Width of the outline in world units
		 * \param sdf_shape Type of SDF shape to render
		 *
		 * Implementation notes:
		 * - Calculate SDF-specific transform using Renderer2DUtils::CalculateSDFTransform()
		 * - Set all SDF shader uniforms (model, colors, size, line width, shape type)
		 * - Use SDF vertex array and draw triangles
		 * - Shape rendering handled entirely in fragment shader
		 */
		void DrawSDF(const Math::TransformationMatrix& transform, CS200::RGBA fill_color, CS200::RGBA line_color, double line_width, SDFShape sdf_shape, float depth);

		size_t draw_call = 0;
		size_t GetDrawCallCounter() override;

		size_t texture_call = 0;
		size_t GetDrawTextureCounter() override;
	};
}



